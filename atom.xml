<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-11T10:46:02.947Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ximoxiyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>07树&amp;二叉树</title>
    <link href="http://yoursite.com/2020/04/11/07%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/04/11/07%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-04-11T02:29:00.000Z</published>
    <updated>2020-04-11T10:46:02.947Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/b7d501591eb7" target="_blank" rel="noopener">参考</a><br><a href="https://www.jianshu.com/p/38853c044156" target="_blank" rel="noopener">目录</a></p><p>内部类 数据，引用(个数不定)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/b7d501591eb7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/38853c044156
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>06哈希表</title>
    <link href="http://yoursite.com/2020/04/11/07%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/04/11/07%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2020-04-11T02:07:00.000Z</published>
    <updated>2020-04-11T10:15:25.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1.【优点】哈希表基于数组，但插入-删除-查找操作效率高;<br>O(1)时间级，速度比树快，且编码简单<br>数组查找：基于索引查找效率高，基于内容效率低，而删除插入效率低<br>【缺点】数据无顺序，遍历顺序不固定；key不重复;  字典和集合都基于哈希表<br>2.定义<br><strong>结构为数组，但下标值会进行哈希函数，来获得HashCode</strong><br>3.案例：存1000个员工(通过哈希函数使某key(如名字)来获索引值)<br>保存联系人与电话、存储单词信息<br>【哈希表应用—高级语言的编译器】</p><h3 id="字母转数字"><a href="#字母转数字" class="headerlink" title="字母转数字"></a>字母转数字</h3><p>1.常见字符编码：<br>ASCII码(占一个字节，美)<br>ISO-8859-1码(扩充，一个字节，欧洲)<br>GBxxx(如GBK,GB18030 1、2、4字节，中)<br><strong>Unicode字符集，目前常用UTF-8</strong><br>2.【目标】字符串转为数字<br>可以用ASCII码，也可自己设置编码系统，26个字母+空格(0)—27; a-z对应1-26，不考虑大小写<br>实现方式：<br>1)数字相加(数字过小，下标不唯一！)<br>2)幂的连乘:27个字符 如果有4个字母，分别是27的3,2,1,0幂(数字过大！耗内存)<br>3)改进后：哈希化！  2倍，取余实现压缩<br>整除10，取余数0-9</p><h3 id="哈希化"><a href="#哈希化" class="headerlink" title="哈希化"></a>哈希化</h3><p>1.哈希化：大数字-压缩转换为数组范围下标<br>2.哈希函数：封装<strong>单词转大数字，哈希化</strong>的代码<br>3.哈希表：将最终数据插入到数组，增删改查，整个结构的封装<br>【缺点：下标存在重复–冲突】</p><h3 id="解决地址冲突"><a href="#解决地址冲突" class="headerlink" title="解决地址冲突"></a><a href="https://www.jianshu.com/p/6e88d63061f2" target="_blank" rel="noopener">解决地址冲突</a></h3><p>1.链地址法(拉链法)<br> 数组每个位置由单个元素改存储一个链表/数组(视情况，插前用链表)<br>2.开放地址法<br>寻找空单元格来存重复数据，探测方式有三种：查、删<br>1)线性探测：下标值+1  查的过程中遇到空白，停止查找，表示此数不存在，删位置后设为-1  (缺点–聚集：连续单元填充，影响性能)<br>2)二次探测：优化步长,+1,+4,+9 比线性好  (步长不一的聚集)<br>3)再哈希法：依赖关键字的探测序列<br>关键字-》哈希函数再进行哈希化-》结果为步长<br>特点：哈希函数不同，不能输出0<br>哈希函数已被设好</p><h3 id="哈希化的效率"><a href="#哈希化的效率" class="headerlink" title="哈希化的效率"></a>哈希化的效率</h3><p>1)没有冲突，效率更高<br>2)发生冲突：存放时间依赖后来的探测长度(取决于填装因子)<br>填装因子=总数据项/哈希表长度<br>链地址法：可大于1<br>开放地址表法最大填装因子：1  寻空项<br>三种探测方案的效率<br>线性：<br>对成功的查找: P = (1+1/(1-L))/2<br>对不成功的查找: P=(1+1/(1-L)^2)/2<br>二次与再哈希性能近似，比线性高<br>【结论】<br>真实开发时，多使用链地址法！</p><h2 id="链地址法实现哈希表"><a href="#链地址法实现哈希表" class="headerlink" title="链地址法实现哈希表"></a><a href="https://www.cnblogs.com/AhuntSun-blog/p/12636714.html" target="_blank" rel="noopener">链地址法实现哈希表</a></h2><p>1.设计哈希函数:快速计算 元素均匀分布<br>【快速计算】乘法效率低<br>多项式计算-》优化:霍纳法则(秦九韶算法) 复杂度 O(N^2)降为 O(N)  核心：降低乘法的次数<br>【均匀分布】在常量地方使用质数，如哈希表长度27，N次幂的底数(27) 表长为质数<br>Java中哈希表：链地址法 长度为2的幂  位运算     //哈希化公式：index=hasCode(key)&amp;(Length-1)<br>JS使用质数，取余</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>【哈希函数】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//字符串转换为较大的数字：hashCode,取余进行压缩</span></span><br><span class="line"><span class="comment">//设计哈希函数</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">hashFunc</span>(<span class="params">str,size</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> hashCode = <span class="number">0</span></span><br><span class="line">       <span class="comment">////使用霍纳法计算hashCode值，取余操作实现哈希化</span></span><br><span class="line">       <span class="comment">//霍纳核心：先计算最内层一次多项式值，由内向外计算，n次多项转为一次多项式</span></span><br><span class="line">       <span class="comment">//cats -&gt;Unicode编码</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;str.length; i++)&#123;</span><br><span class="line">           <span class="comment">//str.charCodeAt(i)获取某个字符对应的Unicode码</span></span><br><span class="line">           <span class="comment">//</span></span><br><span class="line">           <span class="comment">//为什么是37？规定为常用数</span></span><br><span class="line">           hashCode = <span class="number">37</span> * hashCode+ str.charCodeAt(i);<span class="comment">//charCodeAt()可返回指定位置的字符的 Unicode 编码,0-65535</span></span><br><span class="line">       &#125;</span><br><span class="line">           <span class="comment">//取余压缩</span></span><br><span class="line">           <span class="keyword">var</span>  index = hashCode % size;</span><br><span class="line">           <span class="keyword">return</span> index</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//测试代码</span></span><br><span class="line">   <span class="built_in">console</span>.log(hashFunc(<span class="string">'123'</span>,<span class="number">7</span>))<span class="comment">//4</span></span><br><span class="line">   <span class="built_in">console</span>.log(hashFunc(<span class="string">'NBA'</span>,<span class="number">7</span>))<span class="comment">//3</span></span><br><span class="line">   <span class="built_in">console</span>.log(hashFunc(<span class="string">'CBA'</span>,<span class="number">7</span>))<span class="comment">//5</span></span><br><span class="line">   <span class="built_in">console</span>.log(hashFunc(<span class="string">'CMF'</span>,<span class="number">7</span>))<span class="comment">//1</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>【创建哈希表】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ], [ [k,v] ] ]</span><br><span class="line">   &#x2F;&#x2F;每个bucket代表一个index，可 [key,value] [key,value]</span><br><span class="line">   &#x2F;&#x2F;storage有不同index的bucket构成</span><br></pre></td></tr></table></figure><p>【哈希表扩容】<br>1.扩容:链地址法,装填因子&gt;1,可无限插入新数据<br>2.扩容条件：装填因子&gt;0.75<br>3.实现：<br>1)定义变量，改变指向<br>2)创建一个新容量更大的数组，this.storage指向它<br>3)取oldStorage中bucket中的每个数据依次添加<br>【注】利用resize()即可实现扩容，又可实现容量压缩<br>装填因子 = 哈希表中数据 / 哈希表长度<br>1.装填因子laodFactor &gt; 0.75时，对哈希表进行扩容。在put()函数中添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容操作</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>.count &gt; <span class="keyword">this</span>.limit * <span class="number">0.75</span>)&#123;</span><br><span class="line">     <span class="comment">//调用扩容函数</span></span><br><span class="line">       <span class="keyword">this</span>.resize(<span class="keyword">this</span>.limit * <span class="number">2</span>)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>2.装填因子laodFactor &lt; 0.25时，对哈希表容量进行压缩 在remove中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;缩小容量</span><br><span class="line">   if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;</span><br><span class="line">    &#x2F;&#x2F;调用扩容函数 this.resize(Math.floor(this.limit &#x2F; 2))</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>【总代码】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">     &#x2F;&#x2F;设计哈希表：链地址法，每个index对应一个数组</span><br><span class="line">        function HashTable() &#123;</span><br><span class="line">            &#x2F;&#x2F;定义属性</span><br><span class="line">            this.storage &#x3D; [] &#x2F;&#x2F;数组</span><br><span class="line">            this.count &#x3D; 0 &#x2F;&#x2F;记录已存数据</span><br><span class="line">            &#x2F;&#x2F;装填因子:loadFactor&gt;0.75 扩容，&lt;0.25减少容量</span><br><span class="line">            this.limit &#x3D; 7 &#x2F;&#x2F;标记数组中可存放元素个数</span><br><span class="line">            &#x2F;&#x2F;定义相关的方法</span><br><span class="line">            &#x2F;&#x2F;哈希函数</span><br><span class="line">            HashTable.prototype.hashFunc&#x3D;(str, size)&#x3D;&gt;&#123;</span><br><span class="line">                var hashCode &#x3D; 0</span><br><span class="line">                for (var i &#x3D; 0; i &lt; str.length; i++) &#123;</span><br><span class="line">                    hashCode &#x3D; 37 * hashCode + str.charCodeAt(i)</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;取余操作</span><br><span class="line">                hashCode &#x3D; hashCode % size</span><br><span class="line">                return hashCode</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;一.put(key,value)插入修改元素，若不存在key则为插入，若有，则为修改值为value</span><br><span class="line">            HashTable.prototype.put &#x3D; (key, value) &#x3D;&gt; &#123;</span><br><span class="line">                &#x2F;&#x2F;1.获取key的index</span><br><span class="line">                var index &#x3D; this.hashFunc(key, this.limit)</span><br><span class="line">                &#x2F;&#x2F;2.取出数组</span><br><span class="line">                var bucket &#x3D; this.storage[index]</span><br><span class="line">                &#x2F;&#x2F;3.判断这个数组是否存在</span><br><span class="line">                &#x2F;&#x2F;若不存，先创建bucket</span><br><span class="line">                if (bucket &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    bucket &#x3D; []</span><br><span class="line">                    this.storage[index] &#x3D; bucket</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                     &#x2F;&#x2F;4.判断新增还是修改原值,声明变量flag来记录是否进行修改操作</span><br><span class="line">                var flag &#x3D; false;</span><br><span class="line">                for (var i &#x3D; 0; i &lt; bucket.length; i++) &#123;</span><br><span class="line">                    var tuple &#x3D; bucket[i]&#x2F;&#x2F;声明一个来保存bucket？因为bucket的每个值是[key,value]</span><br><span class="line">                    if (tuple[0] &#x3D;&#x3D; key) &#123;</span><br><span class="line">                        tuple[1] &#x3D; value</span><br><span class="line">                        flag &#x3D; true &#x2F;&#x2F;修改成功</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;新增</span><br><span class="line">                if(!flag)&#123;</span><br><span class="line">                    bucket.push([key,value])</span><br><span class="line">                    this.count++</span><br><span class="line">                    &#x2F;&#x2F; 数组扩容</span><br><span class="line">                 if (this.count &gt; this.limit * 0.75) </span><br><span class="line">                 this.resize(this.limit * 2)</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;get(key)获取特定位置元素</span><br><span class="line">            HashTable.prototype.get&#x3D;(key)&#x3D;&gt;&#123;</span><br><span class="line">                &#x2F;&#x2F;获取key对应的index</span><br><span class="line">                var index &#x3D;this.hashFunc(key,this.limit)</span><br><span class="line">                &#x2F;&#x2F;获取对应的bucket</span><br><span class="line">                var bucket &#x3D;this.storage[index]</span><br><span class="line">                &#x2F;&#x2F;3.若不存在，说明没有数据</span><br><span class="line">                if(bucket&#x3D;&#x3D;null)</span><br><span class="line">                  return null</span><br><span class="line">                else&#123;</span><br><span class="line">                    for(var i&#x3D;0;i&lt;bucket.length;i++)&#123;</span><br><span class="line">                        var tuple &#x3D;bucket[i]</span><br><span class="line">                        if(tuple[0]&#x3D;&#x3D;key)</span><br><span class="line">                        return tuple[1]</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;遍历完成后也没找到</span><br><span class="line">                    return null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;remove(key)删除特定位置元素</span><br><span class="line">            HashTable.prototype.remove&#x3D;(key)&#x3D;&gt;&#123;</span><br><span class="line">                &#x2F;&#x2F;获取key对应的index</span><br><span class="line">                var index &#x3D;this.hashFunc(key,this.limit)</span><br><span class="line">                &#x2F;&#x2F;获取对应的bucket</span><br><span class="line">                var bucket &#x3D;this.storage[index]</span><br><span class="line">                &#x2F;&#x2F;3.若不存在，说明没有数据</span><br><span class="line">                if(bucket&#x3D;&#x3D;null)</span><br><span class="line">                  return null</span><br><span class="line">                else&#123;</span><br><span class="line">                    for(var i&#x3D;0;i&lt;bucket.length;i++)&#123;</span><br><span class="line">                        var tuple &#x3D;bucket[i]</span><br><span class="line">                        if(tuple[0]&#x3D;&#x3D;key)&#123;</span><br><span class="line">                            &#x2F;&#x2F;删除操作</span><br><span class="line">                       bucket.splice(i,1)</span><br><span class="line">                       this.count --</span><br><span class="line">                       &#x2F;&#x2F; 缩小数组的容量</span><br><span class="line">            if (this.limit &gt; 8 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;</span><br><span class="line">                this.resize(Math.floor(this.limit &#x2F; 2))</span><br><span class="line">            &#125;</span><br><span class="line">            return tuple[1]</span><br><span class="line">                        &#125;</span><br><span class="line">                       </span><br><span class="line">                    &#125;</span><br><span class="line">                      &#x2F;&#x2F;依然没找到</span><br><span class="line">                      return null</span><br><span class="line">                &#125;</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;isEmpty()</span><br><span class="line">            HashTable.prototype.isEmpty &#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">                return this.count&#x3D;&#x3D;0</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;size()</span><br><span class="line">            HashTable.prototype.size &#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">                return this.count</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;resize(value)哈希表扩容</span><br><span class="line">            HashTable.prototype.resize &#x3D; (newLimit)&#x3D;&gt;&#123;</span><br><span class="line">                &#x2F;&#x2F;1.保存旧数据</span><br><span class="line">                let oldStorage &#x3D; this.storage</span><br><span class="line">                &#x2F;&#x2F;2.重置所有属性</span><br><span class="line">                this.storage&#x3D;[]</span><br><span class="line">                this.count&#x3D;0</span><br><span class="line">                this.limit&#x3D;newLimit</span><br><span class="line">                &#x2F;&#x2F;3.遍历oldStorage中所有的bucket</span><br><span class="line">                for(var i&#x3D;0;i&lt;oldStorage.length;i++)</span><br><span class="line">                const bucket &#x3D;oldStorage[i]</span><br><span class="line">                &#x2F;&#x2F;判断是否为空</span><br><span class="line">                if(bucket&#x3D;&#x3D;null)&#123;</span><br><span class="line">                    continue</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    &#x2F;&#x2F;当bucket中有数据时，取出数据重新插入</span><br><span class="line">                    for(var j&#x3D;0;j&lt;bucket.length;j++)&#123;</span><br><span class="line">                        const tuple &#x3D;bucket[j];</span><br><span class="line">                        this.put(tuple[0],tuple[1]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试哈希表</span><br><span class="line">var ht &#x3D; new HashTable()</span><br><span class="line">&#x2F;&#x2F;插入数据</span><br><span class="line">ht.put(&#39;name&#39;,&quot;xi&quot;)</span><br><span class="line">ht.put(&#39;height&#39;,165)</span><br><span class="line">ht.put(&#39;age&#39;,18)</span><br><span class="line">ht.put(&#39;sex&#39;,&#39;girl&#39;)</span><br><span class="line">console.log(ht)</span><br><span class="line">alert(ht.get(&#39;age&#39;))</span><br><span class="line">ht.put(&#39;color&#39;,&#39;blue&#39;)</span><br><span class="line">console.log(ht)</span><br><span class="line">alert(ht.remove(&#39;kk&#39;))</span><br><span class="line">alert(ht.isEmpty())</span><br><span class="line">alert(ht.size())</span><br></pre></td></tr></table></figure><h3 id="容量质数"><a href="#容量质数" class="headerlink" title="容量质数"></a>容量质数</h3><p>1.判断一个数是否为质数？仅能被1和自身整除<br>【容量改为质数的代码】<br><a href="https://www.jianshu.com/p/70c11dc8ec98" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;理论&quot;&gt;&lt;a href=&quot;#理论&quot; class=&quot;headerlink&quot; title=&quot;理论&quot;&gt;&lt;/a&gt;理论&lt;/h2&gt;&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>05集合与字典</title>
    <link href="http://yoursite.com/2020/04/10/05%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2020/04/10/05%E9%9B%86%E5%90%88/</id>
    <published>2020-04-10T13:39:00.000Z</published>
    <updated>2020-04-11T02:26:53.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>1.特点：无序，不能重复的元素构成–视为特殊的数组<br>2.常见实现方式：哈希表<br>3.ES6中的Set类<br>4.封装过程中的一些对象操作<br>1)对象添加元素this.items【value】=value //属性名与属性值均为value<br>2)Object.keys(obj)//返回对象可枚举属性组成的字符串数组</p><a id="more"></a><p>5.集合的封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//使用一个对象来保存集合的元素 属性items</span></span><br><span class="line">            <span class="keyword">this</span>.items=&#123;&#125;</span><br><span class="line">            <span class="comment">//方法</span></span><br><span class="line">            <span class="comment">//add(value)</span></span><br><span class="line">            <span class="built_in">Set</span>.prototype.add =<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//先判断是否存在,有则添加失败</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.has(value))</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//添加失败</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//元素添加到集合 this.属性名</span></span><br><span class="line">                    <span class="keyword">this</span>.items[value] =value</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">//添加成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//remove(value)</span></span><br><span class="line">             <span class="built_in">Set</span>.prototype.remove =<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//先判断是否存在</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.has(value))</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//添加失败</span></span><br><span class="line">                   <span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">delete</span> <span class="keyword">this</span>.items[value] <span class="comment">//delete语句</span></span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                   &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//has(value) 判断是否存在</span></span><br><span class="line">             <span class="built_in">Set</span>.prototype.has =<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//先判断是否存在,使用对象属性hasOwnProperty</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>.items.hasOwnProperty(value)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//clear() 清空</span></span><br><span class="line">             <span class="built_in">Set</span>.prototype.clear =<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.items =&#123;&#125;;<span class="comment">//初始化</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//size()</span></span><br><span class="line">            <span class="built_in">Set</span>.prototype.size=<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//先判断是否存在</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.items).length</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//values() 转换为数组</span></span><br><span class="line">             <span class="built_in">Set</span>.prototype.values =<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//先判断是否存在</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.items)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">### 集合间的操作</span></span><br><span class="line"><span class="string">集合间操作：并集，交集，差集，子集(没有查出错误，但是测试结果不对)</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">//集合的操作</span></span><br><span class="line">        <span class="comment">//并集+</span></span><br><span class="line">        <span class="built_in">Set</span>.prototype.unison = <span class="function">(<span class="params">otherSet</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//this:集合对象A    otherSet:集合对象B</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">//创建新集合 此时为空</span></span><br><span class="line">             <span class="keyword">var</span> unSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">             <span class="comment">//A中对象添加到新集合,即转换后的数组aa-&gt;集合</span></span><br><span class="line">             <span class="keyword">var</span> aa = <span class="keyword">this</span>.values() <span class="comment">//拿到A中的所有元素,此时aa为数组</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ;i&lt;aa.length;i++)&#123;</span><br><span class="line">               unSet.add(aa[i])<span class="comment">//将A中所有数据添加到新集合</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> bb = otherSet.values() <span class="comment">//拿到A中的所有元素,此时aa为数组</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ;i&lt; bb.length;i++)&#123;</span><br><span class="line">               unSet.add(bb[i])<span class="comment">//将A中所有数据添加到新集合</span></span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">return</span> unSet  <span class="comment">//返回新集合</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交集&amp;</span></span><br><span class="line">        <span class="built_in">Set</span>.prototype.intersection =<span class="function">(<span class="params">otherSet</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//this:集合对象A    otherSet:集合对象B</span></span><br><span class="line">             <span class="comment">//创建新集合 此时为空</span></span><br><span class="line">             <span class="keyword">var</span> unSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">             <span class="comment">//A中对象添加到新集合,即转换后的数组aa-&gt;集合</span></span><br><span class="line">             <span class="keyword">var</span> aa = <span class="keyword">this</span>.values() <span class="comment">//拿到A中的所有元素,此时aa为数组</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ;i&lt;aa.length;i++)&#123;</span><br><span class="line">               <span class="comment">//判断集合B是否有此元素</span></span><br><span class="line">               <span class="keyword">var</span> data =aa[i]</span><br><span class="line">               <span class="keyword">if</span>(otherSet.has(data))&#123;</span><br><span class="line">                unSet.add(data)<span class="comment">//将A中所有数据添加到新集合</span></span><br><span class="line">               &#125; </span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">return</span> unSet  <span class="comment">//返回新集合</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//差集-</span></span><br><span class="line">        <span class="built_in">Set</span>.prototype.subset =<span class="function">(<span class="params">otherSet</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//this:集合对象A    otherSet:集合对象B</span></span><br><span class="line">             <span class="comment">//创建新集合 此时为空</span></span><br><span class="line">             <span class="keyword">var</span> unSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">             <span class="comment">//A中对象添加到新集合,即转换后的数组aa-&gt;集合</span></span><br><span class="line">             <span class="keyword">var</span> aa = <span class="keyword">this</span>.values() <span class="comment">//拿到A中的所有元素,此时aa为数组</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;aa.length; i++)&#123;</span><br><span class="line">               <span class="comment">//判断集合B是否有此元素</span></span><br><span class="line">               <span class="keyword">var</span> data =aa[i]</span><br><span class="line">               <span class="keyword">if</span>(!otherSet.has(data))&#123; <span class="comment">//不存在</span></span><br><span class="line">                unSet.add(data)<span class="comment">//将A中所有数据添加到新集合</span></span><br><span class="line">               &#125; </span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">return</span> unSet  <span class="comment">//返回新集合</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//子集  包含</span></span><br><span class="line">        <span class="built_in">Set</span>.prototype.child =<span class="function">(<span class="params">otherSet</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//this:集合对象A    otherSet:集合对象B</span></span><br><span class="line">    <span class="comment">//核心：遍历A中所有的元素，若在B中不存在返回false,否则返回true</span></span><br><span class="line">    </span><br><span class="line">             <span class="keyword">var</span> aa = <span class="keyword">this</span>.values() <span class="comment">//拿到A中的所有元素,此时aa为数组</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;aa.length; i++)&#123;</span><br><span class="line">               <span class="comment">//判断集合B是否有此元素</span></span><br><span class="line">               <span class="keyword">var</span> data =aa[i]</span><br><span class="line">               <span class="keyword">if</span>(!otherSet.has(data))&#123; <span class="comment">//不存在</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">               &#125; </span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">//返回新集合</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>【测试】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 创建两个新集合，并添加元素</span></span><br><span class="line">  <span class="keyword">var</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  setA.add(<span class="string">'aaa'</span>)</span><br><span class="line">  setA.add(<span class="string">'bbb'</span>)</span><br><span class="line">  setA.add(<span class="string">'ccc'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(setA)</span><br><span class="line">  <span class="keyword">var</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  setB.add(<span class="string">'aaa'</span>)</span><br><span class="line">  setB.add(<span class="string">'ddd'</span>)</span><br><span class="line">  setB.add(<span class="string">'eee'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(setB)</span><br><span class="line"><span class="comment">//注意要转换成数组显示！！！</span></span><br><span class="line"><span class="keyword">var</span> a = setA.unison(setB)</span><br><span class="line">alert(a.values())</span><br><span class="line"><span class="keyword">var</span> b = setA.intersection(setB)</span><br><span class="line">alert(b.values())</span><br><span class="line"><span class="keyword">var</span> c = setA.subset(setB)</span><br><span class="line">alert(c.values())</span><br><span class="line">alert(setA.child(setB))</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>1.数组-集合-字典（编程语言默认提供）<br>js提供数组类型，在ES6中增加集合，字典<br>2.特点：一对一个对象<br>1)数组：【’ximo’,18,165】利用下标值取数据<br>2)字典{‘name’:’ximo’,’age’:18,’height’:165}通过key取value<br>【注】字典中key不重复且无序，而value可重复<br>3.字典，又称映射关系或Map<br>4.应用：哈希表，动态添加数据结构<br>【注】在JS中，对象就是字典，将字典理解成对象即可<br><a href="https://www.jianshu.com/p/c53460c9c8e4" target="_blank" rel="noopener">补充</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h2&gt;&lt;p&gt;1.特点：无序，不能重复的元素构成–视为特殊的数组&lt;br&gt;2.常见实现方式：哈希表&lt;br&gt;3.ES6中的Set类&lt;br&gt;4.封装过程中的一些对象操作&lt;br&gt;1)对象添加元素this.items【value】=value //属性名与属性值均为value&lt;br&gt;2)Object.keys(obj)//返回对象可枚举属性组成的字符串数组&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>04链表</title>
    <link href="http://yoursite.com/2020/04/10/04%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/04/10/04%E9%93%BE%E8%A1%A8/</id>
    <published>2020-04-10T06:57:00.000Z</published>
    <updated>2020-04-10T13:38:52.862Z</updated>
    
    <content type="html"><![CDATA[<p>1.链表&amp;数组：均可存多个元素<br>不同：数组内存连续且固定，开头及中间增删数据不易<br>    链表动态存储，不固定，复杂度低；但元素间相互联系，每次使用均要从头遍历<br>2.链表：所存元素节点+指针(指向下个元素的引用)–火车头 head+节点+null<br>head属性指向链表的第一个节点,节点上有数据<br>最后一个节点指向null<br>若链表中无节点，则head指向null<br><a href="https://www.cnblogs.com/AhuntSun-blog/p/12433173.html" target="_blank" rel="noopener">拓展</a> </p><a id="more"></a><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>  【特点】从头到尾遍历，单向  不能反向！<br>3.链表的封装：类比优先队列 节点类+属性(head和长度)+方法<br>常见操作：有参数(position,element)<br>【增】注意最后this.length++<br>1)<strong>append(element)</strong> 末尾添加元素<br>链表 空or不空？</p><ul><li>若链表中没有节点，则 head指向null   即this.head =null<br>添加Node1：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建节点 newNode</span></span><br><span class="line"><span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(element)</span><br><span class="line"><span class="comment">//将head指针指向newNode</span></span><br><span class="line"><span class="keyword">this</span>.head = newNode</span><br></pre></td></tr></table></figure></li><li>链表有节点,添加Node2/3/4…  找最后节点,并将指针指向newNode<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建节点 newNode</span></span><br><span class="line"><span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(element)</span><br><span class="line"><span class="comment">//因为head指向第一个节点，即cur为第一个节点</span></span><br><span class="line"><span class="keyword">var</span> cur = <span class="keyword">this</span>.head </span><br><span class="line"><span class="comment">//核心：判断当前节点的next是否为空,即cur.next==null？</span></span><br><span class="line">   <span class="keyword">while</span>(cur.next)&#123;</span><br><span class="line">         <span class="comment">//cur指向当前节点的下一个节点</span></span><br><span class="line">           cur = cur.next</span><br><span class="line">             &#125;</span><br><span class="line"><span class="comment">//找到最后节点，最后节点的next指向新节点，即=新结点</span></span><br><span class="line">cur.next = newNode</span><br></pre></td></tr></table></figure>2)<strong>insert(pos,ele)</strong> 指定位置添加<br>position的越界问题:(0&lt;pos || pos&gt;this.length)<br>关于position:两个节点间<br>对pos=0 或 pos&lt;this.length进行讨论<br>pos=0, //链表Node1前插入节点<br>pos&gt;0,while循环，使cur指向pos=x位置的后一个，pre指向pos=x的前一个节点<br>注：用变量指向节点，即此变量代替当前节点 cur.next =下个节点;<br>两节点间双向，节点2前一个的1节点，1.next=2; </li></ul><p>【前提:原head指向Node1  即this.head = Node1】</p><ul><li>position=0  newNode指向Node1,head指向newNode<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(position==<span class="number">0</span>)&#123;</span><br><span class="line">newNode.next = <span class="keyword">this</span>.head <span class="comment">//因为默认this.head =Node1</span></span><br><span class="line"><span class="keyword">this</span>.head = newNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>position&gt;0  有前后节点  前一个节点指向也要变 两个变量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pre = <span class="literal">null</span> <span class="comment">//第一个节点前一个null</span></span><br><span class="line"><span class="keyword">var</span> cur = <span class="keyword">this</span>.head <span class="comment">// 变量cur指向第一个节点，从此遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index=<span class="number">0</span>; index &lt; position ; index++)&#123;</span><br><span class="line">  pre = cur <span class="comment">//依次给指向</span></span><br><span class="line">  cur = cur.next <span class="comment">//没到position,继续往后遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到对应位置，更改next指向</span></span><br><span class="line">newNode.next = cur <span class="comment">//两者指向相同</span></span><br><span class="line">pre.next = newNode <span class="comment">//更改前一节点的指向</span></span><br></pre></td></tr></table></figure>【查位置&amp;索引】<br>1)<strong>get(pos)</strong> 获取对应位置元素<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.prototype.get = <span class="function">(<span class="params">pos</span>)=&gt;</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(pos&lt;<span class="number">0</span> || pos&gt;=<span class="keyword">this</span>.length )&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//获取对应节点的element</span></span><br><span class="line">         <span class="keyword">var</span> cur = <span class="keyword">this</span>.head <span class="comment">//position =0</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">var</span> index=<span class="number">0</span>; index&lt; pos; index++)&#123;</span><br><span class="line">           cur = cur.next</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> cur.element</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>2)<strong>indexOf(element)</strong> 索引<br>只要cur.next!=null，就一直循环<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回此元素索引indexOf(element)</span></span><br><span class="line">        LinkedList.prototype.indexOf =<span class="function">(<span class="params">ele</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">var</span> cur =<span class="keyword">this</span>.head</span><br><span class="line">          <span class="keyword">var</span> index=<span class="number">0</span></span><br><span class="line">          <span class="comment">//判断是否遍历到末尾</span></span><br><span class="line">          <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">              <span class="keyword">if</span>(cur.element==ele)&#123;</span><br><span class="line">               <span class="keyword">return</span> index</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123; <span class="comment">//不相等</span></span><br><span class="line">               cur=cur.next</span><br><span class="line">               index ++</span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;</span><br><span class="line">   <span class="comment">//遍历到末尾也没找到</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>【改】</li><li><em>update(pos,ele)*</em> 修改某位值元素  类似数组中splice<br>越界增加pos!=length<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//update(pos,newEle)//修改某位置数据，前提是有数据，不能到末尾</span></span><br><span class="line">         LinkedList.prototype.update =<span class="function">(<span class="params">pos,newEle</span>)=&gt;</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(pos&lt;<span class="number">0</span> || pos&gt;=<span class="keyword">this</span>.length)&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">var</span> cur = <span class="keyword">this</span>.head</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">var</span> index=<span class="number">0</span>; index&lt;pos; index++)&#123;</span><br><span class="line">                 cur= cur.next</span><br><span class="line">             &#125;</span><br><span class="line">             cur.element = newEle</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>【删】</li><li><em>removeAt(pos)*</em> 特定位置移除元素<br>核心：跳过当前指向<br>pos=0 //删除Node1<br>pos=2 //删除Node3<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特定位置移除removeAt(position)</span></span><br><span class="line">        LinkedList.prototype.removeAt=<span class="function">(<span class="params">pos</span>)=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(pos&lt;<span class="number">0</span> || pos&gt;=<span class="keyword">this</span>.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//定义到外面</span></span><br><span class="line">            <span class="keyword">var</span> cur =<span class="keyword">this</span>.head</span><br><span class="line">            <span class="comment">//删除pos=0处，更改head的指向</span></span><br><span class="line">            <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next <span class="comment">//指向第二个节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//pos不为0，前一个等于后一个指向，跳过当前</span></span><br><span class="line">                <span class="keyword">var</span> pre = <span class="literal">null</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> index=<span class="number">0</span>;index&lt;pos;index++)&#123;</span><br><span class="line">                pre = cur</span><br><span class="line">                cur =cur.next</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">//  前一个等于后一个指向，跳过当前</span></span><br><span class="line">              pre.next =cur.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数据长度减少</span></span><br><span class="line">            <span class="keyword">this</span>.length--</span><br><span class="line">            <span class="keyword">return</span> cur.element</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><em>remove(ele)*</em> 移除元素  等价于removeAt(indexOf(ele))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;移除remove(element)</span><br><span class="line">        LinkedList.prototype.remove &#x3D;(ele)&#x3D;&gt;&#123;</span><br><span class="line">            &#x2F;&#x2F;获取当前数据的位置&#x3D;index</span><br><span class="line">          var pos &#x3D; this.indexOf(ele)</span><br><span class="line">          &#x2F;&#x2F;由位置信息进行删除</span><br><span class="line">          return this.removeAt(pos)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>【其他】<br>isEmpty() size() toString()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//isEmpty()</span></span><br><span class="line">         LinkedList.prototype.isEmpty =<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>.length ==<span class="number">0</span></span><br><span class="line">         &#125;</span><br><span class="line">  <span class="comment">//size()</span></span><br><span class="line">         LinkedList.prototype.size =<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>.length </span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//toString()仅输出元素的值</span></span><br><span class="line">         LinkedList.prototype.toString = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">             <span class="keyword">var</span> cur = <span class="keyword">this</span>.head <span class="comment">//拿第一个节点</span></span><br><span class="line">             <span class="keyword">var</span> listString = <span class="string">''</span></span><br><span class="line">             <span class="comment">//循环获取一个个节点,取链表中的元素是否为空,拼成字符串</span></span><br><span class="line">             <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                 listString += cur.element+ <span class="string">' '</span></span><br><span class="line">                 <span class="comment">//拼接节点数据后，更新next!,依次往后遍历</span></span><br><span class="line">                 cur = cur.next</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//返回结果</span></span><br><span class="line">             <span class="keyword">return</span> listString</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a><a href="https://www.cnblogs.com/AhuntSun-blog/p/12441095.html" target="_blank" rel="noopener">双向链表</a></h2>1.从头到尾，从尾到头  一个节点两个引用！ 占内存  更常使用<br> <img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt=""></li></ul><p>1)双向链表不仅有head指针指向第一个节点，而且有tail指针指向最后一个节点；<br>2)每一个节点由三部分组成：item储存数据、prev指向前一个节点、next指向后一个节点；<br>3)双向链表的第一个节点的prev指向null；<br>4)双向链表的最后一个节点的next指向null；<br>2.新增方法：<br>三种获取字符串的方法<strong>forwardString（）//从后往前<br>backwardString（）与toString()同</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//十一.getHead方法：获取链表的第一个元素</span></span><br><span class="line"> DoubleLinklist.prototype.getHead = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.head.data</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//十二.getTail方法：获取链表的最后一个元素</span></span><br><span class="line"> DoubleLinklist.prototype.getTail = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.tail.data</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>3.【难点】插入链表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三.insert方法</span></span><br><span class="line">  DoubleLinklist.prototype.insert = <span class="function">(<span class="params">position, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//1.越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.根据data创建新的节点</span></span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.插入新节点</span></span><br><span class="line">    <span class="comment">//原链表为空</span></span><br><span class="line">      <span class="comment">//情况1：插入的newNode是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = newNode</span><br><span class="line">      <span class="keyword">this</span>.tail = newNode</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原链表不为空</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//情况2：position == 0  第一个节点！改第一个节点prev指向newNode,新节点pre指head,next</span></span><br><span class="line">      <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//原节点的rev指向newNode,即原Node1.pre =newNode，且Node1=this.head</span></span><br><span class="line">        <span class="keyword">this</span>.head.prev = newNode </span><br><span class="line">        <span class="comment">//新节点的next指向原Node1,即newNode.next=this.head</span></span><br><span class="line">        newNode.next = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//head指向新节点</span></span><br><span class="line">        <span class="keyword">this</span>.head = newNode</span><br><span class="line"></span><br><span class="line">      <span class="comment">//情况3：position == this.length  最后一个节点！</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(position == <span class="keyword">this</span>.length)&#123;</span><br><span class="line">          <span class="comment">//最后一个节点的next指向新节点  this.tail =newNode</span></span><br><span class="line">        <span class="keyword">this</span>.tail.next = newNode</span><br><span class="line">        <span class="comment">//新节点的prev指向最后一个节点  newNode.prev=this.tail</span></span><br><span class="line">        newNode.prev = <span class="keyword">this</span>.tail</span><br><span class="line">        <span class="comment">//this.tail指向新节点</span></span><br><span class="line">        <span class="keyword">this</span>.tail = newNode</span><br><span class="line">        <span class="comment">//情况4：0 &lt; position &lt; this.length  中间插  前一个节点的next改，后一个节点的prev改  先找原位置</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到正确的pos,修改pos位置前后节点变量的指向(改四个节点)</span></span><br><span class="line">        newNode.next = current    <span class="comment">//新节点的next指向当前</span></span><br><span class="line">        newNode.prev = current.prev  <span class="comment">//新节点的prev指向cur.prev</span></span><br><span class="line">        current.pre.next = newNode   <span class="comment">//前一个节点的next指向新</span></span><br><span class="line">        current.prev = newNode     <span class="comment">//当前节点的prev指向新</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.length+1</span></span><br><span class="line">    <span class="keyword">this</span>.length += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span><span class="comment">//返回true表示插入成功</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.链表&amp;amp;数组：均可存多个元素&lt;br&gt;不同：数组内存连续且固定，开头及中间增删数据不易&lt;br&gt;    链表动态存储，不固定，复杂度低；但元素间相互联系，每次使用均要从头遍历&lt;br&gt;2.链表：所存元素节点+指针(指向下个元素的引用)–火车头 head+节点+null&lt;br&gt;head属性指向链表的第一个节点,节点上有数据&lt;br&gt;最后一个节点指向null&lt;br&gt;若链表中无节点，则head指向null&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/AhuntSun-blog/p/12433173.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;拓展&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>03队列</title>
    <link href="http://yoursite.com/2020/04/09/03%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/04/09/03%E9%98%9F%E5%88%97/</id>
    <published>2020-04-09T07:05:00.000Z</published>
    <updated>2020-04-09T12:08:08.551Z</updated>
    
    <content type="html"><![CDATA[<p>1.队列：先进先出FIFO  首部删除，尾部增加–排队<br>在程序中的应用：打印队列，线程队列<br>2.方法<br>enqueue(element)增尾，dequeue()删首<br>front()返回队列中第一个元素，不改<br>isEmpty()，size()<br>同栈</p><a id="more"></a><p>3.优先级队列：元素本身的优先级有关系的队列.（机场登机）<br>【实现】1)封装元素和优先级放在一起(可以封装一个新的构造函数)<br>2)添加元素时, 将当前的优先级和队列中已经存在的元素优先级进行比较, 以获得自己正确的位置.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要是新构造了一个函数，用来保存元素及优先级，由原来的一个参数变为两个参数，方便封装enqueue()时使用</span></span><br><span class="line"><span class="comment">//在封装enqueue()利用上述构造新new一个对象newElement,有元素及优先级属性；主逻辑：在增加对象时先判断此队列是否为空，空则直接push,不空--遍历队列，比较新元素优先级与队列每个元素的优先级，若比其小，则利用splice进行添加；若均大，push添加到末尾</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.封装一个新函数，保存元素及优先级</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">QueueElement</span>(<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.element = element</span><br><span class="line">                <span class="keyword">this</span>.priority = priority</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.添加元素的方法被改，有参数</span></span><br><span class="line">            PriorityQueue.prototype.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//   1)根据传入元素，创建新对象</span></span><br><span class="line">                <span class="keyword">var</span> newElement = <span class="keyword">new</span> QueueElement(element, priority)</span><br><span class="line">                <span class="comment">//2)获取正确位置</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.items.push(newElement)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> flag = <span class="literal">false</span>;<span class="comment">//是否填加成功</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;  <span class="keyword">this</span>.items.length; i++) &#123;</span><br><span class="line">                        <span class="comment">//规定数越小，优先级越高</span></span><br><span class="line">                        <span class="keyword">if</span> ( newElement.priority &lt;  <span class="keyword">this</span>.items[i].priority) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.items.splice(i, <span class="number">0</span>, newElement);</span><br><span class="line">                            flag = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;<span class="comment">//添加成功后退出</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//若表优先级的数比其他都大，则加到最后</span></span><br><span class="line">                    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.items.push(newElement)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>【例子：击鼓传花–Queue】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//击鼓传花的函数 名字序列和淘汰数字</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">queGame</span>(<span class="params">nameList,num</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> q = <span class="keyword">new</span> Queue();</span><br><span class="line">           <span class="comment">//1.遍历放入队列</span></span><br><span class="line">           nameList.forEach(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">               <span class="comment">//放入队列</span></span><br><span class="line">               q.enqueue(value)</span><br><span class="line">           &#125;)</span><br><span class="line">           <span class="comment">//2.队列不为1时，判断!=num,加入最后，否则出列</span></span><br><span class="line">           <span class="keyword">while</span>(q.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="comment">//假设从0开始数</span></span><br><span class="line">               <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                   <span class="comment">//前出列，放入后面</span></span><br><span class="line">                   q.enqueue(q.dequeue())</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//移除数到num的人</span></span><br><span class="line">               q.dequeue()</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.获取最后一个人--赢家</span></span><br><span class="line">           <span class="keyword">var</span> winName =q.dequeue()</span><br><span class="line">           alert(<span class="string">'winer:'</span>+ winName)</span><br><span class="line">           <span class="comment">//4.获取此人位置   indexOf: 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1</span></span><br><span class="line">           <span class="keyword">return</span> nameList.indexOf(winName)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//测试</span></span><br><span class="line">       <span class="keyword">var</span> names =[<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>,<span class="string">'dd'</span>,<span class="string">'ee'</span>];</span><br><span class="line">       <span class="keyword">var</span> index = queGame(names,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.队列：先进先出FIFO  首部删除，尾部增加–排队&lt;br&gt;在程序中的应用：打印队列，线程队列&lt;br&gt;2.方法&lt;br&gt;enqueue(element)增尾，dequeue()删首&lt;br&gt;front()返回队列中第一个元素，不改&lt;br&gt;isEmpty()，size()&lt;br&gt;同栈&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>02栈</title>
    <link href="http://yoursite.com/2020/04/09/02%E6%A0%88/"/>
    <id>http://yoursite.com/2020/04/09/02%E6%A0%88/</id>
    <published>2020-04-09T04:43:00.000Z</published>
    <updated>2020-04-10T06:56:53.829Z</updated>
    
    <content type="html"><![CDATA[<p>1.线性结构：数组，栈，队列<br>其中数组：任意位置增删元素，不受限；而栈与列表为受限线性结构–一端操作<br>2.stack栈，后进先出LIFO(last in first out)<br>方法：与对象实例有联系<br>原型：给整个类定义方法而不是某一个实例<br>函数调用栈<br>递归：为什么没有停止条件的递归会造成栈溢出？比如函数A为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数A压入栈，最后造成栈溢出（Stack Overfloat</p><a id="more"></a><p>3.栈的操作：push(元素),pop(),peek()–只返回栈顶元素，栈不变 isEmpty(),size()–栈中元素个数，toString()–栈结构内容以字符串形式返回<br>4.用类模拟栈中操作【疑问：栈是有记忆性吗？【object object】】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       <span class="comment">//栈结构封装：1)数组 2)链表  使用数组封装，即栈内放数组结构</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="comment">//栈的属性：定义一个数组类型的变量</span></span><br><span class="line">           <span class="comment">// var items =[1,2,3] 错误！！！</span></span><br><span class="line">           <span class="keyword">this</span>.items = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">           <span class="comment">//栈相关的方法(操作)--数组操作模拟--建议使用原型封装:给整个类而不是某具体实例   prototype，节省内存</span></span><br><span class="line">           <span class="comment">//1.压栈push(元素)</span></span><br><span class="line">           <span class="comment">// Stack.prototype.push = function (element)&#123;</span></span><br><span class="line">           <span class="comment">//     this.items.push(element)</span></span><br><span class="line">           <span class="comment">// &#125;</span></span><br><span class="line">            Stack.prototype.push = <span class="function">(<span class="params">element</span>)=&gt;</span> <span class="keyword">this</span>.items.push(element)</span><br><span class="line">           <span class="comment">//2.出栈pop():箭头函数方式书写</span></span><br><span class="line">           <span class="comment">// this.pop =()=&gt;&#123;items.pop()&#125;//给某一个实例,不建议！！</span></span><br><span class="line">           Stack.prototype.pop = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.items.pop()</span><br><span class="line">           <span class="comment">//3.查看栈顶元素peek()</span></span><br><span class="line">           Stack.prototype.peek = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>]</span><br><span class="line">           <span class="comment">//4.判断栈是否为空isEmpty()</span></span><br><span class="line">           Stack.prototype.isEmpty = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.items.length == <span class="number">0</span></span><br><span class="line">           <span class="comment">//5.栈中元素个数size()</span></span><br><span class="line">           Stack.prototype.size = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.items.length</span><br><span class="line">           <span class="comment">// //6.内容转字符串 toString()</span></span><br><span class="line">           Stack.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">               <span class="keyword">var</span> resultString = <span class="string">''</span>;</span><br><span class="line">               <span class="keyword">this</span>.items.forEach(<span class="function"><span class="params">t</span> =&gt;</span> resultString += t +<span class="string">' '</span>);<span class="comment">//注意有间隔！改了好久</span></span><br><span class="line">               <span class="keyword">return</span> resultString</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//声明</span></span><br><span class="line">       <span class="keyword">var</span> s = <span class="keyword">new</span> Stack()</span><br><span class="line">       <span class="comment">//测试</span></span><br><span class="line">       s.push(<span class="number">20</span>)</span><br><span class="line">       s.push(<span class="number">50</span>)</span><br><span class="line">       s.push(<span class="number">80</span>)</span><br><span class="line">       s.push(<span class="number">100</span>)</span><br><span class="line">       alert(s) <span class="comment">//1 2 3 20 50 80 100</span></span><br><span class="line">       alert(s.pop())<span class="comment">//100</span></span><br><span class="line">       alert(s.peek())<span class="comment">//80</span></span><br><span class="line">       alert(s.isEmpty())<span class="comment">//false</span></span><br><span class="line">       alert(s.size())<span class="comment">//6</span></span><br><span class="line">       alert(s.toString())<span class="comment">//1 2 3 20 50 80 </span></span><br><span class="line"></span><br><span class="line">   &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>【例子：十进制转二进制】—运行时显示内存不够？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decToBin</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">           <span class="keyword">var</span> flag=<span class="number">0</span>;</span><br><span class="line">           <span class="comment">//循环作除，不知次数用while()</span></span><br><span class="line">           <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               aa = <span class="built_in">Math</span>.floor(num/<span class="number">2</span>);<span class="comment">//向下取整</span></span><br><span class="line">               flag = num % <span class="number">2</span>;</span><br><span class="line">               <span class="comment">//将余数压栈</span></span><br><span class="line">               stack.push(flag);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//出栈</span></span><br><span class="line">           <span class="keyword">var</span> cc =<span class="string">''</span>;</span><br><span class="line">           <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">               cc+=stack.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// alert(cc)</span></span><br><span class="line">           <span class="keyword">return</span> cc</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//测试代码，调用函数</span></span><br><span class="line">       <span class="built_in">console</span>.log(decToBin(<span class="number">8</span>))</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/eade026ffaf5" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.线性结构：数组，栈，队列&lt;br&gt;其中数组：任意位置增删元素，不受限；而栈与列表为受限线性结构–一端操作&lt;br&gt;2.stack栈，后进先出LIFO(last in first out)&lt;br&gt;方法：与对象实例有联系&lt;br&gt;原型：给整个类定义方法而不是某一个实例&lt;br&gt;函数调用栈&lt;br&gt;递归：为什么没有停止条件的递归会造成栈溢出？比如函数A为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数A压入栈，最后造成栈溢出（Stack Overfloat&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>01数组</title>
    <link href="http://yoursite.com/2020/04/09/01%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/04/09/01%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97/</id>
    <published>2020-04-09T02:49:00.000Z</published>
    <updated>2020-04-09T12:08:15.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><a href="https://www.jianshu.com/p/9521594710d7" target="_blank" rel="noopener">数组</a></h2><p>1.其他语言：存储同一类型数据；js可存储不同数据类型数据<br>2优势：节省变量个数，将其统一保存在一个数组内</p><a id="more"></a><p>3.创建数组并初始化 new Array()或直接【】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.数组的创建与初始化</span></span><br><span class="line">       <span class="keyword">var</span> aa = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">       <span class="keyword">var</span> bb = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">7</span>);</span><br><span class="line">       <span class="keyword">var</span> cc = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>,<span class="string">'dd'</span>,<span class="string">'ee'</span>);</span><br><span class="line">       <span class="keyword">var</span> dd = [<span class="string">'11'</span>,<span class="string">'22'</span>,<span class="string">'33'</span>,<span class="string">'44'</span>];</span><br><span class="line">       <span class="comment">//2.数组的遍历 for或者forEach</span></span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;dd.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(dd[i])</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//forEach更简单</span></span><br><span class="line">       cc.forEach(<span class="function"><span class="params">value</span>=&gt;</span>alert(value))</span><br></pre></td></tr></table></figure><p>【练习】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习：求斐波那契数列前20数字，并放入数组  1,1,2,3,5...</span></span><br><span class="line">    <span class="comment">//建议用for循环，forEach不太适用</span></span><br><span class="line">    <span class="keyword">var</span> num=[]</span><br><span class="line">    num[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    num[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">        num[i]=num[i<span class="number">-1</span>]+num[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br></pre></td></tr></table></figure><p>4.数组在中间插入元素比链表效率低<br>5.数组的增删方法：<br>首部：unshift,shift<br>末尾：push，pop<br>任意位置：splice<br>splice(3,5)//在索引3处删除5个元素，包含索引3<br>splice(3,0,’a’,’b’,’c’)//增<br>splice(3,5,’a’,’b’,’c’,’d’,’e’)//替换<br>【注】其中增，可以有参数，表增一个或多个；删没有参数<br>【下面均为单条语句执行】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">//1.增加元素，末尾push,首部unshift  1个或多个，有参数</span></span><br><span class="line">     num.push(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);<span class="comment">//[1,2,3,4,5,7,8,9]</span></span><br><span class="line">     num.unshift(<span class="number">-7</span>,<span class="number">0</span>);<span class="comment">//[-7，0，1,2,3,4,5]</span></span><br><span class="line">     <span class="comment">//2.删  末尾pop,首部shift  第一个，无参数</span></span><br><span class="line">     num.pop();<span class="comment">//[1,2,3,4]</span></span><br><span class="line">     num.shift();<span class="comment">//[2,3,4,5]</span></span><br><span class="line"> <span class="comment">//任意位置删除,增加更改 splice()</span></span><br><span class="line">  num.splice(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//[1,2,5]</span></span><br><span class="line">  num.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>);<span class="comment">//[1, 2, "aa", "bb", "cc", 3, 4, 5]</span></span><br><span class="line">    num.splice(<span class="number">2</span>,<span class="number">2</span>,<span class="string">'aa'</span>,<span class="string">'bb'</span>);<span class="comment">//[1, 2, "aa", "bb", 5]</span></span><br><span class="line">     <span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><p>【其他方法】<br>1)数组合并 nums1.concat(nums2) 等价于 nums1 + nums2<br>2)indexOf:    返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1<br>3)迭代方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代/遍历方法：every() some() forEach() filter()  map() </span></span><br><span class="line">       <span class="keyword">var</span> names =[<span class="string">'abc'</span>,<span class="string">'acd'</span>,<span class="string">'bcd'</span>,<span class="string">'ade'</span>];</span><br><span class="line">       <span class="comment">//1.every()每一个:利用every()判断数组元素中是否都包含a  &amp;</span></span><br><span class="line">       <span class="keyword">var</span> flag = names.every(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> value.indexOf(<span class="string">'a'</span>)!=<span class="number">-1</span></span><br><span class="line">       &#125;)<span class="comment">//flag=false</span></span><br><span class="line">       <span class="comment">//2.some():一旦有一次函数返回了true, 那么迭代就会结束. 并且结果为true  ||</span></span><br><span class="line">       <span class="keyword">var</span> flag1 =names.some(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> value.indexOf(<span class="string">'a'</span>)!= <span class="number">-1</span></span><br><span class="line">       &#125;) <span class="comment">//flag1=true</span></span><br><span class="line">       <span class="comment">//3.forEach()  快速迭代数组，无返回值</span></span><br><span class="line">       <span class="comment">//4.filter()  过滤，均满足，返回true并添加到新数组，false不添加  返回新数组</span></span><br><span class="line">       <span class="keyword">var</span> newNames = names.filter(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> value.indexOf(<span class="string">'a'</span>)!=<span class="number">-1</span></span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="comment">//5.map() 映射函数  变换生成新元素添加到新数组，返回新数组</span></span><br><span class="line">       <span class="keyword">var</span> mapNames =names.map(<span class="function"><span class="params">t</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> t+<span class="string">'111'</span></span><br><span class="line">       &#125;)</span><br><span class="line">       alert(mapNames)</span><br></pre></td></tr></table></figure><p>4）reduce()方法–函数式编程，有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【格式】arr.reduce(callback[, initialValue])</span><br><span class="line">【说明】callback指数组中每个元素均执行的回调函数，<span class="number">4</span>个可选参数为( previousValue--》上一次调用回调函数时的返回值，或者初始值</span><br><span class="line">currentValue--》当前正在处理的数组元素</span><br><span class="line">currentIndex--》当前正在处理的数组元素下标</span><br><span class="line">array--》调用reduce()方法的数组）</span><br><span class="line">而initialValue（可选的初始值。作为第一次调用回调函数时传给previousValue的值）</span><br><span class="line">】</span><br><span class="line">【举例，仅适用callback中的前两个参数】</span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">   <span class="keyword">var</span> total=numbers.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//   return pre+=cur;</span></span><br><span class="line">    <span class="comment">//上次执行结果保存在pre中,默认pre第一次执行时为0.</span></span><br><span class="line">    <span class="keyword">return</span> pre+cur;      </span><br><span class="line">   &#125;)</span><br><span class="line">   alert(total);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.jianshu.com/p/9521594710d7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;1.其他语言：存储同一类型数据；js可存储不同数据类型数据&lt;br&gt;2优势：节省变量个数，将其统一保存在一个数组内&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构</title>
    <link href="http://yoursite.com/2020/04/09/01%E6%95%B0%E7%BB%84%EF%BC%8C%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/04/09/01%E6%95%B0%E7%BB%84%EF%BC%8C%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97/</id>
    <published>2020-04-09T02:26:00.000Z</published>
    <updated>2020-04-11T02:33:20.427Z</updated>
    
    <content type="html"><![CDATA[<p>【写在前面】开启新的模块学习，梳理学过的算法与数据结构，掌握基本思想和逻辑，与编程语言无关<br>【目标】本周末前学完</p><a id="more"></a><p>【学习方法】语法-&gt;效果-&gt;逻辑<br>1.数据结构：<strong>存储和组织数据方式</strong>更高效(图书摆放，取快递)<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401" alt=""><br>【线性结构】数组，栈，队列，链表<br>哈希表，树结构，图结构，排序&amp;搜索</p><p>2.算法：<strong>解决问题的方法与操作(步骤)</strong>(找最佳路径)<br>3.目录<br><a href="">01数组</a><br><a href="">02栈</a><br><a href="">03队列&amp;优先队列</a><br><a href="">04链表</a><br><a href="">05集合&amp;字典</a><br><a href="">06哈希表</a><br><a href="">07树&amp;二叉树</a><br><a href="">08红黑树</a><br><a href="">09图论</a><br><a href="">10排序算法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【写在前面】开启新的模块学习，梳理学过的算法与数据结构，掌握基本思想和逻辑，与编程语言无关&lt;br&gt;【目标】本周末前学完&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>蘑菇街</title>
    <link href="http://yoursite.com/2020/04/08/%E8%98%91%E8%8F%87%E8%A1%97/"/>
    <id>http://yoursite.com/2020/04/08/%E8%98%91%E8%8F%87%E8%A1%97/</id>
    <published>2020-04-08T12:25:33.000Z</published>
    <updated>2020-04-09T12:08:57.866Z</updated>
    
    <content type="html"><![CDATA[<p>1.两种方式实现项目托管  本地-远程仓库<br>【方案一】git clone <a href="https://github.com/ximoxiyu/supermall.git" target="_blank" rel="noopener">https://github.com/ximoxiyu/supermall.git</a><br>复制，粘贴到当前文件夹<br>git add.<br>git commit -m ‘初始化项目’<br>git push<br>【方案二】<br>git remote add origin “地址”<br>git push -u origin master -f</p><h2 id="项目-蘑菇街"><a href="#项目-蘑菇街" class="headerlink" title="项目-蘑菇街"></a>项目-蘑菇街</h2><p> 1.划分目录结构<br> common：完全公共<br> content:当前项目相关</p><p> :root -&gt;获取根元素html<br> 定义变量<br> 2.引入两个css,标签统一<br> 3.vue.config.js 定义别名  .editorconfig.js 统一格式<br> 4.项目的模块划分：tabbar -&gt;路由映射关系<br> 5.加载src中时，不用空格</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.两种方式实现项目托管  本地-远程仓库&lt;br&gt;【方案一】git clone &lt;a href=&quot;https://github.com/ximoxiyu/supermall.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="http://yoursite.com/2020/04/07/vuex/"/>
    <id>http://yoursite.com/2020/04/07/vuex/</id>
    <published>2020-04-07T01:06:22.000Z</published>
    <updated>2020-04-07T08:17:17.230Z</updated>
    
    <content type="html"><![CDATA[<p>1.Vuex：状态管理模式(插件)，多个组件间共享状态的插件，且状态是响应式的<br>工具Devtools:在Chrome上调试时记录哪个变量修改<br>2.安装配置类比Vue-router</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//小写！</span><br><span class="line"> npm install vuex --save</span><br></pre></td></tr></table></figure><p>在src文件夹下新建store文件夹，建index.js，引入Vue与Vuex<br>注意大小写<br>【注】vuex-state是单一状态树，只推荐建一个对象store<br>3.对象的解构–ES6解构赋值，按名字赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line">   name:<span class="string">'why'</span>,</span><br><span class="line">   age:<span class="number">16</span>,</span><br><span class="line">   height:<span class="number">1.66</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name,age,height&#125;=obj;</span><br></pre></td></tr></table></figure><p>4.项目文件夹的目录组织：除state不抽，其他抽出,其他getters/mutations等均抽离成一个文件getters.js，并与index.js处于同一级目录下,抽离 <strong>export default{源代码}</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js中</span></span><br><span class="line"><span class="comment">//仅将state抽离，放在原文件下，</span></span><br><span class="line"><span class="comment">//使用时导入：import getters from './getters'</span></span><br><span class="line"><span class="keyword">const</span> state=&#123;</span><br><span class="line">    counter:<span class="number">1000</span>,</span><br><span class="line">    students:[</span><br><span class="line">       <span class="comment">//  注意对象的书写，是：而不是=</span></span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'aa'</span>,<span class="attr">age</span>:<span class="string">'10'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'bb'</span>,<span class="attr">age</span>:<span class="string">'15'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">'cc'</span>,<span class="attr">age</span>:<span class="string">'20'</span>&#125;,</span><br><span class="line">   ],</span><br><span class="line">   info:&#123;<span class="attr">id</span>:<span class="number">8</span>,<span class="attr">name</span>:<span class="string">'kk'</span>,<span class="attr">age</span>:<span class="string">'88'</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意对象的书写,注意大写！！！--单一数据源</span></span><br><span class="line"> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">     <span class="comment">//状态--单一数据源</span></span><br><span class="line">    state,</span><br><span class="line">    <span class="comment">//计算属性</span></span><br><span class="line">    getters,</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    mutations,</span><br><span class="line">     <span class="comment">//异步操作+Promise</span></span><br><span class="line">    actions,</span><br><span class="line">     <span class="comment">//划分模块--抽离模块</span></span><br><span class="line">    modules:&#123;</span><br><span class="line">      a:moduleA,</span><br><span class="line">&#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>5.五个核心概念：<br>1)state–类比data属性，存数据(状态)，供getters/mutations等使用;也可在APP.vue中直接使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2)getters–类比computed属性，即将数据进行一定处理再使用，本质为属性，可同state方法使用，但可以函数复用，可以有参数<br>但getters默认不可传参，传参数时：要求返回一个含参的函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$store.getters.moreAgeStu(18)&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在getters内部：里面也是函数，但用<span class="keyword">return</span></span><br><span class="line">  <span class="comment">//大于13岁的个数</span></span><br><span class="line">  <span class="comment">//1)函数的复用:复用之前的函数more13age,此时参数中多getters</span></span><br><span class="line">     more13ageLength(state,getters)&#123;</span><br><span class="line">         <span class="keyword">return</span> getters.more13age.length;</span><br><span class="line">     &#125;,</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//动态决定大于的岁数</span></span><br><span class="line"> <span class="comment">//2)计算属性中传参数，要求内部返回一个带参数的函数！</span></span><br><span class="line">     moreAgeStu(state)&#123;</span><br><span class="line">         <span class="comment">//返回函数</span></span><br><span class="line">         <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">             <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span>=&gt;</span>s.age&gt;age);</span><br><span class="line">             <span class="comment">//上句return 等价于</span></span><br><span class="line">             <span class="keyword">return</span> <span class="function"><span class="params">age</span>=&gt;</span>state.students.filter(<span class="function"><span class="params">s</span>=&gt;</span>s.age&gt;age);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>3)mutations–类比method属性：绑定事件;在App.vue中用commit来进行提交！同步，一般用devtool工具(浏览器插件)进行调试 响应式更新;<br>Vuex中store状态更新到唯一方式：提交mutation,含两部分：事件类型与回调函数(第一个参数为state)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;App.vue</span><br><span class="line"> &lt;button @click&#x3D;&quot;addNum(5)&quot;&gt;+5&lt;&#x2F;button&gt;</span><br><span class="line"> &#x2F;&#x2F;方法</span><br><span class="line">  addNum(num)&#123;</span><br><span class="line">      &#x2F;&#x2F;普通封装</span><br><span class="line">       this.$store.commit(&#39;inNum&#39;,num)</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;在mutations.js中</span><br><span class="line">   inNum(state,num)&#123;</span><br><span class="line">       state.counter +&#x3D; num</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>【拓展-提交风格：普通&amp;特殊-含type属性的对象，将整个commit的对象作payload使用】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊提交封装,可以</span></span><br><span class="line">     <span class="keyword">this</span>.$store.commit(&#123;</span><br><span class="line">         type: <span class="string">'inNum'</span>,</span><br><span class="line">         num</span><br><span class="line">           &#125;)</span><br><span class="line"> <span class="comment">//在mutations.js中 </span></span><br><span class="line"> <span class="comment">//特殊封装,特殊提交写成payload对象,小写！！</span></span><br><span class="line">   inNum(state,payload)&#123;</span><br><span class="line">       state.counter += payload.num</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>【响应规则：set与detele】<br>不用Vue时，改变的属性必须之前初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;响应式修改，之前没有的属性</span><br><span class="line">   upInfo(state)&#123;</span><br><span class="line">  &#x2F;&#x2F;第三个参数是字符串或数字</span><br><span class="line">  Vue.set(state.info,&#39;address&#39;,&#39;北京&#39;);</span><br><span class="line">  &#x2F;&#x2F;删除属性</span><br><span class="line">  Vue.delete(state.info,&#39;age&#39;)</span><br><span class="line">&#125;</span><br><span class="line">在App.vue中调用时同上</span><br></pre></td></tr></table></figure><p>4)Action -&gt;Mutation：异步操作(搭配Promise对象使用)<br>注：在定义函数时，第一个参数为context  –区别mutations的state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//context上下文，新定义异步操作的函数，payload为参数</span></span><br><span class="line">    aUpdataInfo(context,payload)&#123; </span><br><span class="line">    <span class="comment">//return Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//mutations中的函数</span></span><br><span class="line">           context.commit(<span class="string">'updateInfo'</span>);</span><br><span class="line">           <span class="built_in">console</span>.log(payload);</span><br><span class="line">           resolve(<span class="string">'resolve中的参数'</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">   &#125;) </span><br><span class="line">   </span><br><span class="line">   <span class="comment">//在App.vue中</span></span><br><span class="line">    <span class="comment">// Action的异步操作</span></span><br><span class="line">    actInfo()&#123;</span><br><span class="line">      <span class="comment">//异步，由commit改为dispatch</span></span><br><span class="line">       <span class="keyword">this</span>.$store.dispatch(<span class="string">'aUpdataInfo'</span>,<span class="string">'参数'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'里面完成了提交'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>【对比：同步mutations】参数为context,提交方式为dispatch，多返回Promise对象，有then</p><p>5)Module<br>  将store分割成模块(Module)，每个模块均有自身的state,mutations,getters,action<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;加入之前的状态：rootState</span><br><span class="line">    getName(state,getters,rootState)&#123;</span><br><span class="line">    return getters.fullname + rootState.counter;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><br>【小结】在其他组件.vue中，使用store对象中保存的状态</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1)this.$store.state.属性</span><br><span class="line">2)this.$store.getters.计算属性名</span><br><span class="line">2)this.$store.commit('mutations中的方法')//修改状态，绑定事件</span><br><span class="line">注：通过提交mutation来追踪状态变化，而非直接改变state</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.Vuex：状态管理模式(插件)，多个组件间共享状态的插件，且状态是响应式的&lt;br&gt;工具Devtools:在Chrome上调试时记录哪个变量修改&lt;br&gt;2.安装配置类比Vue-router&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从TabBar例子：抽离组件和复习vue-router</title>
    <link href="http://yoursite.com/2020/04/04/%E4%BB%8ETabBar%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%8A%BD%E7%A6%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%A4%8D%E4%B9%A0vue-router/"/>
    <id>http://yoursite.com/2020/04/04/%E4%BB%8ETabBar%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%8A%BD%E7%A6%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%A4%8D%E4%B9%A0vue-router/</id>
    <published>2020-04-04T15:00:46.000Z</published>
    <updated>2020-04-05T04:25:08.487Z</updated>
    
    <content type="html"><![CDATA[<p>【学习总结】<br>立了一堆flag，今天只完成了一个，自己太菜了，改了一天bug，为了省时间，一边看视频一边敲代码，减少自己bug的错误率;还好最终把结果做出来了，时间不够用，真心觉得时间不够用！以后的博客总结每日学习所得，不照本宣科，踏踏实实，多修改，多更正，不求一次做好，但要不断提炼自己的笔记。<br>今日早晨自己又独立写了一遍，果然上手才发现bug真不少。。<br>注意点：何时字符串，何时用变量;路径的大小写</p><a id="more"></a><p>【安装】<br>1)指定文件夹下：vue create “项目名”<br>2)安装vue-router: ** npm install vue-router –save **<br>3)配置路由：在src下新建router文件夹，创建index.js来配置路由信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.</span>导入Vue与VueRouter对象  <span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line">引入新建的子组件--懒加载(ES6的箭头函数)</span><br><span class="line"><span class="keyword">const</span> Home=<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'相对路径'</span>)</span><br><span class="line"><span class="number">1.</span>Vue.use(插件)安装插件</span><br><span class="line"><span class="number">2.</span>创建路由对象router，并且传入路由映射配置！</span><br><span class="line"><span class="keyword">const</span> router =<span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">   routes:[&#123;&#125;,&#123;&#125;];<span class="comment">//映射关系</span></span><br><span class="line">   mode:<span class="string">'history'</span><span class="comment">//拼接URL的格式</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="number">3.</span>输出router</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line">【补充】<span class="number">4.</span>在Vue实例main.js中挂载创建的路由对象router</span><br><span class="line">并在main.js中进行挂载：<span class="keyword">import</span>引入,实例中声明router</span><br></pre></td></tr></table></figure><p>4)【使用vue-router】创建路由组件，如Home.vue -&gt; 在index.js中懒加载，routes配置路由映射关系{path:,component} -&gt;在App.vue中使用<router-link>与<router-view><br>5)【组件抽离的思想】<br>1)整个页面：上–路由加载到的信息(子Vue),下–控制条;关系：点击控制条，路由到相应url,显示对应内容<br>2)上–<br>3)下–大组件：TabBar.vue内含四个小组件TabBarItem,每个小组件含两张图片(v-if v-else控制)和对应名字<br>【注】灵活更改使用slot组件，外包一层div，方便写控制，如v-if v-else和绑定属性等<br>【关键】子组件的click事件触发后更改router的地址，链接到不同的子组件如Home.vue等;且在App.vue中每个子组件标签处写上path地址<br>开发中：常用height:49px;<br>打包css样式安了插件<br><img src="/images/tabbar.png" alt="">】<br>【TabBar实现思路】<br>TabBar:定义插槽，flex布局平分<br>TabBarItem:定义两个插槽：图片，文字，外包div方便设置样式；<br>填充slot</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【学习总结】&lt;br&gt;立了一堆flag，今天只完成了一个，自己太菜了，改了一天bug，为了省时间，一边看视频一边敲代码，减少自己bug的错误率;还好最终把结果做出来了，时间不够用，真心觉得时间不够用！以后的博客总结每日学习所得，不照本宣科，踏踏实实，多修改，多更正，不求一次做好，但要不断提炼自己的笔记。&lt;br&gt;今日早晨自己又独立写了一遍，果然上手才发现bug真不少。。&lt;br&gt;注意点：何时字符串，何时用变量;路径的大小写&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vue-router</title>
    <link href="http://yoursite.com/2020/04/04/vue-router/"/>
    <id>http://yoursite.com/2020/04/04/vue-router/</id>
    <published>2020-04-04T01:18:39.000Z</published>
    <updated>2020-04-09T12:09:35.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习指南"><a href="#学习指南" class="headerlink" title="学习指南"></a>学习指南</h2><p>1.箭头函数()=&gt;{}:ES6定义函数的方式，常用于一个函数的往另一个函数中传参，箭头函数中的this向外层找;只有一行代码可省略return与{}<br>定义函数：本身function,对角字面量，ES6箭头函数<br>2.路由器：路由(路径)与传送(数据包转移)<br>内网192.168.1.110(可重复性，仅在当前网络中有效)<br>公网IP唯一性<br>发消息：公网IP-&gt;路由器(再次转发，映射表：内网IP与MAC地址的对应关系)<br>3.前端渲染与后端渲染<br>三个阶段<br>1）后端渲染(服务器渲染)-后端路由(jsp技术：java server page)，后端处理URL与页面的映射关系<br>2)前后端分离(前端渲染)-没有路由的概念(ajax请求数据)，后端(数据)，静态服务器(html+css+js),ajax发送网络请求，服务器回传数据，js操作浏览器渲染DOM<br>3)单页面富应用(SPA)(前端渲染)-前端路由(URL与页面的映射关系)+前后端分离，改变url，js判断，从资源中获取相应部分,页面不进行整体刷新，仅一个页面<br>4.【两种模式改URL】URL的hash(#)与HTML5中的history<br>【原】<a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8081</a><br>1)hash修改URL,页面未刷新，本质改location.href<br>控制台下：location.hash=’修改内容’—结果：<a href="http://localhost:8081/#修改内容" target="_blank" rel="noopener">http://localhost:8081/#修改内容</a><br>vue-router应用此机制，改变url地址，存在一份路由映射表，实现前端跳转而不刷新页面，ajax请求数据;<br>2)history对象模式，也不刷新页面，栈；后进先出，入栈：history.pushState()<br>出栈：history.back()<br>可以前进后退<br>同时：history.go(-1)=history.back()<br>history.go(1)=history.forward()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;&#125;,<span class="string">''</span>,<span class="string">'home'</span>)<span class="comment">//输出http://localhost:8081/home</span></span><br><span class="line"></span><br><span class="line">history.back()<span class="comment">//输出http://localhost:8081</span></span><br><span class="line"></span><br><span class="line">history.replaceState(&#123;&#125;,<span class="string">''</span>,<span class="string">'替换'</span>)<span class="comment">//http://localhost:8081/替换</span></span><br></pre></td></tr></table></figure><p>replaceState()只替换，无历史记录，无返回，后退受限</p><p>所有组件都继承自Vue类的原型</p><p>5.1)建立vue项目：在指定文件夹下 vue create 项目名 -&gt;cd 项目名 -&gt; npm run serve -&gt;修改URL的hash或HTML5中的history<br>2)配置vue-router插件模块，用Vue.user来安装路由功能;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure><ul><li>src下创router文件夹：存路由信息  ，建index.js</li><li>创建路由实例，在实例中挂载创建的路由实例对象</li></ul><p>3）快速生成vue模板：在vue文件下，输入vue回车<br>在components文件夹下创建路由组件Home.vue -》index.js配置路由映射(组件与路径映射)-》在APP.vue中使用路由</p><p>默认显示首页，再配置路由重定向<br>router-link默认渲染a标签，改为tag=”button” repalce状态repalceState<br>点击，字体颜色改变<br>【1.配置路由映射关系】配置组件，导入组件，配置映射关系，在APP内配置router-link<br>【2.动态路由】页面path不确定，在index.js的path改，在App.vue中绑定to属性，在data中定义路径；若要显示此路径，在User.vue中定义计算属性，获取 return this.$route.params.userId<br>【注】router是new的路由对象，内有routes(多个route),$route是此时活跃的路由<br>【3.路由懒加载–webpack的打包-步骤：npm run build,在dist-&gt;static-&gt;js中三类：app-业务你的代码，vendor-第三方(引用的vue/vue-router/axios/bs),manifest-底层支撑代码<br><strong>懒加载：用到时再加载</strong>，不同路由打包成不用js，几个组件几个懒加载,防止出现短暂空白–懒加载，将路由对应组件打包成一个个js块，路由访问时才加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入方式：三种，常用ES6的箭头函数</span></span><br><span class="line"><span class="comment">//index.js中书写懒加载</span></span><br><span class="line">&#123;</span><br><span class="line">        path:<span class="string">'/about'</span>,</span><br><span class="line">        component:<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'../components/About'</span>)<span class="comment">//箭头函数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用懒加载，js文件个数增加，从app.js中抽离出来<br>】</p><p><strong>路由使用时，用懒加载方式,一个路由一个js文件</strong><br>【路由嵌套】创建子组件，配置子路由，不用加/  ;父组件内部使用router-view<br>【路由参数】创建profile.vue–我的文件(档案);路由参数有两种：params对象与query–?<br>分析：URL<br>1)params类型：配置路由格式/router/:id<br>          传递方式：path后加对应值，形成路径：/router/123<br>2)query类型：/router ,传递格式：对象使用query的key为传递，形成路径：/router?id=123<br>【导航守卫】监听从哪往哪跳，改index.js中的title<br>常用生命周期的函数：created(),mounted(),updated()–界面刷新<br>方案一：在Home.vue中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'created Home'</span>);</span><br><span class="line">            <span class="built_in">document</span>.title=<span class="string">'首页'</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>【keep-alive保存组件状态】是Vue的内部组件<br>1.不写缺省值，在Home中在created()中写缺省</p><p>【琐碎知识】：vue-router是vue.js的路由插件<br>先渲染APP.vue</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习指南&quot;&gt;&lt;a href=&quot;#学习指南&quot; class=&quot;headerlink&quot; title=&quot;学习指南&quot;&gt;&lt;/a&gt;学习指南&lt;/h2&gt;&lt;p&gt;1.箭头函数()=&amp;gt;{}:ES6定义函数的方式，常用于一个函数的往另一个函数中传参，箭头函数中的this向外层找;只有
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>手撕promise</title>
    <link href="http://yoursite.com/2020/04/03/%E6%89%8B%E6%92%95promise/"/>
    <id>http://yoursite.com/2020/04/03/%E6%89%8B%E6%92%95promise/</id>
    <published>2020-04-03T09:28:00.000Z</published>
    <updated>2020-04-09T12:09:07.997Z</updated>
    
    <content type="html"><![CDATA[<p>【背景】解决ajax异步操作中的回调函数过多，将回调嵌套改为链式调用<br>1)观察者模式<br>then收集依赖–&gt;异步触发resolve–&gt;resolve执行依赖<br>在then方法的回调里取得异步操作的返回值<br>2)ES6中Promise/A规范控制Promise的状态<br>2.1)核心：Promise本质–状态机：Pending(等待),Fulfilled(执行中)，Rejected(拒绝态)<br>状态变更-单向:1-&gt;2,1-&gt;3<br>2.2)then方法：接收两个可选参数-状态改变时的回调;then方法可返回一个promise,可被同一个promise调用多次<br>3)【then的链式调用】<br>then()方法需返回一个Promise，这样才能返回then？then()的回调顺序执行<br>当前Promise状态变更后，再执行下一个then收集回调<br><strong>值穿透</strong>–then(参数必须为函数)<br><strong>处理状态为resolve/reject</strong>直接执行then回调</p><p>【查：instanceof 和try..catch】</p><p>【自学部分：promise】<br>1.背景：promise对异步操作进行封装<br>2.三种状态：<br>1).pending等待状态：正在执行网络请求或定时器未到时间<br>2).fulfill成功状态：主动回调resolve()时，并回调.then()<br>3).reject拒绝状态：主动回调reject()时，并回调.catch() 可省略<br>3.基本结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;setoutTime()&#125;).then().catch()</span><br></pre></td></tr></table></figure><p>4.链式调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    正确写法：不是一层套一层，是执行完之后继续链式执行</span></span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              resolve(<span class="string">'aaa'</span>);</span><br><span class="line">          &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//先初始调用，再拼接</span></span><br><span class="line">          <span class="built_in">console</span>.log(res, <span class="string">'第一层10行代码'</span>);</span><br><span class="line">          <span class="comment">//单纯在后面拼接，无需setTimeOut()再显示</span></span><br><span class="line">          <span class="comment">// return new Promise((resolve,reject) =&gt; &#123;</span></span><br><span class="line">          <span class="comment">//     // resolve(res + '111')</span></span><br><span class="line">          <span class="comment">//     reject(err);</span></span><br><span class="line">          <span class="comment">// &#125;)</span></span><br><span class="line">          <span class="comment">// 等价于 return Promise.reject(err);</span></span><br><span class="line">          <span class="comment">//再次简写：用throw抛出</span></span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//先初始调用，再拼接</span></span><br><span class="line">          <span class="built_in">console</span>.log(res, <span class="string">'第二层10行代码'</span>);</span><br><span class="line">         <span class="keyword">return</span> res+<span class="string">'222'</span>;</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(res, <span class="string">'第三层10行代码'</span>);</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'错误信息'</span>)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【背景】解决ajax异步操作中的回调函数过多，将回调嵌套改为链式调用&lt;br&gt;1)观察者模式&lt;br&gt;then收集依赖–&amp;gt;异步触发resolve–&amp;gt;resolve执行依赖&lt;br&gt;在then方法的回调里取得异步操作的返回值&lt;br&gt;2)ES6中Promise/A规范控制
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>常用HTML标签汇总</title>
    <link href="http://yoursite.com/2020/04/03/%E5%B8%B8%E7%94%A8HTML%E6%A0%87%E7%AD%BE%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2020/04/03/%E5%B8%B8%E7%94%A8HTML%E6%A0%87%E7%AD%BE%E6%B1%87%E6%80%BB/</id>
    <published>2020-04-03T08:57:00.000Z</published>
    <updated>2020-04-03T09:27:43.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="form标签中的input标签与label标签"><a href="#form标签中的input标签与label标签" class="headerlink" title="form标签中的input标签与label标签"></a>form标签中的input标签与label标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"male"</span>&gt;</span>Male<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">id</span>=<span class="string">"male"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1)form表单，可包含input元素，textarea元素，label元素，向服务器传数据，块元素<br>2)label标签为input元素定义标注，当用户选择此标签时，浏览器自动将焦点转到与此标签相关的表单控件;<br>3)label中的for=input中的id;即for将label绑定到另一个元素<br>4)input常用属性：type,value(input元素值),name(input元素名)<br>5)input标签，<a href="https://www.w3school.com.cn/tags/att_input_type.asp" target="_blank" rel="noopener">type规定input元素的类型</a><br>常见：button/checkbox/file/hidden/image/password/radio/<strong>reset(清除表单中所有数据)/submit(数据提交到服务器)/text(单行输入文本)</strong></p><h2 id="列表与列表项"><a href="#列表与列表项" class="headerlink" title="列表与列表项"></a>列表与列表项</h2><p> 1)列表ul/ol–li与定义列表dl-dt/dd描述<br> 2)列表项内部可以使用段落、换行符、图片、链接以及其他列表等等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;form标签中的input标签与label标签&quot;&gt;&lt;a href=&quot;#form标签中的input标签与label标签&quot; class=&quot;headerlink&quot; title=&quot;form标签中的input标签与label标签&quot;&gt;&lt;/a&gt;form标签中的input标签与l
      
    
    </summary>
    
    
    
      <category term="html " scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>http协议梳理</title>
    <link href="http://yoursite.com/2020/03/29/http%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/29/http%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/</id>
    <published>2020-03-29T07:31:21.000Z</published>
    <updated>2020-03-30T07:59:30.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《图解http协议》总结"><a href="#《图解http协议》总结" class="headerlink" title="《图解http协议》总结"></a>《图解http协议》总结</h2><p>1.HTTP：HyperText Transfer Protocol 超文本传输协议(规则)<br>HTTP协议前：FTP文本传输协议<br>2.WWW: World Wide Web 万维网，简称web<br>     3项WWW构建技术：SGML-标准通用标记语言<br>                HTTP协议<br>                URL-统一资源定位符<br>3.TCP/IP分层：应用层(FTP,DNS,HTTP协议)，传输层(TCP,UDP)，网络层(IP)，链路层(硬件)<br>4.TCP/IP 通信传输流(p19页图)<br>层与层传输数据时，加每层的首部信息<br>5.<strong>IP,TCP,DNS协议</strong><br>1)IP协议：传数据包，节点分配地址(可变);依赖MAC地址-网卡的固定地址;中转时IP通过ARP协议，解析地址反查对应的MAC地址<br>2)TCP协议：确定数据传到(可靠性)，BSS-字节流服务,数据以报文段(单位)分割;牢记三次握手：SYN–SYN/ACK–ACK<br><img src="/images/http%E5%8D%8F%E8%AE%AE/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"><br>3)DNS:域名解析，域名–IP地址，服务器接收IP地址，若是域名，则先经过DNS，将域名解析为IP地址<br>4)三者协议与HTTP协议关系(p24页图)<br>6.URI(标识符)&gt; URL(定位符),绝对URI,使用https:<br><img src="/images/http%E5%8D%8F%E8%AE%AE/%E7%BB%9D%E5%AF%B9URI.png" alt="绝对URI"></p><a id="more"></a><p>7.http协议:<br>1)不保存–Cookie技术,在报文中写入Cookie信息控制客户端(p46-47)<br>2)URI定位资源 –OPTIONS方法<br>3)持久连接-HTTP/0.9中需keep alive<br>4)管线化-并行发送，节省通信流量<br>8.请求方法<br>GET-请求资源，有返回<br>POST/PUT-传输资源，PUT指定位置<br>HEAD-获报文首部，类似GET，但只返首部信息<br>DELETE:删除指定位置资源<br>OPTIONS:询问支持方法<br>9.<a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener">Cookie变少，多用Token</a><br>10.HTTP报文：HTTP协议交互的信息，多行数据，字符串文本<br>请求报文：请求方法(GET,POST,PUT,HEAD),请求URI,协议版本(HTTP/1.1),可选–请求首部字段和内容实体(p32页)<br>响应报文：协议版本，状态码及解释短句(200 OK),可选-响应首部字段及实体内容(p33页)<br>11.报文结构：请求行/状态行,报文首部，报文主体<br>报文首部：请求/响应首部字段，通用首部字段，实体首部字段，其他(第6章重点)<br>首部字段：报文主体大小，语言，认证信息;结构–首部字段名：字段值(可多个)<br><img src="/images/http%E5%8D%8F%E8%AE%AE/%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.png" alt="通用首部字段"><br>请求首部字段<br><img src="/images/http%E5%8D%8F%E8%AE%AE/%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.png" alt="请求首部字段"><br><img src="/images/http%E5%8D%8F%E8%AE%AE/%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.png" alt="响应首部字段"><br><img src="/images/http%E5%8D%8F%E8%AE%AE/%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.png" alt="实体首部字段"></p><p>12.数据传输-编码提升传输效率，但耗CPU<br>1)不编码，报文内容=实体内容(变)<br>2)服务器内容编码：压缩–gzip/compress/deflate/identify<br>           分块–16进制，最后一块用’0’标记<br>3)可恢复机制–范围请求Range  206范围请求，返回指定范围<br>4)内容协商：服务器、客服端，透明(结合)协商<br>13.<strong>状态码(常考14种)：告知从服务器返回的请求结果(T/F)</strong><br>1xx–信息状态码<br>2xx–成功状态码，200正常返回   204成功，无资源返回<br>3xx–重定向,301永久 302暂时 303同302,但仅用GET 307同302，禁止POST变GET<br>4xx–客户端错误，401未授权 403禁止访问 404没找到资源<br>5xx–服务器错误，500执行错误 503超负荷<br>其中：304上次请求后页面未修改(特殊);加附加条件请求，服务器允许请求访问资源，但不满足条件；状态码返回时，无响应主体<br>14.服务器上的部署<br>1)相同IP，虚拟主机寄存多个不同主机名、域名<br>2)数据转发：代理，网关，隧道<br><strong>代理</strong>：转发不处理  代理服务器，写Via HTTP协议<br>分类基准：缓存？(缓存代理) 修改报文？(透明代理)<br><strong>网关</strong>：转发，处理请求  可使服务器提供非HTTP协议服务 安全性(加密)<br><strong>隧道</strong>：通信线路 安全通信<br>网关与隧道均为通信;<br>15.<a href="https://segmentfault.com/a/1190000022198770" target="_blank" rel="noopener">强缓存，协商缓存</a><br>强缓存-服务器，协商缓存-客户端<br>1.检查缓存是否过期（强缓存）<br>2.若缓存过期，与服务器协商是否更新缓存（协商缓存）</p><p>16.HTTP与HTTPS区别<br>1)HTTP缺点：不加密，内容被窃听;不验证身份，遭遇伪装;不证明报文完整性，遭篡改<br>2)通信加密，HTTP+SSL(安全套接层)=HTTPS,超文本传输安全协议<br>HTTP+加密+认证+完整性保护=HTTPS,是披SSL外壳的HTTP,不是新协议;<br>HTTPS采用混合加密机制：交换-公开密钥加密，交换报文-共享密钥加密<br>17.证明公开密钥正确性的证书（p150）<br>18.用户身份认证<br>1)核对信息：密码、动态令牌、数字证书、IC卡、生物认证<br>2)HTTP认证方式：BASIC、DIGEST、SSL客户端认证、FormBase认证(表单)–后端框架<br>Token认证<br>19.<a href="https://www.cnblogs.com/smallJunJun/p/11187796.html" target="_blank" rel="noopener">防范Web攻击</a><br>20.<a href="https://www.cnblogs.com/wupeixuan/p/8642100.html" target="_blank" rel="noopener">HTTP0.9-2.0版本区别</a><br>【后记】本篇基于《图解HTTP》与<a href="https://www.bilibili.com/video/bv1K7411Z7zu" target="_blank" rel="noopener">b站视频</a><br>学习过程：3小时刷书+2.5小时视频+2个小时总结为博客</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;《图解http协议》总结&quot;&gt;&lt;a href=&quot;#《图解http协议》总结&quot; class=&quot;headerlink&quot; title=&quot;《图解http协议》总结&quot;&gt;&lt;/a&gt;《图解http协议》总结&lt;/h2&gt;&lt;p&gt;1.HTTP：HyperText Transfer Protocol 超文本传输协议(规则)&lt;br&gt;HTTP协议前：FTP文本传输协议&lt;br&gt;2.WWW: World Wide Web 万维网，简称web&lt;br&gt;     3项WWW构建技术：SGML-标准通用标记语言&lt;br&gt;                HTTP协议&lt;br&gt;                URL-统一资源定位符&lt;br&gt;3.TCP/IP分层：应用层(FTP,DNS,HTTP协议)，传输层(TCP,UDP)，网络层(IP)，链路层(硬件)&lt;br&gt;4.TCP/IP 通信传输流(p19页图)&lt;br&gt;层与层传输数据时，加每层的首部信息&lt;br&gt;5.&lt;strong&gt;IP,TCP,DNS协议&lt;/strong&gt;&lt;br&gt;1)IP协议：传数据包，节点分配地址(可变);依赖MAC地址-网卡的固定地址;中转时IP通过ARP协议，解析地址反查对应的MAC地址&lt;br&gt;2)TCP协议：确定数据传到(可靠性)，BSS-字节流服务,数据以报文段(单位)分割;牢记三次握手：SYN–SYN/ACK–ACK&lt;br&gt;&lt;img src=&quot;/images/http%E5%8D%8F%E8%AE%AE/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&quot; alt=&quot;三次握手&quot;&gt;&lt;br&gt;3)DNS:域名解析，域名–IP地址，服务器接收IP地址，若是域名，则先经过DNS，将域名解析为IP地址&lt;br&gt;4)三者协议与HTTP协议关系(p24页图)&lt;br&gt;6.URI(标识符)&amp;gt; URL(定位符),绝对URI,使用https:&lt;br&gt;&lt;img src=&quot;/images/http%E5%8D%8F%E8%AE%AE/%E7%BB%9D%E5%AF%B9URI.png&quot; alt=&quot;绝对URI&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>js30系列04</title>
    <link href="http://yoursite.com/2020/03/28/js30%E7%B3%BB%E5%88%9704/"/>
    <id>http://yoursite.com/2020/03/28/js30%E7%B3%BB%E5%88%9704/</id>
    <published>2020-03-28T10:16:59.000Z</published>
    <updated>2020-04-02T09:27:55.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="15网页菜单"><a href="#15网页菜单" class="headerlink" title="15网页菜单"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/15%20-%20LocalStorage" target="_blank" rel="noopener">15网页菜单</a></h2><p>【目标】页面中添加新的菜品，而且在页面刷新之后也不清空<br>理解 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/LocalStorage" target="_blank" rel="noopener">localStorage</a> 的机制，利用 LocalStorage 把信息存到本地，从而可以保证刷新后内容不变。但使用 localStorage 的时候，直接把 items 传入得到的值是 [object Object]<br><a href="https://www.cnblogs.com/st-leslie/p/5617130.html" target="_blank" rel="noopener">localStorage学习</a><br>【关键点】1.localStorage理解为前端数据库：增删查改，setItem()/removeItem()/getItem()；字符串形式<br>2.主要配合JSON对象使用：JSON.stringify()//转字符串<br>JSON.parse()//字符串转JSON形式<br>3.HTML5的新特性，解决cookie内存不足(4k)，localStorage (5M)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 获取表单--添加部分</span><br><span class="line">  const addItems = document.querySelector(<span class="string">'.add-items'</span>);</span><br><span class="line">  // 获取列表--显示部分</span><br><span class="line">  const itemsList = document.querySelector(<span class="string">'.plates'</span>);</span><br><span class="line">  //定义空数组 const items = [];</span><br><span class="line">  //字符串转JSON格式</span><br><span class="line">  var items = JSON.parse(localStorage.getItem(<span class="string">'items'</span>)) || [];</span><br><span class="line">//事件的触发  提交-添加  点击-选中列表  最后：页面更新</span><br><span class="line">addItems.addEventListener(<span class="string">'submit'</span>,addItem);</span><br><span class="line">itemsList.addEventListener(<span class="string">'click'</span>,checkDone);</span><br><span class="line">changePage(items,itemsList);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//调用的具体函数</span><br><span class="line">//更新页面函数 changePage  显示ul</span><br><span class="line"><span class="keyword">function</span> changePage(plates=[],plateslist)&#123;</span><br><span class="line">  // 数组里的内容构造一组 &lt;li&gt; 组成的列表，并且加上一些标识信息，以助于之后需要实现的选中功能</span><br><span class="line">  plateslist.innerHTML = plates.map((plate,i)=&gt;&#123;</span><br><span class="line">    <span class="built_in">return</span> `</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span> =<span class="string">"checkbox"</span></span><br><span class="line">           data-index=<span class="variable">$&#123;i&#125;</span> id=<span class="string">"item<span class="variable">$&#123;i&#125;</span>"</span> </span><br><span class="line">           <span class="variable">$&#123;plate.checked1 ? 'checked' : ''&#125;</span> &gt;</span><br><span class="line">      &lt;label <span class="keyword">for</span>=<span class="string">"item<span class="variable">$&#123;i&#125;</span>"</span>&gt;<span class="variable">$&#123;plate.text&#125;</span>&lt;/label&gt;</span><br><span class="line">   &lt;/li&gt;</span><br><span class="line">    `;</span><br><span class="line">  &#125;).join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 添加函数addItem：获取当前input中的输入内容，将其存储在一个对象中，对象存入新数组</span><br><span class="line"><span class="keyword">function</span> addItem(e)&#123;</span><br><span class="line">  e.preventDefault();//阻止默认行为，闪动</span><br><span class="line">  // 获取输入框中的内容</span><br><span class="line">  const text =this.querySelector(<span class="string">'[name=item]'</span>).value;</span><br><span class="line">  //新建对象，存储输入框中的内容</span><br><span class="line">  const item =&#123;</span><br><span class="line">    text,//存储当前输入框中的内容</span><br><span class="line">    checked1:<span class="literal">false</span>,//是否勾选</span><br><span class="line">  &#125;</span><br><span class="line">  // 空数组中增加新元素</span><br><span class="line">  items.push(item);</span><br><span class="line">  // 表单元素重置为默认值--清空当前输入框</span><br><span class="line">  this.reset();</span><br><span class="line">  //页面刷新</span><br><span class="line">  changePage(items,itemsList);</span><br><span class="line">  //localStorage增加,等价于 localStorage.items = JSON.stringify(items)</span><br><span class="line">  localStorage.setItem(<span class="string">'items'</span>,JSON.stringify(items));</span><br><span class="line">  // 控制台打印当前输入内容，可删，同时第一句也可删</span><br><span class="line">console.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//选中函数 checkDone</span><br><span class="line"><span class="keyword">function</span> checkDone(e)&#123;</span><br><span class="line">  // 正则判断,要求为input</span><br><span class="line"><span class="keyword">if</span> (!e.target.matches(<span class="string">'input'</span>))</span><br><span class="line"><span class="built_in">return</span>;</span><br><span class="line">const el =e.target;</span><br><span class="line">const index =el.dataset.index;//读取data-index</span><br><span class="line">items[index].checked1 =!items[index].checked1;//取反</span><br><span class="line">changePage(items,itemsList);</span><br><span class="line">localStorage.setItem(<span class="string">'items'</span>,JSON.stringify(items));</span><br><span class="line">  // 控制台打印当前输入内容，可删，同时第一句也可删</span><br><span class="line">console.log(el.dataset.index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//附加功能，比如全选，全不选，删除</span><br><span class="line">const checkAllBtn = document.querySelector(<span class="string">'.check-all'</span>);</span><br><span class="line">const uncheckAllBtn = document.querySelector(<span class="string">'.uncheck-all'</span>);</span><br><span class="line">const deleteAllBtn = document.querySelector(<span class="string">'.delete-all'</span>);</span><br><span class="line"></span><br><span class="line">checkAllBtn.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  items.forEach(item=&gt;&#123;</span><br><span class="line">    item.checked1 = <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  changePage(items,itemsList);</span><br><span class="line">  localStorage.setItem(<span class="string">'items'</span>,JSON.stringify(items)); </span><br><span class="line">&#125;);</span><br><span class="line">uncheckAllBtn.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  items.forEach(item=&gt;&#123;</span><br><span class="line">    item.checked1 = <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  changePage(items,itemsList);</span><br><span class="line">  localStorage.setItem(<span class="string">'items'</span>,JSON.stringify(items)); </span><br><span class="line">&#125;);</span><br><span class="line">deleteAllBtn.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  items =[];</span><br><span class="line">  changePage(items,itemsList);</span><br><span class="line">  localStorage.setItem(<span class="string">'items'</span>,JSON.stringify(items)); </span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="17-数组标题去前缀"><a href="#17-数组标题去前缀" class="headerlink" title="[17.数组标题去前缀]"></a>[17.数组标题去前缀]</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">const bands = [<span class="string">'The Plot in You'</span>, <span class="string">'The Devil Wears Prada'</span>, <span class="string">'Pierce the Veil'</span>, <span class="string">'Norma Jean'</span>, <span class="string">'The Bled'</span>, <span class="string">'Say Anything'</span>, <span class="string">'The Midway State'</span>, <span class="string">'We Came as Romans'</span>,<span class="string">'Counterparts'</span>, <span class="string">'Oh, Sleeper'</span>, <span class="string">'A Skylit Drive'</span>, <span class="string">'Anywhere But Here'</span>, <span class="string">'An Old Dog'</span>];</span><br><span class="line">// 去除字符串中的The，A以及An的前缀后再进行排序,String.replace()函数,第一参数使用字面量正则表达式</span><br><span class="line">const delPrefix = item =&gt;item.replace(/^(The|A|An)\s&#123;1&#125;/,<span class="string">''</span>);</span><br><span class="line">  // Array.prototype.sort(*param*)方法虽然有返回值，但排序结果也影响原数组，Array.prototype.sort()函数只是返回了一个指向原数组的引用，而并没有生成新的数组。</span><br><span class="line">// 数组排序,排序后结果赋给新变量，</span><br><span class="line">const sortedbands = bands.sort((a,b)=&gt; delPrefix(a) &gt; delPrefix(b) ? 1 : -1);</span><br><span class="line">//获取ul列表,进行内容添加,展示到HTML页面</span><br><span class="line">document.querySelector(<span class="string">'#bands'</span>).innerHTML =<span class="string">'&lt;li&gt;'</span>+sortedbands.join(<span class="string">'&lt;/li&gt;&lt;li&gt;'</span>)+<span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">//测试Array.prototype.sort()的返回值，排序后的数组作为列表项插入其中。</span><br><span class="line">bands[0]=<span class="string">'I love javascript30!'</span>;</span><br><span class="line">console.log(sortedbands);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="19-照相"><a href="#19-照相" class="headerlink" title="19.照相"></a><a href="https://github.com/soyaine/JavaScript30/tree/master/19%20-%20Webcam%20Fun" target="_blank" rel="noopener">19.照相</a></h2><p>1.通过编写javascript代码，请求调用用户的网络摄像头;<br>2.在页面上展示来自webcam的数据流信息;<br>3.并允许用户保存展示的照片;<br>4.及使用滑块来改变图像的色彩。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">  canvas = document.querySelector(<span class="string">'canvas'</span>);</span><br><span class="line">    video = document.querySelector(<span class="string">'video'</span>);</span><br><span class="line">    ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    img = document.querySelector(<span class="string">'#myimg'</span>);</span><br><span class="line">    slider = document.querySelector(<span class="string">'.rgb'</span>);</span><br><span class="line">    a = document.querySelector(<span class="string">'a'</span>);</span><br><span class="line">    //滤色范围记录</span><br><span class="line">    filter = &#123;</span><br><span class="line">        rmin: 0,</span><br><span class="line">        rmax: 255,</span><br><span class="line">        gmin: 0,</span><br><span class="line">        gmax: 255,</span><br><span class="line">        bmin: 0,</span><br><span class="line">        bmax: 255</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //调用摄像头数据</span><br><span class="line">            askWebcam();</span><br><span class="line"></span><br><span class="line">    //绑定change事件动态修改图片颜色</span><br><span class="line">    slider.onchange = <span class="keyword">function</span>(e) &#123;</span><br><span class="line">        //先将canvas恢复至原始截图</span><br><span class="line">        ctx.putImageData(origindata, 0, 0);</span><br><span class="line">        const target = e.target;</span><br><span class="line">        //startPos表示操作像素点数据时的起点，从canvas获取到的像素数据每四个值表示一个像素点</span><br><span class="line">        //例如滑块为红色，则只需要改变像素数组中第0,4,8......个元素的值。</span><br><span class="line">        const startPos = &#123;</span><br><span class="line">            <span class="string">'r'</span>: 0,</span><br><span class="line">            <span class="string">'g'</span>: 1,</span><br><span class="line">            <span class="string">'b'</span>: 2</span><br><span class="line">        &#125;[target.name[0]];</span><br><span class="line">        //filterMin和filterMax表示相应的滤色范围上下限，若修改了红色滤色范围则取红色范围值。</span><br><span class="line">        //若修改蓝色的滤色范围，则取蓝色。</span><br><span class="line">        var tempFilter = checkFilter(target.name, target.value);</span><br><span class="line">        const filterMin = tempFilter.min;</span><br><span class="line">        const filterMax = tempFilter.max;</span><br><span class="line">        //从canvas获取像素数据</span><br><span class="line">        var img = ctx.getImageData(0, 0, 300, 200);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        var imgd = img.data;</span><br><span class="line">        //色彩过滤</span><br><span class="line">        <span class="keyword">for</span> (var i = startPos, len = imgd.length; i &lt; len; i += 4) &#123;</span><br><span class="line">            <span class="keyword">if</span> (imgd[i] &lt; filterMin) &#123;</span><br><span class="line">                imgd[i] = filterMin;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imgd[i] &gt; filterMax) &#123;</span><br><span class="line">                imgd[i] = filterMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将修改后的像素数据重绘制至canvas</span><br><span class="line">        ctx.putImageData(img, 0, 0);</span><br><span class="line">        img.src = canvas.toDataURL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//点击函数</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">takePhoto</span></span>() &#123;</span><br><span class="line">    ctx.drawImage(video, 0, 0, 300, 200);</span><br><span class="line">    //将原始截图保存</span><br><span class="line">    origindata = ctx.getImageData(0, 0, 300, 200);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//保存图片</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">savePhoto</span></span>() &#123;</span><br><span class="line">    img.src = canvas.toDataURL();</span><br><span class="line">    a.href = canvas.toDataURL();</span><br><span class="line">    a.setAttribute(<span class="string">'download'</span>, <span class="string">'handsome'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//申请网络摄像头操作权限</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">askWebcam</span></span>() &#123;</span><br><span class="line">    navigator.getUserMedia = navigator.getUserMedia ||</span><br><span class="line">        navigator.webkitGetUserMedia ||</span><br><span class="line">        navigator.mozGetUserMedia;</span><br><span class="line">    <span class="keyword">if</span> (navigator.getUserMedia) &#123;</span><br><span class="line">        navigator.getUserMedia(&#123;</span><br><span class="line">            audio: <span class="literal">false</span>,</span><br><span class="line">            video: &#123;</span><br><span class="line">                width: 300,</span><br><span class="line">                height: 200</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">function</span>(stream) &#123;</span><br><span class="line">            //若成功</span><br><span class="line">            video.srcObject = stream;</span><br><span class="line">            video.onloadedmetadata = <span class="keyword">function</span>(e) &#123;</span><br><span class="line">                video.play();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">function</span>(err) &#123;</span><br><span class="line">            console.log(<span class="string">'Error occured:'</span> + err.name);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        console.log(<span class="string">'this navigator doesn\'</span>t support webcam!<span class="string">');</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//滤色函数</span></span><br><span class="line"><span class="string">function checkFilter(name, value) &#123;</span></span><br><span class="line"><span class="string">    var _min;</span></span><br><span class="line"><span class="string">    var _max;</span></span><br><span class="line"><span class="string">    var _antiname = &#123;</span></span><br><span class="line"><span class="string">        '</span>rmin<span class="string">': '</span>rmax<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>rmax<span class="string">': '</span>rmin<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>gmin<span class="string">': '</span>gmax<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>gmax<span class="string">': '</span>gmin<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>bmin<span class="string">': '</span>bmax<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>bmax<span class="string">': '</span>bmin<span class="string">'</span></span><br><span class="line"><span class="string">    &#125;[name]</span></span><br><span class="line"><span class="string">    filter[name] = value;</span></span><br><span class="line"><span class="string">    //当下限值超过上限时，将两者对调</span></span><br><span class="line"><span class="string">    _min = Math.min(filter[name], filter[_antiname]);</span></span><br><span class="line"><span class="string">    _max = Math.max(filter[name], filter[_antiname]);</span></span><br><span class="line"><span class="string">    console.log(filter);</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">        min: _min,</span></span><br><span class="line"><span class="string">        max: _max</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>20.语音接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;</span><br><span class="line">  var words = document.getElementById(<span class="string">'words'</span>);</span><br><span class="line"></span><br><span class="line">  //新建一个语音识别对象</span><br><span class="line">  var speech = new webkitSpeechRecognition();</span><br><span class="line">  speech.interimResults = <span class="literal">true</span>;</span><br><span class="line">  speech.lang = <span class="string">'en-US'</span>;</span><br><span class="line">  speech.start();</span><br><span class="line"></span><br><span class="line">//有结果返回时</span><br><span class="line">  speech.addEventListener(<span class="string">'result'</span>, (e) =&gt; &#123;</span><br><span class="line">      const results = Array.from(e.results) </span><br><span class="line">      // e.results中保存的是识别的结果，本来并不是数组，需要将其转换为数组，方便使用其map、join等方法。</span><br><span class="line">        .map(result =&gt; result[0])</span><br><span class="line">        .map(result =&gt; result.transcript) // 获取到每一段话，是一个数组类型</span><br><span class="line">        .join(<span class="string">''</span>); // 将每一段话连接成字符串</span><br><span class="line">       //将结果输出在页面上</span><br><span class="line">        words.innerHTML = results;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//开始捕获到音频时</span><br><span class="line">speech.onaudiostart = <span class="keyword">function</span>(e) &#123;</span><br><span class="line">  console.log(<span class="string">'start'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//出现错误时</span><br><span class="line">speech.onerror = <span class="keyword">function</span>(e) &#123;</span><br><span class="line">  console.log(e.error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//语音识别结束时重新开始捕获语音</span><br><span class="line"> speech.onend = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">     speech.start();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;15网页菜单&quot;&gt;&lt;a href=&quot;#15网页菜单&quot; class=&quot;headerlink&quot; title=&quot;15网页菜单&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/ximoxiyu/JavaScript30/tree/master/15%20-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>js30系列03</title>
    <link href="http://yoursite.com/2020/03/27/js30%E7%B3%BB%E5%88%9703/"/>
    <id>http://yoursite.com/2020/03/27/js30%E7%B3%BB%E5%88%9703/</id>
    <published>2020-03-27T14:48:00.000Z</published>
    <updated>2020-03-30T04:14:39.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="09-Console-调试技巧"><a href="#09-Console-调试技巧" class="headerlink" title="09 Console 调试技巧"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master" target="_blank" rel="noopener">09 Console 调试技巧</a></h2><p>仅html+js<br>[console对象与控制台学习]（<a href="https://wangdoc.com/javascript/features/console.html）" target="_blank" rel="noopener">https://wangdoc.com/javascript/features/console.html）</a></p><ul><li>console对象是js的原生对象<br>console用途：调试程序，提供命令行接口;F12<br>console面板：命令行窗口</li><li>console对象的静态方法，可覆盖</li></ul><p>1.console.log()输出普通信息<br>%c：css格式字符串–%c后面的内容<br>%d：打印整数<br>%s：打印字符串<br>%f：打印浮点数<br>%o：打印javascript对象，可以是整数，字符串，JSON对象<br>2.console.info()输出提示信息<br>3.console.error()输出错误信息<br>4.console.warn()输出警示信息<br>5.console.debug()输出调试信息<br>6.console.table()数据打印成表格<br>7.console.assert() 条件判断，2个参数;在第一个参数为 false 的情况下会在控制台输出信息。<br>8.console.dir()检查，可以显示一个对象的所有属性和方法<br>9.console.count()打印标识及调用次数，可接收字符串为参数，对执行次数进行分类<br>10.console.group()数组设置分组信息<br>  console.groupEnd()结束当前的分组。 console.groupCollapsed()隐藏分组信息<br>11.console.time()测试程序执行的时长<br>  console.timeEnd()计时结束,执行时长显示在控制台。<br>12.console.clear()清除控台台之前的信息;若选中控制台的“Preserve log”选项，console.clear方法将不起作用。</p><a id="more"></a>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">     // Regular常规输出</span><br><span class="line">console.log(<span class="string">"我只是常规输出"</span>);</span><br><span class="line">    // Interpolated字符替换</span><br><span class="line">console.log(<span class="string">"我的名字为%s"</span>,<span class="string">"log"</span>);</span><br><span class="line">console.log(<span class="string">"我的年龄为 %f"</span>,22);</span><br><span class="line">    // Styled设定输出样式</span><br><span class="line">    // %c打印内容定义格式</span><br><span class="line">console.log(<span class="string">"偷偷告诉你，我会变身 %c ~\(≧▽≦)/~巴拉拉~~"</span>, <span class="string">"color: #00fdff; font-size: 2em;"</span>)</span><br><span class="line">    // warning!</span><br><span class="line">console.warn(<span class="string">"我是warnning"</span>);</span><br><span class="line">    // Error :|</span><br><span class="line">console.error(<span class="string">"我是报错error"</span>);</span><br><span class="line">    // Info输出提示信息</span><br><span class="line">console.info(<span class="string">"我是输出提示信息"</span>);</span><br><span class="line">  // Viewing DOM Elements打印输出DOM元素</span><br><span class="line">  const p =document.querySelector(<span class="string">'p'</span>);</span><br><span class="line">    console.log(p);</span><br><span class="line">    // Testing测试</span><br><span class="line">    console.assert(1===1,<span class="string">"这句话发布时删除"</span>);</span><br><span class="line">    console.assert(0===1,<span class="string">"console.assert()第一个参数为false时输出信息"</span>);</span><br><span class="line">    console.assert(p.innerHTML.match(<span class="string">"小红"</span>),<span class="string">"我这没有小红"</span>);</span><br><span class="line">    // clearing清除之前控制台上所有信息</span><br><span class="line">    //  console.clear();</span><br><span class="line">    // console.dir()可以显示一个对象的所有属性和方法</span><br><span class="line">    console.dir(p);</span><br><span class="line">    // Grouping together</span><br><span class="line">    // console.group();数组设置分组信息</span><br><span class="line">    // 使用 console.groupEnd() 方法来结束当前的分组。</span><br><span class="line">    // 使用 console.groupCollapsed() 方法来隐藏分组信息</span><br><span class="line">    dogs.forEach(dog=&gt;&#123;</span><br><span class="line">        console.group();</span><br><span class="line">        console.log(dog.name);</span><br><span class="line">        console.log(dog.age);</span><br><span class="line">        console.log(dog.name+<span class="string">'有'</span>+dog.age +<span class="string">'岁了'</span>);</span><br><span class="line">        // console.groupEnd();</span><br><span class="line">    &#125;);</span><br><span class="line">    // 数据打印成表格</span><br><span class="line">    console.table(dogs);</span><br><span class="line">    console.table(dogs,[<span class="string">"age"</span>]);</span><br><span class="line">    // counting</span><br><span class="line">    // Console.count()打印标识及次数</span><br><span class="line">    console.count(<span class="string">"（读来过反）羊只"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）羊只"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）鱼条"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）羊只"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）羊只"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）鱼条"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）鱼条"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）羊只"</span>);</span><br><span class="line">    // timing测试程序执行的时长</span><br><span class="line">console.time(<span class="string">'fetch my data'</span>);</span><br><span class="line">fetch(<span class="string">'https://api.github.com/users/wesbos'</span>)</span><br><span class="line">   .<span class="keyword">then</span>(data =&gt; data.json())</span><br><span class="line">   .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">       console.timeEnd(<span class="string">'fetch my data'</span>);</span><br><span class="line">   console.log(data)&#125;</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p>  <img src="/images/js30/9.png" alt="效果"><br>  【补充】控制台命令行API<br>  1)$(selector)返回第一个匹配的元素，等同于document.querySelector()<br>  2)$$(selector)返回选中的 DOM 对象，等同于document.querySelectorAll。<br>  3)dir(object)：显示特定对象的所有属性，是console.dir方法的别名。<br>  2.debugger 语句,除错，设置断点</p><hr><h2 id="10-JS-实现-Checkbox-中按住-Shift-的多选功能"><a href="#10-JS-实现-Checkbox-中按住-Shift-的多选功能" class="headerlink" title="10 JS 实现 Checkbox 中按住 Shift 的多选功能"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/10%20-%20Hold%20Shift%20and%20Check%20Checkboxes" target="_blank" rel="noopener">10 JS 实现 Checkbox 中按住 Shift 的多选功能</a></h2><p>  【html】checkbox 类型的 input 元素<br>  【目标】选中某个复选框时，其 <p> 标签中的文字会显示删除线。按下Shift执行多选  按下shift,A-B之间全选<br>  【核心】 选中checkbox(点击事件)–触发数组范围，判断当前状态及是否按下shift的键，进行相应范围选中，改变对应样式<br>  1.截取数组元素slice(m,n)  –结果:数组索引【m,n)<br>  2.Math.min(a,b) 返回a，b的最小值<br>  【js】获取 A 和 B，利用 indexOf() 来获得 A 和 B 在数组中的索引值，由此即可确定范围，并能通过 slice() 来直接截取 A-B 的所有 DOM 元素，并进行状态改变的操作，而变量 onOff 表示 A-B 范围内的状态，true 表示选中，false 表示取消选中<br>   <img src="/images/js30/10.png" alt="效果"></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  &lt;script&gt;</span><br><span class="line">    // 1.获取input</span><br><span class="line">    const boxs = document.querySelectorAll(<span class="string">'input'</span>);</span><br><span class="line">    // 转换 Nodelist 为数组</span><br><span class="line">    const boxArr=Array.from(boxs);</span><br><span class="line">    // 上次选中的变量</span><br><span class="line">    <span class="built_in">let</span> A;</span><br><span class="line">    //2.点击事件-触发函数：利用数组索引获取需要选中的范围</span><br><span class="line">     boxs.forEach(box =&gt;box.onclick=<span class="keyword">function</span>(e)&#123;</span><br><span class="line">        // A 是上一次操作选中的对象，B 是此次操作对象</span><br><span class="line">        <span class="keyword">if</span>(!A)</span><br><span class="line">        A =this;</span><br><span class="line">        // onOff 表示 A-B 范围内的状态</span><br><span class="line">        onOff = A.checked ? <span class="literal">true</span> :<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(e.shiftKey)&#123;</span><br><span class="line">            //针对按下了 Shift 键的情况，利用indexOf()获取 A-B 索引值</span><br><span class="line">            <span class="built_in">let</span> start =boxArr.indexOf(A);</span><br><span class="line">            <span class="built_in">let</span> end = boxArr.indexOf(this);</span><br><span class="line">           </span><br><span class="line">            // slice(A,B)截取 A-B 的数组元素，并用forEach遍历改变选中状态</span><br><span class="line">            boxArr.slice(Math.min(start,end),Math.max(start,end)+1).forEach(input =&gt; input.checked = onOff);</span><br><span class="line"></span><br><span class="line">            console.log(start + <span class="string">'---'</span> + end);</span><br><span class="line">        &#125;</span><br><span class="line">       A=this;</span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="12-暗号-特效-16鼠标移动"><a href="#12-暗号-特效-16鼠标移动" class="headerlink" title="[12 暗号-特效+16鼠标移动]"></a>[12 暗号-特效+16鼠标移动]</h2><p>【目标】网页输入暗号，生成特效<br>html+js，仅js<br>  KeyUp事件是键盘上的某个键按下后再松开时触发; Change事件是控件的内容发生改变时触发。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  &lt;script&gt;</span><br><span class="line">        //核心：监听并获取输入的字符,处理输入，在符合条件时，调用 cornify</span><br><span class="line"> // 1.声明一个空数组，存放字符串，并声明暗号</span><br><span class="line">        const pressed = [];</span><br><span class="line">        const secretCode = <span class="string">'hello'</span>;</span><br><span class="line">        // 触发keyup事件, keyup 事件是针对页面的，所以在调试时单击页面后时焦点在页面中才生效，在 Console 面板中是不会触发的。</span><br><span class="line">        window.onkeyup = <span class="keyword">function</span> (e) &#123;</span><br><span class="line">            //验证输入字符</span><br><span class="line">            console.log(e.key);</span><br><span class="line">//2.将每一个输入的字符存入 pressed 数组，然后处理数组，使其呈现队列的性质，也就是输入一个字符时，会挤出原有的的字符，保证其最大长度始终为 secretCode 的长度</span><br><span class="line">            //数组内增加元素,获取输入字符</span><br><span class="line">            pressed.push(e.key);</span><br><span class="line">            // 截取数组</span><br><span class="line">            pressed.splice(-secretCode.length - 1, pressed.length - secretCode.length);</span><br><span class="line">            </span><br><span class="line">// 3.判断是否有暗号</span><br><span class="line">//Array.join()将array数据中每个元素都转为字符串，用自定义的连接符分割</span><br><span class="line">            <span class="keyword">if</span> (pressed.join(<span class="string">''</span>).includes(secretCode)) &#123;</span><br><span class="line">                console.log(<span class="string">'暗号成功'</span>);</span><br><span class="line">          //调用cornify_add() 方法时，会在页面中追加 p 标签，并在 DOM 中插入一个图标</span><br><span class="line">                cornify_add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><br>  <img src="/images/js30/12.png" alt="效果"></p><h3 id="16-鼠标移动"><a href="#16-鼠标移动" class="headerlink" title="16.鼠标移动"></a>16.鼠标移动</h3><p><img src="/images/js30/16.png" alt="理论"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//文字阴影text-shadow: h-shadow v-shadow blur color</span><br><span class="line">text-shadow: 10px 10px 0 rgba(0,0,0,1);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     const hero = document.querySelector(<span class="string">'.hero'</span>);</span><br><span class="line">  const text = hero.querySelector(<span class="string">'h1'</span>);</span><br><span class="line">  //定义：当鼠标移动至显示区域边界时，阴影距离占hero元素宽和高的比例</span><br><span class="line">//   标记阴影距离h1中心的距离和鼠标距离h1中心距离的比例，用于计算阴影的具体位置</span><br><span class="line">  const factor = 0.4;</span><br><span class="line">  //触发鼠标移动mousemove事件</span><br><span class="line">  hero.onmousemove =<span class="keyword">function</span>(e)&#123;</span><br><span class="line">       //解构赋值</span><br><span class="line">    //    从事件发生的event对象中获取需要的值,简写了</span><br><span class="line">    const &#123; offsetWidth: width, offsetHeight: height &#125; = hero;</span><br><span class="line">    <span class="built_in">let</span> &#123; offsetX: x, offsetY: y &#125; = e;</span><br><span class="line">     //将鼠标位置转换为相对视口左上角的坐标，本例中由于hero元素占满视口故未起实际作用</span><br><span class="line">     <span class="keyword">if</span> (this !== e.target) &#123;</span><br><span class="line">      x = x + e.target.offsetLeft;</span><br><span class="line">      y = y + e.target.offsetTop;</span><br><span class="line">    &#125;</span><br><span class="line">    //阴影瞬时位置：鼠标位置距离h1中心的距离乘以factor</span><br><span class="line">    // x表示鼠标当前位置的坐标,width与height指代hero元素的宽和高：</span><br><span class="line">    const xWalk = parseInt((x-width/2)*factor);</span><br><span class="line">    const yWalk = parseInt((y-height/2)*factor);</span><br><span class="line">    //使用模板字符串赋值</span><br><span class="line">    // 绕h1元素中心旋转90°的方式共生成4个阴影</span><br><span class="line">    text.style.textShadow = `</span><br><span class="line">      <span class="variable">$&#123;xWalk&#125;</span>px <span class="variable">$&#123;yWalk&#125;</span>px 0 rgba(255,0,255,0.7),</span><br><span class="line">      <span class="variable">$&#123;xWalk * -1&#125;</span>px <span class="variable">$&#123;yWalk&#125;</span>px 0 rgba(0,255,255,0.7),</span><br><span class="line">      <span class="variable">$&#123;yWalk&#125;</span>px <span class="variable">$&#123;xWalk * -1&#125;</span>px 0 rgba(0,255,0,0.7),</span><br><span class="line">      <span class="variable">$&#123;yWalk * -1&#125;</span>px <span class="variable">$&#123;xWalk&#125;</span>px 0 rgba(0,0,255,0.7)</span><br><span class="line">    `;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="13-图片随屏幕滚动"><a href="#13-图片随屏幕滚动" class="headerlink" title="13.图片随屏幕滚动"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/13%20-%20Slide%20in%20on%20Scroll" target="_blank" rel="noopener">13.图片随屏幕滚动</a></h2><p>页面中的文章有几张配图，随着页面上下滚动，图片位置划过图片一半时，图片从两侧滑入；图片位置离开可见区域时，图片向两侧滑出。<br><img src="/images/js30/13.png" alt="理论"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        //debounce 函数来降低触发的次数。</span><br><span class="line">        <span class="keyword">function</span> debounce(func, <span class="built_in">wait</span> = 20, immediate = <span class="literal">true</span>) &#123;</span><br><span class="line">            var timeout;</span><br><span class="line">            <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                var context = this, args = arguments;</span><br><span class="line">                var later = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                    timeout = null;</span><br><span class="line">                    <span class="keyword">if</span> (!immediate) func.apply(context, args);</span><br><span class="line">                &#125;;</span><br><span class="line">                var callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = setTimeout(later, <span class="built_in">wait</span>);</span><br><span class="line">                <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 1.获取页面中的所有图片元素</span><br><span class="line">        const imgs = document.querySelectorAll(<span class="string">'.slide-in'</span>);</span><br><span class="line"></span><br><span class="line">        //2.滚动事件监听</span><br><span class="line">        //定义处理函数：检查滑动条</span><br><span class="line">        <span class="keyword">function</span> checkSlide(e) &#123;</span><br><span class="line">            imgs.forEach(img =&gt; &#123;</span><br><span class="line">                // 滑动页面的底部距离扣除图片一半的高</span><br><span class="line">                const slideInAt = (window.scrollY + window.innerHeight) - img.height / 2;</span><br><span class="line">                //图片的底部距离顶端距离</span><br><span class="line">                const imgBottom = img.offsetTop + img.height;</span><br><span class="line">                //  两个临界点：判图片是否在需显示的区域</span><br><span class="line">                // 已滑过了图片的一半</span><br><span class="line">                const isHalfShow = slideInAt &gt; img.offsetTop;</span><br><span class="line">                //未完全滑过图片</span><br><span class="line">                const isNotScrollPast = window.scrollY &lt; imgBottom;</span><br><span class="line">                <span class="keyword">if</span> (isHalfShow &amp;&amp; isNotScrollPast) &#123;</span><br><span class="line">                    img.classList.add(<span class="string">'active'</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    img.classList.remove(<span class="string">'active'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        //事件触发</span><br><span class="line">        window.addEventListener(<span class="string">'scroll'</span>, debounce(checkSlide));</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="14-JS的引用与复制"><a href="#14-JS的引用与复制" class="headerlink" title="14.JS的引用与复制"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/14%20-%20JavaScript%20References%20VS%20Copying" target="_blank" rel="noopener">14.JS的引用与复制</a></h2><p> 【注】直接运行页面后打开 Console，边编辑代码，边查看结果。<br> 1.Array类型与普通类型(Boolean Number String)不同，是引用不是复制，两个变量均指同一个数组，改任意一个均变<br> 2.解决：Array.prototype.slice()//数组浅拷贝，不改原数组<br>  Array.prototype.concat() //合并数组，不改<br>  const team4 = […players]//ES6 扩展语法<br>  Array.from()//创建新数组实例<br> 3.Object类型–引用，会改<br>   Object.assign(target, …sources) 时，后来的源对象的属性值，将会覆盖它之前的对象的属性。<br>   利用 JSON 可以先将对象转成字符串的格式，然后再把它转成 JSON，从而实现复制【不太理解】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 1.普通类型：String、Number、Boolean ：仅复制不引用，不改变</span><br><span class="line">    <span class="built_in">let</span> age = 100;</span><br><span class="line">    <span class="built_in">let</span> age2 = age;</span><br><span class="line">    console.log(<span class="string">'原变量'</span>+age,<span class="string">'复制后'</span>+age2);</span><br><span class="line">    // 改变一个值</span><br><span class="line">    age = 200;</span><br><span class="line">    console.log(<span class="string">'原变量'</span>+age,<span class="string">'更改后'</span>+age2);</span><br><span class="line"></span><br><span class="line">    // 2.数组Array类型：引用，均改</span><br><span class="line">    const players = [<span class="string">'Wes'</span>, <span class="string">'Sarah'</span>, <span class="string">'Ryan'</span>, <span class="string">'Poppy'</span>];</span><br><span class="line"></span><br><span class="line">    // 直接复制不可，因为 team 只是这个数组的引用，并不是它的复制。team 和 players 指向的是同一个数组。</span><br><span class="line"></span><br><span class="line">    //4种复制方法</span><br><span class="line">    //1)浅拷贝，运行 slice 得到的结果是一个对原数组的浅拷贝，原数组不会被修改</span><br><span class="line">    const team1 =players.slice();</span><br><span class="line">    team1[3] =<span class="string">'11'</span>;</span><br><span class="line">    console.log(<span class="string">'原'</span>+players[3],<span class="string">'浅拷贝'</span>+ team1[3]);</span><br><span class="line">    // 2)创建一个新数组，然后用 concat 方法来获取它</span><br><span class="line">    const team2 =[].concat(players);</span><br><span class="line">    team2[3] =<span class="string">'22'</span>;</span><br><span class="line">    console.log(<span class="string">'原'</span>+players[3],<span class="string">'concat合并数组'</span>+ team2[3]);</span><br><span class="line">    //3) ES6 里面的扩展语法</span><br><span class="line">    const team3 =[...players];</span><br><span class="line">    team3[3] =<span class="string">'33'</span>;</span><br><span class="line">    console.log(<span class="string">'原'</span>+players[3], <span class="string">'Es6写法'</span>+ team3[3]);</span><br><span class="line">    //4)Array.from()//创建新数组实例</span><br><span class="line">    const team4 =Array.from(players);</span><br><span class="line">    team4[3] =<span class="string">'44'</span>;</span><br><span class="line">    console.log(<span class="string">'原'</span>+players[3],<span class="string">'Array.from()创数组实例'</span>+ team4[3]);</span><br><span class="line">    //直接复制</span><br><span class="line">    const team = players;</span><br><span class="line">    team[3] =<span class="string">'Lux'</span>;</span><br><span class="line">    console.log( <span class="string">'原'</span>+players[3],<span class="string">'直接修改后'</span>+team[3]);</span><br><span class="line">    // 3.对象类型Object()</span><br><span class="line">     const person =&#123;</span><br><span class="line">        name:<span class="string">'Wes Bos'</span>,</span><br><span class="line">        age:20</span><br><span class="line">     &#125;;</span><br><span class="line">    //复制方法：2种</span><br><span class="line">    //1)Object.assign(target, ...sources) 时，后来的源对象的属性值，将会覆盖它之前的对象的属性。三个参数</span><br><span class="line">     const people =Object.assign(&#123;&#125;,person,&#123;age: 11&#125;);</span><br><span class="line">     console.log(<span class="string">'原:'</span>+person.age,<span class="string">'改:'</span>+people.age);</span><br><span class="line">    //json法：对象转字符串再转json--使用JSON.parse(JSON.stringify(obj))实现深拷贝</span><br><span class="line">    // stringify()从一个对象解析出字符串</span><br><span class="line">    // JSON.parse()从一个字符串中解析出json对象</span><br><span class="line">    const wes = &#123;</span><br><span class="line">      age: 100,</span><br><span class="line">    &#125;;</span><br><span class="line">    const people2 =JSON.parse(JSON.stringify(wes));</span><br><span class="line">    console.log(<span class="string">'原:'</span>+person.age,<span class="string">'改:'</span>+people2.age</span><br><span class="line"></span><br><span class="line">    //常规复制：均改，只引用不复制</span><br><span class="line">    const person1=person;</span><br><span class="line">        person1.age =80;</span><br><span class="line">    console.log(<span class="string">'原:'</span>+person.age,<span class="string">'常规复制:'</span>+person1.age);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/js30/14.png" alt="理论"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;09-Console-调试技巧&quot;&gt;&lt;a href=&quot;#09-Console-调试技巧&quot; class=&quot;headerlink&quot; title=&quot;09 Console 调试技巧&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/ximoxiyu/JavaScript30/tree/master&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;09 Console 调试技巧&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;仅html+js&lt;br&gt;[console对象与控制台学习]（&lt;a href=&quot;https://wangdoc.com/javascript/features/console.html）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://wangdoc.com/javascript/features/console.html）&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;console对象是js的原生对象&lt;br&gt;console用途：调试程序，提供命令行接口;F12&lt;br&gt;console面板：命令行窗口&lt;/li&gt;
&lt;li&gt;console对象的静态方法，可覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.console.log()输出普通信息&lt;br&gt;%c：css格式字符串–%c后面的内容&lt;br&gt;%d：打印整数&lt;br&gt;%s：打印字符串&lt;br&gt;%f：打印浮点数&lt;br&gt;%o：打印javascript对象，可以是整数，字符串，JSON对象&lt;br&gt;2.console.info()输出提示信息&lt;br&gt;3.console.error()输出错误信息&lt;br&gt;4.console.warn()输出警示信息&lt;br&gt;5.console.debug()输出调试信息&lt;br&gt;6.console.table()数据打印成表格&lt;br&gt;7.console.assert() 条件判断，2个参数;在第一个参数为 false 的情况下会在控制台输出信息。&lt;br&gt;8.console.dir()检查，可以显示一个对象的所有属性和方法&lt;br&gt;9.console.count()打印标识及调用次数，可接收字符串为参数，对执行次数进行分类&lt;br&gt;10.console.group()数组设置分组信息&lt;br&gt;  console.groupEnd()结束当前的分组。 console.groupCollapsed()隐藏分组信息&lt;br&gt;11.console.time()测试程序执行的时长&lt;br&gt;  console.timeEnd()计时结束,执行时长显示在控制台。&lt;br&gt;12.console.clear()清除控台台之前的信息;若选中控制台的“Preserve log”选项，console.clear方法将不起作用。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/03/26/hello-world/"/>
    <id>http://yoursite.com/2020/03/26/hello-world/</id>
    <published>2020-03-26T09:06:32.000Z</published>
    <updated>2020-03-26T09:06:34.340Z</updated>
    
    <content type="html"><![CDATA[<p>图片引用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></table></figure><p><img src="/images/img.jpg" alt="你好"></p><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;图片引用格式&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>js30系列02</title>
    <link href="http://yoursite.com/2020/03/26/js30%E7%B3%BB%E5%88%9702/"/>
    <id>http://yoursite.com/2020/03/26/js30%E7%B3%BB%E5%88%9702/</id>
    <published>2020-03-26T09:05:01.000Z</published>
    <updated>2020-03-27T14:50:56.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="04-07-数组Array"><a href="#04-07-数组Array" class="headerlink" title="04+07 数组Array"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/04%20-%20Array%20Cardio%20Day%201" target="_blank" rel="noopener">04+07 数组Array</a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">Array</a></p><p>Array对象–构造数组的全局对象<br>2个属性：Array.length<br>Array.prototype //通过数组的原型对象可以为所有数组对象添加属性。所有数组实例都会从 Array.prototype 继承属性和方法。修改 Array 的原型会影响到所有的数组实例<br>方法：<br>Array.prototype.sort()//对数组元素进行排序，并返回当前数组。<br>Array.prototype.splice()//任意的位置给数组添加或删除任意个元素。<br>Array.prototype.reverse()//颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。<br>【迭代方法】<br>Array.prototype.forEach()//数组中的每个元素执行一次回调函数<br>Array.prototype.every()//【每个】数组中的每个元素都满足测试函数，则返回 true，否则返回 false<br>Array.prototype.some()//【某个】数组中至少有一个元素满足测试函数，则返回 true，否则返回 false<br>Array.prototype.filter()//所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回<br>Array.prototype.find()//找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。<br>Array.prototype.findIndex() //找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。<br>Array.prototype.map()//返回一个由回调函数的返回值组成的新数组。<br>Array.prototype.reduce()//从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值<br><img src="/images/js30/4_7.png" alt="效果"></p><a id="more"></a><h2 id="05照片墙-弹性盒子"><a href="#05照片墙-弹性盒子" class="headerlink" title="05照片墙+弹性盒子"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/05%20-%20Flex%20Panel%20Gallery" target="_blank" rel="noopener">05照片墙+弹性盒子</a></h2><p>【html】父.panels的div块–5个小div，内部分别有3个p元素<br>【css】1.  min-height:100vh;//vh表示相对视窗高度<br>2. 过渡效果 transition:<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">font-size 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),</span><br><span class="line">flex 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),</span><br><span class="line">background 0.2s;</span><br></pre></td></tr></table></figure><br>3. 每一个子div盒子设置为弹性盒子，三个子元素p用flex=1;将宽度均分，justify-conten+flex-direction确定相对位置<br>4. .panel &gt; * {} //类元素下所有元素<br>5. .panel p:nth-child(2) {}//每个小块下的第二个p<br>6. .panel.open {}与.cta{}<br>7. transform: translateY(100%);//向Y轴移动，设置为了让一开始只有中间P显示在页面内<br>8. 改变效果transform ： none ;    也就是：  transform: rotate | scale | skew | translate |matrix; //空格隔开<br>   <a href="https://blog.csdn.net/dongfanghaoyu/article/details/9253913" target="_blank" rel="noopener">transition&amp;transform</a><br>   <a href="https://segmentfault.com/q/1010000004080910" target="_blank" rel="noopener">flex:1</a>运用 flex 可以使各个元素按一定比例占据页面<br><img src="/images/js30/5.png" alt="效果"></p><!--more--><p>【总结】<br>element.classList.toggle()//在元素中切换类名，有就删除，没有就添加;重点是改CSS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">//1.获取所有类名为 panel 的元素</span><br><span class="line">//匹配指定 CSS 选择器的所有元素</span><br><span class="line">const panels = document.querySelectorAll(<span class="string">'.panel'</span>);</span><br><span class="line">// 2.为其添加 click 事件监听，编写触发事件调用的函数（给触发的 DOM 元素添加/去掉样式，实现拉伸/压缩的效果）</span><br><span class="line">panels.forEach(panel=&gt;panel.onclick=<span class="keyword">function</span>(e)&#123;</span><br><span class="line">  //添加类名</span><br><span class="line">  console.log(this);</span><br><span class="line">   this.classList.toggle(<span class="string">'open'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="难06-Fetch-filter快速匹配古诗"><a href="#难06-Fetch-filter快速匹配古诗" class="headerlink" title="难06.Fetch+filter快速匹配古诗"></a>难<a href="https://github.com/ximoxiyu/JavaScript30/tree/master/06%20-%20Type%20Ahead" target="_blank" rel="noopener">06.Fetch+filter快速匹配古诗</a></h2><p>【考察】 Ajax，json,异步操作，Promise，Array与正则</p><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noopener">Fetch API</a>提供了一个获取资源的接口（包括跨域请求）,提供全局方法fetch();接受 (资源的路径)作为参数，返回值是一个 Promise 对象。若请求成功，这个对象包含了（对应 Request 的）Response，但这只是一个 HTTP 响应。<br>fetch(input, init).then(function(response) { … });<br>常用的方法还有：blob()、text()、arrayBuffer()、formData()和json()</li><li>正则表达式<br>正则表达式的 match() 可以执行数据匹配，我们再结合 Array.filter() 便能筛出整个数组中，满足条件的项，再经过字符串处理即可输出到页面。<br>【html】form:input(输入框)与ul(列表展示)<br>input标签内placeholder 属性适用类型：text, search, url, telephone, email 以及 password。<br>表：输入字段预期值<br>诗句的来源 json 数据是加载页面时从网络中异步获得<br><img src="/images/js30/6.png" alt="效果"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    const endpoint = <span class="string">'https://gist.githubusercontent.com/soyaine/81399bb2b24ca1bb5313e1985533c640/raw/bdf7df2cbcf70706c4a5e51a7dfb8c933ed78878/TangPoetry.json'</span>;</span><br><span class="line"></span><br><span class="line">      // fetch(资源路径).<span class="keyword">then</span>(<span class="keyword">function</span>(response) &#123; ... &#125;);ES6写法</span><br><span class="line">      //1.声明一个空数组，用于存放解析 json 后的数据</span><br><span class="line">      const poetrys = [];</span><br><span class="line">      // 异步获取数据并解析,运用 fetch() 发送 HTTP 请求,获取返回的 Promise 对象,解析 JSON 数据,存入数组poetrys</span><br><span class="line">      fetch(endpoint)</span><br><span class="line">          .<span class="keyword">then</span>(blob =&gt; blob.json())</span><br><span class="line">          .<span class="keyword">then</span>(data =&gt; poetrys.push(...data));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      //先声明函数，方便后面事件绑定</span><br><span class="line"></span><br><span class="line">      // 匹配输入的函数:运用 filter() 过滤数组数据,创建正则表达式，构造过滤条件</span><br><span class="line">      <span class="keyword">function</span> findMatches(wordToMatch, poetrys) &#123;</span><br><span class="line">          <span class="built_in">return</span> poetrys.filter(poet =&gt; &#123;</span><br><span class="line">              //正则找出匹配诗句</span><br><span class="line">              //  在js中提供了一个内置构造函数RegExp来创建一个正则对象</span><br><span class="line">              const regex = new RegExp(wordToMatch, <span class="string">'gi'</span>);</span><br><span class="line">              const author = poet.detail_author.join(<span class="string">''</span>);</span><br><span class="line">              <span class="built_in">return</span> poet.detail_text.match(regex) || poet.title.match(regex) || author.match(regex);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 展示匹配结果函数:获取匹配数据,替换关键词放入高亮的标签,构造 HTML 标签数据,将匹配值的 HTML 标签放入 &lt;ul&gt; 中</span><br><span class="line">      <span class="keyword">function</span> <span class="function"><span class="title">displayMatches</span></span>() &#123;</span><br><span class="line">          // 获取匹配数据</span><br><span class="line">          const matches = findMatches(this.value, poetrys);</span><br><span class="line">          const regex = new RegExp(this.value, <span class="string">'gi'</span>);</span><br><span class="line">          const html = matches.map(poet =&gt; &#123;</span><br><span class="line">              //替换高亮标签</span><br><span class="line">              const text = poet.detail_text.replace(regex, `&lt;span class=<span class="string">"h1"</span>&gt;<span class="variable">$&#123;this.value&#125;</span>&lt;/span&gt;`);</span><br><span class="line">              const title = poet.title.replace(regex, `&lt;span class=<span class="string">"hl"</span>&gt;<span class="variable">$&#123;this.value&#125;</span>&lt;/span&gt;`);</span><br><span class="line">              //构造HTML值</span><br><span class="line">              <span class="built_in">return</span> `</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;span class=<span class="string">"poet"</span>&gt;<span class="variable">$&#123; text&#125;</span>&lt;/span&gt;</span><br><span class="line">&lt;span class=<span class="string">"title"</span>&gt;<span class="variable">$&#123; title&#125;</span> - <span class="variable">$&#123;poet.detail_author[0]&#125;</span>&lt;/span&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">`;</span><br><span class="line">          &#125;).join(<span class="string">''</span>);</span><br><span class="line">          ulSuggestions.innerHTML = html;</span><br><span class="line">      &#125;</span><br><span class="line">      //2.获取两个主要 HTML 元素（&lt;input&gt;，&lt;ul&gt;），给 &lt;input&gt; 添加事件监听（change, keyup）均触发同一个函数</span><br><span class="line">      const inputSearch = document.querySelector(<span class="string">'.search'</span>);</span><br><span class="line">      const ulSuggestions = document.querySelector(<span class="string">'.suggestions'</span>);</span><br><span class="line">      inputSearch.addEventListener(<span class="string">'change'</span>, displayMatches);</span><br><span class="line">      inputSearch.addEventListener(<span class="string">'keyup'</span>, displayMatches);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;04-07-数组Array&quot;&gt;&lt;a href=&quot;#04-07-数组Array&quot; class=&quot;headerlink&quot; title=&quot;04+07 数组Array&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/ximoxiyu/JavaScript30/tree/master/04%20-%20Array%20Cardio%20Day%201&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;04+07 数组Array&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Array&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Array对象–构造数组的全局对象&lt;br&gt;2个属性：Array.length&lt;br&gt;Array.prototype //通过数组的原型对象可以为所有数组对象添加属性。所有数组实例都会从 Array.prototype 继承属性和方法。修改 Array 的原型会影响到所有的数组实例&lt;br&gt;方法：&lt;br&gt;Array.prototype.sort()//对数组元素进行排序，并返回当前数组。&lt;br&gt;Array.prototype.splice()//任意的位置给数组添加或删除任意个元素。&lt;br&gt;Array.prototype.reverse()//颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。&lt;br&gt;【迭代方法】&lt;br&gt;Array.prototype.forEach()//数组中的每个元素执行一次回调函数&lt;br&gt;Array.prototype.every()//【每个】数组中的每个元素都满足测试函数，则返回 true，否则返回 false&lt;br&gt;Array.prototype.some()//【某个】数组中至少有一个元素满足测试函数，则返回 true，否则返回 false&lt;br&gt;Array.prototype.filter()//所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回&lt;br&gt;Array.prototype.find()//找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。&lt;br&gt;Array.prototype.findIndex() //找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。&lt;br&gt;Array.prototype.map()//返回一个由回调函数的返回值组成的新数组。&lt;br&gt;Array.prototype.reduce()//从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值&lt;br&gt;&lt;img src=&quot;/images/js30/4_7.png&quot; alt=&quot;效果&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="js30" scheme="http://yoursite.com/tags/js30/"/>
    
  </entry>
  
  <entry>
    <title>js30系列01</title>
    <link href="http://yoursite.com/2020/03/23/js30%E7%B3%BB%E5%88%9701/"/>
    <id>http://yoursite.com/2020/03/23/js30%E7%B3%BB%E5%88%9701/</id>
    <published>2020-03-23T13:04:31.000Z</published>
    <updated>2020-03-26T10:43:00.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-打鼓"><a href="#01-打鼓" class="headerlink" title="01 打鼓"></a>01 <a href="https://github.com/ximoxiyu/JavaScript30/tree/master/01%20-%20JavaScript%20Drum%20Kit" target="_blank" rel="noopener">打鼓</a></h2><p>【基本思路】<br>触发键盘按键ASDFGHJKL,进行audio播放与样式的改变,结束后触发transitionend事件去除样式;<br>【html】一大块div(keys)内含9小块div(key)，每小块div有自身的键码data-key与音频sound;<br>每个按键码对应一个audio标签，进行指定音频【注：音频地址为本地sounds文件夹】</p><a id="more"></a><p>【css】<br>1)样式背景属性<a href="https://blog.csdn.net/qq_27674439/article/details/90674949" target="_blank" rel="noopener">background</a><br>我只设置了图片与位置,大小;注意：position与size使用时加/<br>2)高亮样式.playing由动态添加<br>3) /* 复合属性，含四个子属性，所用属性在0.07秒内匀速变化 */<br>  transition:all .07s;<br>4)设置英文字母为大写text-transform: uppercase;</p><p>【重点-JS】<br>两个事件：键盘keydown事件与transitionend事件<br>keydown事件：按键后audio.play()与增加样式<br>transitionend事件:获取所有按键，移出新样式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//监听键盘事件</span><br><span class="line">window.onkeydown =<span class="keyword">function</span> (e) &#123; </span><br><span class="line">    // 1.获取键码--获取音频与DIV元素</span><br><span class="line">    const audio=document.querySelector(`audio[data-key=<span class="string">"<span class="variable">$&#123;event.keyCode&#125;</span>"</span>]`);</span><br><span class="line">    const key=document.querySelector(`div[data-key=<span class="string">"<span class="variable">$&#123;event.keyCode&#125;</span>"</span>]`);</span><br><span class="line">    // 2.处理元素:播放音频，添加样式</span><br><span class="line">    // <span class="keyword">if</span>(!audio) <span class="built_in">return</span>;//处理无效按键</span><br><span class="line">    key.classList.add(<span class="string">'playing'</span>);//每个按键添加类名--添样式</span><br><span class="line">    //没有此语句时，按住不放是一声一声，加上后是连续鼓点</span><br><span class="line">    audio.currentTime = 0; // 每次播放之后都使音频播放进度归零=按键按住不放时，马上响起连续鼓点声</span><br><span class="line">    audio.play();//音频播放</span><br><span class="line">&#125;;</span><br><span class="line">// document.querySelectorAll()返回的不是一个数组，而是一个NodeList;不可遍历，所以使用Array.from转化成数组</span><br><span class="line">//获取页面上所有按键,为其添加transitionend 的事件，去除样式</span><br><span class="line">const keys = Array.from(document.querySelectorAll(<span class="string">'.key'</span>));</span><br><span class="line">//遍历元素触发事件</span><br><span class="line">keys.forEach(key=&gt;key.ontransitionend=<span class="keyword">function</span>(event)&#123;</span><br><span class="line">  // 过滤其中一种事件</span><br><span class="line">    <span class="keyword">if</span>(event.propertyName !=<span class="string">"transform"</span>)</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">      //去除样式</span><br><span class="line">    event.target.classList.remove(<span class="string">'playing'</span>);</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>【易错点】</p><ol><li>keys.forEach();//forEach后面直接加()</li><li>模板字面量–模板字符串的标识<br><code>字符串 ${ 变量、属性名 }</code><br>const audio=document.querySelector(`audio[data-key=”${event.keyCode}”]//为什么加了””?</li></ol><hr><h2 id="02-纯-JS、CSS-时钟"><a href="#02-纯-JS、CSS-时钟" class="headerlink" title="02 纯 JS、CSS 时钟"></a>02 <a href="https://github.com/ximoxiyu/JavaScript30/tree/master/02%20-%20JS%20%2B%20CSS%20Clock" target="_blank" rel="noopener">纯 JS、CSS 时钟</a></h2><p>目的：动态更新指针位置<br>关键：指针的旋转与获取实时时间，每转一秒改变一次指针状态–类比音乐播放器的旋转<br>核心思想:每走1s，改变分针的角度;实质：利用定时器setInterval获取当前时间Date对象时分秒针的转动角度，改变转动样式<br><img src="/images/js30/2.png" alt="效果"><br>【html】最大块clock–含整个表clock-face–含时,分，秒针<br>【css】圆盘指针属性<br>【js】1.获html节点<br>2.定时器setInterval每隔1s=1000ms进行一次处理(获取当前时间，更改对应角度，注意加90°–起始位置,获取到的html节点来改变样式transform：rotate())</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 核心:动态改时间旋转角度</span><br><span class="line">// 1.获取三个指针的HTML</span><br><span class="line">const secHand = document.querySelector(<span class="string">'.second-hand'</span>);</span><br><span class="line">const minHand = document.querySelector(<span class="string">'.min-hand'</span>);</span><br><span class="line">const hourHand = document.querySelector(<span class="string">'.hour-hand'</span>);</span><br><span class="line">//定时器+Data获取时间,定时器间隔ms</span><br><span class="line">var num=setInterval(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  // 编写setDate函数,获取当前时分秒，计算相应角度</span><br><span class="line">  //获取当前时间</span><br><span class="line">  const data = new Date();</span><br><span class="line">  const second =data.getSeconds();//获取秒</span><br><span class="line">  //计算角度：90°--0秒，60秒走360度</span><br><span class="line">  const secondDeg = 90+(second/60)*360;</span><br><span class="line">  const min =data.getMinutes();</span><br><span class="line">  const minDeg = 90 +(min/60)*360;</span><br><span class="line">  const hour = data.getHours();</span><br><span class="line">  //加入分钟所占的时间，是时针缓慢移动</span><br><span class="line">  // 时针在一小时内缓慢的移动到下一个时间点。所以可以利用上分钟，计算每一分钟对时针的角度影响，将加到时针角度上即可</span><br><span class="line">  const hourDeg = 90 + (hour / 12) * 360 + (min / 12 / 60) * 360;</span><br><span class="line">  // const hourDeg =( 90+ (hour/12)*360);也可</span><br><span class="line"></span><br><span class="line">  // 动态将角度值赋值给 HTML 元素的 style 中的 transform 属性</span><br><span class="line">  secHand.style.transform=`rotate(<span class="variable">$&#123;secondDeg&#125;</span>deg)`;</span><br><span class="line">  minHand.style.transform = `rotate(<span class="variable">$&#123; minDeg &#125;</span>deg)`;</span><br><span class="line">  hourHand.style.transform = `rotate(<span class="variable">$&#123; hourDeg &#125;</span>deg)`;</span><br><span class="line">        //在控制台打印当前时间及对应的角度</span><br><span class="line">        console.log(`<span class="variable">$&#123;hour&#125;</span>:<span class="variable">$&#123;min&#125;</span>:<span class="variable">$&#123;second&#125;</span>-角度<span class="variable">$&#123;hourDeg&#125;</span>:<span class="variable">$&#123;minDeg&#125;</span>:<span class="variable">$&#123;secondDeg&#125;</span>`);</span><br><span class="line">&#125;,1000); </span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>【难点】css中的样式设定：指针加阴影box-shadow<br>1.贝塞尔曲线过渡<a href="https://www.cnblogs.com/tenfly/p/11559845.html" target="_blank" rel="noopener">transition-timing-function: cubic-bezier(0.9, 0.54, 0.26, 1.68);</a><br>2.转换–调整曲线轴点–旋转元素的基点位置[transform-origin]<br>3.过渡–时钟指针跳动时的过渡效果<br>transition: all 3s;//复合属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: property duration timing-function delay;</span><br></pre></td></tr></table></figure><p>这里js主要改的是transform:rotate()</p><h3 id="3-js控制css"><a href="#3-js控制css" class="headerlink" title="3.js控制css"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/03%20-%20CSS%20Variables" target="_blank" rel="noopener">3.js控制css</a></h3><p>【核心】触发事件mousemove或input的change,改变css的样式<br><img src="/images/js30/3.png" alt="效果"><br>【html】标题,<a href="https://blog.csdn.net/zhouziyu2011/article/details/58594447?utm_source=blogxgwz0" target="_blank" rel="noopener">label+input</a>构成控制栏(),图片img</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//通过为&lt;input&gt;设置id属性，在&lt;lable&gt;标签中设置<span class="keyword">for</span>=id来让说明文本和对应的&lt;input&gt;关联起来。</span><br><span class="line"> &lt;label <span class="keyword">for</span>=<span class="string">"spacing"</span>&gt;Spacing:&lt;/label&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"range"</span> name=<span class="string">"spacing"</span> min=<span class="string">"10"</span> max=<span class="string">"200"</span> value=<span class="string">"10"</span> data-sizing=<span class="string">"px"</span>&gt;</span><br></pre></td></tr></table></figure><p>【css】</p><ol><li>声明全局（:root）对应html标签的 CSS 变量  –变量名</li><li>使用全局变量(要改变的元素hh类与img内使用) var(–变量名)<br>【js】</li><li>两种事件均会改变样式，故将改变样式封装成函数，触发事件调用此函数即可</li><li>多个input标签选定节点，forEach遍历;</li><li>addEventListener事件监听，一个事件可执行多个函数</li><li>change事件-input值变动，触发;mousemove-鼠标移动<br>【难点】样式改变<br>1)获取参数值后缀—数据属性 dataset<br>2)获取参数名与参数值<br>3)对应css变量赋值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        //   用 JS和 CSS3 实现拖动滑块时，实时调整图片的内边距、模糊度、背景颜色，同时标题中 JS 两字的颜色也随图片背景颜色而变化。</span><br><span class="line"></span><br><span class="line">        // 编写处理更新操作的方法</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">handleUpdate</span></span>() &#123;</span><br><span class="line">            // 获取参数值后缀</span><br><span class="line">            const suffix = this.dataset.sizing || <span class="string">''</span>; // 根据 data-sizing 获取参数的后缀</span><br><span class="line">            // 获取参数名（blur、spacing、color）</span><br><span class="line">            document.documentElement.style.setProperty(`--<span class="variable">$&#123;this.name&#125;</span>`, this.value + suffix); // 设置页面 CSS 变量的值</span><br><span class="line">            // 获取参数值（12px、<span class="comment">#efefef）并赋值给相应的CSS变量--文档根元素</span></span><br><span class="line">            document.getElementById(this.name).innerText = this.value + suffix; // 页面参数实时显示</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取页面中 input 元素</span><br><span class="line">        const inputs = document.querySelectorAll(<span class="string">'.controls input'</span>);</span><br><span class="line">        // 给每个 input 添加监听事件(两种)，使其在值变动，触发更新操作</span><br><span class="line">        inputs.forEach(input =&gt; input.addEventListener(<span class="string">'mousemove'</span>, handleUpdate));//可以加多个函数,不能加多个事件</span><br><span class="line">        inputs.forEach( input =&gt; input.addEventListener(<span class="string">'change'</span>, handleUpdate));</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="处理参数值"><a href="#处理参数值" class="headerlink" title="处理参数值"></a>处理参数值</h4>只需要加上 data- 前缀，可以随便添加和命名,利用dataset来访问，dataset 的值是 DOMStringMap 的一个实例化对象，其中包含之前所设定的自定义属性的“名-值”对。<br>input标签中声明data-sizing=”px”,在js中用dataset.sizing来获取后缀名</li></ol><h4 id="js处理css样式"><a href="#js处理css样式" class="headerlink" title="js处理css样式"></a>js处理css样式</h4><p>获取文档根元素document.documentElement，改变css的全局变量</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;01-打鼓&quot;&gt;&lt;a href=&quot;#01-打鼓&quot; class=&quot;headerlink&quot; title=&quot;01 打鼓&quot;&gt;&lt;/a&gt;01 &lt;a href=&quot;https://github.com/ximoxiyu/JavaScript30/tree/master/01%20-%20JavaScript%20Drum%20Kit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;打鼓&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;【基本思路】&lt;br&gt;触发键盘按键ASDFGHJKL,进行audio播放与样式的改变,结束后触发transitionend事件去除样式;&lt;br&gt;【html】一大块div(keys)内含9小块div(key)，每小块div有自身的键码data-key与音频sound;&lt;br&gt;每个按键码对应一个audio标签，进行指定音频【注：音频地址为本地sounds文件夹】&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="js30" scheme="http://yoursite.com/tags/js30/"/>
    
  </entry>
  
</feed>
