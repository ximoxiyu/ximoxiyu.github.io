<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-09T12:08:08.551Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ximoxiyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>03队列</title>
    <link href="http://yoursite.com/2020/04/09/03%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/04/09/03%E9%98%9F%E5%88%97/</id>
    <published>2020-04-09T07:05:00.000Z</published>
    <updated>2020-04-09T12:08:08.551Z</updated>
    
    <content type="html"><![CDATA[<p>1.队列：先进先出FIFO  首部删除，尾部增加–排队<br>在程序中的应用：打印队列，线程队列<br>2.方法<br>enqueue(element)增尾，dequeue()删首<br>front()返回队列中第一个元素，不改<br>isEmpty()，size()<br>同栈</p><a id="more"></a><p>3.优先级队列：元素本身的优先级有关系的队列.（机场登机）<br>【实现】1)封装元素和优先级放在一起(可以封装一个新的构造函数)<br>2)添加元素时, 将当前的优先级和队列中已经存在的元素优先级进行比较, 以获得自己正确的位置.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要是新构造了一个函数，用来保存元素及优先级，由原来的一个参数变为两个参数，方便封装enqueue()时使用</span></span><br><span class="line"><span class="comment">//在封装enqueue()利用上述构造新new一个对象newElement,有元素及优先级属性；主逻辑：在增加对象时先判断此队列是否为空，空则直接push,不空--遍历队列，比较新元素优先级与队列每个元素的优先级，若比其小，则利用splice进行添加；若均大，push添加到末尾</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.封装一个新函数，保存元素及优先级</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">QueueElement</span>(<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.element = element</span><br><span class="line">                <span class="keyword">this</span>.priority = priority</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.添加元素的方法被改，有参数</span></span><br><span class="line">            PriorityQueue.prototype.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//   1)根据传入元素，创建新对象</span></span><br><span class="line">                <span class="keyword">var</span> newElement = <span class="keyword">new</span> QueueElement(element, priority)</span><br><span class="line">                <span class="comment">//2)获取正确位置</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.items.push(newElement)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> flag = <span class="literal">false</span>;<span class="comment">//是否填加成功</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;  <span class="keyword">this</span>.items.length; i++) &#123;</span><br><span class="line">                        <span class="comment">//规定数越小，优先级越高</span></span><br><span class="line">                        <span class="keyword">if</span> ( newElement.priority &lt;  <span class="keyword">this</span>.items[i].priority) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.items.splice(i, <span class="number">0</span>, newElement);</span><br><span class="line">                            flag = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;<span class="comment">//添加成功后退出</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//若表优先级的数比其他都大，则加到最后</span></span><br><span class="line">                    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.items.push(newElement)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>【例子：击鼓传花–Queue】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//击鼓传花的函数 名字序列和淘汰数字</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">queGame</span>(<span class="params">nameList,num</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> q = <span class="keyword">new</span> Queue();</span><br><span class="line">           <span class="comment">//1.遍历放入队列</span></span><br><span class="line">           nameList.forEach(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">               <span class="comment">//放入队列</span></span><br><span class="line">               q.enqueue(value)</span><br><span class="line">           &#125;)</span><br><span class="line">           <span class="comment">//2.队列不为1时，判断!=num,加入最后，否则出列</span></span><br><span class="line">           <span class="keyword">while</span>(q.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="comment">//假设从0开始数</span></span><br><span class="line">               <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">                   <span class="comment">//前出列，放入后面</span></span><br><span class="line">                   q.enqueue(q.dequeue())</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//移除数到num的人</span></span><br><span class="line">               q.dequeue()</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.获取最后一个人--赢家</span></span><br><span class="line">           <span class="keyword">var</span> winName =q.dequeue()</span><br><span class="line">           alert(<span class="string">'winer:'</span>+ winName)</span><br><span class="line">           <span class="comment">//4.获取此人位置   indexOf: 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1</span></span><br><span class="line">           <span class="keyword">return</span> nameList.indexOf(winName)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//测试</span></span><br><span class="line">       <span class="keyword">var</span> names =[<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>,<span class="string">'dd'</span>,<span class="string">'ee'</span>];</span><br><span class="line">       <span class="keyword">var</span> index = queGame(names,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.队列：先进先出FIFO  首部删除，尾部增加–排队&lt;br&gt;在程序中的应用：打印队列，线程队列&lt;br&gt;2.方法&lt;br&gt;enqueue(element)增尾，dequeue()删首&lt;br&gt;front()返回队列中第一个元素，不改&lt;br&gt;isEmpty()，size()&lt;br&gt;同栈&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>02栈</title>
    <link href="http://yoursite.com/2020/04/09/02%E6%A0%88/"/>
    <id>http://yoursite.com/2020/04/09/02%E6%A0%88/</id>
    <published>2020-04-09T04:43:00.000Z</published>
    <updated>2020-04-09T12:09:19.664Z</updated>
    
    <content type="html"><![CDATA[<p>1.线性结构：数组，栈，队列<br>其中数组：任意位置增删元素，不受限；而栈与列表为受限线性结构–一端操作<br>2.stack栈，后进先出LIFO(last in first out)<br>方法：与对象实例有联系<br>原型：给整个类定义方法而不是某一个实例<br>函数调用栈<br>递归：为什么没有停止条件的递归会造成栈溢出？比如函数A为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数A压入栈，最后造成栈溢出（Stack Overfloat</p><a id="more"></a><p>3.栈的操作：push(元素),pop(),peek()–只返回栈顶元素，栈不变 isEmpty(),size()–栈中元素个数，toString()–栈结构内容以字符串形式返回<br>4.用类模拟栈中操作【疑问：栈是有记忆性吗？【object object】】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       <span class="comment">//栈结构封装：1)数组 2)链表  使用数组封装，即栈内放数组结构</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="comment">//栈的属性：定义一个数组类型的变量</span></span><br><span class="line">           <span class="comment">// var items =[1,2,3] 错误！！！</span></span><br><span class="line">           <span class="keyword">this</span>.items = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">           <span class="comment">//栈相关的方法(操作)--数组操作模拟--建议使用原型封装:给整个类而不是某具体实例   prototype，节省内存</span></span><br><span class="line">           <span class="comment">//1.压栈push(元素)</span></span><br><span class="line">           <span class="comment">// Stack.prototype.push = function (element)&#123;</span></span><br><span class="line">           <span class="comment">//     this.items.push(element)</span></span><br><span class="line">           <span class="comment">// &#125;</span></span><br><span class="line">            Stack.prototype.push = <span class="function">(<span class="params">element</span>)=&gt;</span> <span class="keyword">this</span>.items.push(element)</span><br><span class="line">           <span class="comment">//2.出栈pop():箭头函数方式书写</span></span><br><span class="line">           <span class="comment">// this.pop =()=&gt;&#123;items.pop()&#125;//给某一个实例,不建议！！</span></span><br><span class="line">           Stack.prototype.pop = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.items.pop()</span><br><span class="line">           <span class="comment">//3.查看栈顶元素peek()</span></span><br><span class="line">           Stack.prototype.peek = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>]</span><br><span class="line">           <span class="comment">//4.判断栈是否为空isEmpty()</span></span><br><span class="line">           Stack.prototype.isEmpty = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.items.length == <span class="number">0</span></span><br><span class="line">           <span class="comment">//5.栈中元素个数size()</span></span><br><span class="line">           Stack.prototype.size = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.items.length</span><br><span class="line">           <span class="comment">// //6.内容转字符串 toString()</span></span><br><span class="line">           Stack.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">               <span class="keyword">var</span> resultString = <span class="string">''</span>;</span><br><span class="line">               <span class="keyword">this</span>.items.forEach(<span class="function"><span class="params">t</span> =&gt;</span> resultString += t +<span class="string">' '</span>);<span class="comment">//注意有间隔！改了好久</span></span><br><span class="line">               <span class="keyword">return</span> resultString</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//声明</span></span><br><span class="line">       <span class="keyword">var</span> s = <span class="keyword">new</span> Stack()</span><br><span class="line">       <span class="comment">//测试</span></span><br><span class="line">       s.push(<span class="number">20</span>)</span><br><span class="line">       s.push(<span class="number">50</span>)</span><br><span class="line">       s.push(<span class="number">80</span>)</span><br><span class="line">       s.push(<span class="number">100</span>)</span><br><span class="line">       alert(s) <span class="comment">//1 2 3 20 50 80 100</span></span><br><span class="line">       alert(s.pop())<span class="comment">//100</span></span><br><span class="line">       alert(s.peek())<span class="comment">//80</span></span><br><span class="line">       alert(s.isEmpty())<span class="comment">//false</span></span><br><span class="line">       alert(s.size())<span class="comment">//6</span></span><br><span class="line">       alert(s.toString())<span class="comment">//1 2 3 20 50 80 </span></span><br><span class="line"></span><br><span class="line">   &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>【例子：十进制转二进制】—运行时显示内存不够？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decToBin</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">           <span class="keyword">var</span> flag=<span class="number">0</span>;</span><br><span class="line">           <span class="comment">//循环作除，不知次数用while()</span></span><br><span class="line">           <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               aa = <span class="built_in">Math</span>.floor(num/<span class="number">2</span>);<span class="comment">//向下取整</span></span><br><span class="line">               flag = num % <span class="number">2</span>;</span><br><span class="line">               <span class="comment">//将余数压栈</span></span><br><span class="line">               stack.push(flag);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//出栈</span></span><br><span class="line">           <span class="keyword">var</span> cc =<span class="string">''</span>;</span><br><span class="line">           <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">               cc+=stack.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// alert(cc)</span></span><br><span class="line">           <span class="keyword">return</span> cc</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//测试代码，调用函数</span></span><br><span class="line">       <span class="built_in">console</span>.log(decToBin(<span class="number">8</span>))</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/eade026ffaf5" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.线性结构：数组，栈，队列&lt;br&gt;其中数组：任意位置增删元素，不受限；而栈与列表为受限线性结构–一端操作&lt;br&gt;2.stack栈，后进先出LIFO(last in first out)&lt;br&gt;方法：与对象实例有联系&lt;br&gt;原型：给整个类定义方法而不是某一个实例&lt;br&gt;函数调用栈&lt;br&gt;递归：为什么没有停止条件的递归会造成栈溢出？比如函数A为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数A压入栈，最后造成栈溢出（Stack Overfloat&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>01数组</title>
    <link href="http://yoursite.com/2020/04/09/01%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/04/09/01%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97/</id>
    <published>2020-04-09T02:49:00.000Z</published>
    <updated>2020-04-09T12:08:15.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><a href="https://www.jianshu.com/p/9521594710d7" target="_blank" rel="noopener">数组</a></h2><p>1.其他语言：存储同一类型数据；js可存储不同数据类型数据<br>2优势：节省变量个数，将其统一保存在一个数组内</p><a id="more"></a><p>3.创建数组并初始化 new Array()或直接【】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.数组的创建与初始化</span></span><br><span class="line">       <span class="keyword">var</span> aa = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">       <span class="keyword">var</span> bb = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">7</span>);</span><br><span class="line">       <span class="keyword">var</span> cc = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>,<span class="string">'dd'</span>,<span class="string">'ee'</span>);</span><br><span class="line">       <span class="keyword">var</span> dd = [<span class="string">'11'</span>,<span class="string">'22'</span>,<span class="string">'33'</span>,<span class="string">'44'</span>];</span><br><span class="line">       <span class="comment">//2.数组的遍历 for或者forEach</span></span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;dd.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(dd[i])</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//forEach更简单</span></span><br><span class="line">       cc.forEach(<span class="function"><span class="params">value</span>=&gt;</span>alert(value))</span><br></pre></td></tr></table></figure><p>【练习】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习：求斐波那契数列前20数字，并放入数组  1,1,2,3,5...</span></span><br><span class="line">    <span class="comment">//建议用for循环，forEach不太适用</span></span><br><span class="line">    <span class="keyword">var</span> num=[]</span><br><span class="line">    num[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    num[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">        num[i]=num[i<span class="number">-1</span>]+num[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br></pre></td></tr></table></figure><p>4.数组在中间插入元素比链表效率低<br>5.数组的增删方法：<br>首部：unshift,shift<br>末尾：push，pop<br>任意位置：splice<br>splice(3,5)//在索引3处删除5个元素，包含索引3<br>splice(3,0,’a’,’b’,’c’)//增<br>splice(3,5,’a’,’b’,’c’,’d’,’e’)//替换<br>【注】其中增，可以有参数，表增一个或多个；删没有参数<br>【下面均为单条语句执行】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">//1.增加元素，末尾push,首部unshift  1个或多个，有参数</span></span><br><span class="line">     num.push(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);<span class="comment">//[1,2,3,4,5,7,8,9]</span></span><br><span class="line">     num.unshift(<span class="number">-7</span>,<span class="number">0</span>);<span class="comment">//[-7，0，1,2,3,4,5]</span></span><br><span class="line">     <span class="comment">//2.删  末尾pop,首部shift  第一个，无参数</span></span><br><span class="line">     num.pop();<span class="comment">//[1,2,3,4]</span></span><br><span class="line">     num.shift();<span class="comment">//[2,3,4,5]</span></span><br><span class="line"> <span class="comment">//任意位置删除,增加更改 splice()</span></span><br><span class="line">  num.splice(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//[1,2,5]</span></span><br><span class="line">  num.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>);<span class="comment">//[1, 2, "aa", "bb", "cc", 3, 4, 5]</span></span><br><span class="line">    num.splice(<span class="number">2</span>,<span class="number">2</span>,<span class="string">'aa'</span>,<span class="string">'bb'</span>);<span class="comment">//[1, 2, "aa", "bb", 5]</span></span><br><span class="line">     <span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><p>【其他方法】<br>1)数组合并 nums1.concat(nums2) 等价于 nums1 + nums2<br>2)indexOf:    返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1<br>3)迭代方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代/遍历方法：every() some() forEach() filter()  map() </span></span><br><span class="line">       <span class="keyword">var</span> names =[<span class="string">'abc'</span>,<span class="string">'acd'</span>,<span class="string">'bcd'</span>,<span class="string">'ade'</span>];</span><br><span class="line">       <span class="comment">//1.every()每一个:利用every()判断数组元素中是否都包含a  &amp;</span></span><br><span class="line">       <span class="keyword">var</span> flag = names.every(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> value.indexOf(<span class="string">'a'</span>)!=<span class="number">-1</span></span><br><span class="line">       &#125;)<span class="comment">//flag=false</span></span><br><span class="line">       <span class="comment">//2.some():一旦有一次函数返回了true, 那么迭代就会结束. 并且结果为true  ||</span></span><br><span class="line">       <span class="keyword">var</span> flag1 =names.some(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> value.indexOf(<span class="string">'a'</span>)!= <span class="number">-1</span></span><br><span class="line">       &#125;) <span class="comment">//flag1=true</span></span><br><span class="line">       <span class="comment">//3.forEach()  快速迭代数组，无返回值</span></span><br><span class="line">       <span class="comment">//4.filter()  过滤，均满足，返回true并添加到新数组，false不添加  返回新数组</span></span><br><span class="line">       <span class="keyword">var</span> newNames = names.filter(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> value.indexOf(<span class="string">'a'</span>)!=<span class="number">-1</span></span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="comment">//5.map() 映射函数  变换生成新元素添加到新数组，返回新数组</span></span><br><span class="line">       <span class="keyword">var</span> mapNames =names.map(<span class="function"><span class="params">t</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> t+<span class="string">'111'</span></span><br><span class="line">       &#125;)</span><br><span class="line">       alert(mapNames)</span><br></pre></td></tr></table></figure><p>4）reduce()方法–函数式编程，有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【格式】arr.reduce(callback[, initialValue])</span><br><span class="line">【说明】callback指数组中每个元素均执行的回调函数，<span class="number">4</span>个可选参数为( previousValue--》上一次调用回调函数时的返回值，或者初始值</span><br><span class="line">currentValue--》当前正在处理的数组元素</span><br><span class="line">currentIndex--》当前正在处理的数组元素下标</span><br><span class="line">array--》调用reduce()方法的数组）</span><br><span class="line">而initialValue（可选的初始值。作为第一次调用回调函数时传给previousValue的值）</span><br><span class="line">】</span><br><span class="line">【举例，仅适用callback中的前两个参数】</span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">   <span class="keyword">var</span> total=numbers.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//   return pre+=cur;</span></span><br><span class="line">    <span class="comment">//上次执行结果保存在pre中,默认pre第一次执行时为0.</span></span><br><span class="line">    <span class="keyword">return</span> pre+cur;      </span><br><span class="line">   &#125;)</span><br><span class="line">   alert(total);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.jianshu.com/p/9521594710d7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;1.其他语言：存储同一类型数据；js可存储不同数据类型数据&lt;br&gt;2优势：节省变量个数，将其统一保存在一个数组内&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构</title>
    <link href="http://yoursite.com/2020/04/09/01%E6%95%B0%E7%BB%84%EF%BC%8C%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/04/09/01%E6%95%B0%E7%BB%84%EF%BC%8C%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97/</id>
    <published>2020-04-09T02:26:00.000Z</published>
    <updated>2020-04-09T12:09:30.174Z</updated>
    
    <content type="html"><![CDATA[<p>【写在前面】开启新的模块学习，梳理学过的算法与数据结构，掌握基本思想和逻辑，与编程语言无关<br>【目标】本周末前学完</p><a id="more"></a><p>【学习方法】语法-&gt;效果-&gt;逻辑<br>1.数据结构：<strong>存储和组织数据方式</strong>更高效(图书摆放，取快递)<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401" alt=""><br>【线性结构】数组，栈，队列，链表<br>哈希表，树结构，图结构，排序&amp;搜索</p><p>2.算法：<strong>解决问题的方法与操作(步骤)</strong>(找最佳路径)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【写在前面】开启新的模块学习，梳理学过的算法与数据结构，掌握基本思想和逻辑，与编程语言无关&lt;br&gt;【目标】本周末前学完&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>蘑菇街</title>
    <link href="http://yoursite.com/2020/04/08/%E8%98%91%E8%8F%87%E8%A1%97/"/>
    <id>http://yoursite.com/2020/04/08/%E8%98%91%E8%8F%87%E8%A1%97/</id>
    <published>2020-04-08T12:25:33.000Z</published>
    <updated>2020-04-09T12:08:57.866Z</updated>
    
    <content type="html"><![CDATA[<p>1.两种方式实现项目托管  本地-远程仓库<br>【方案一】git clone <a href="https://github.com/ximoxiyu/supermall.git" target="_blank" rel="noopener">https://github.com/ximoxiyu/supermall.git</a><br>复制，粘贴到当前文件夹<br>git add.<br>git commit -m ‘初始化项目’<br>git push<br>【方案二】<br>git remote add origin “地址”<br>git push -u origin master -f</p><h2 id="项目-蘑菇街"><a href="#项目-蘑菇街" class="headerlink" title="项目-蘑菇街"></a>项目-蘑菇街</h2><p> 1.划分目录结构<br> common：完全公共<br> content:当前项目相关</p><p> :root -&gt;获取根元素html<br> 定义变量<br> 2.引入两个css,标签统一<br> 3.vue.config.js 定义别名  .editorconfig.js 统一格式<br> 4.项目的模块划分：tabbar -&gt;路由映射关系<br> 5.加载src中时，不用空格</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.两种方式实现项目托管  本地-远程仓库&lt;br&gt;【方案一】git clone &lt;a href=&quot;https://github.com/ximoxiyu/supermall.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="http://yoursite.com/2020/04/07/vuex/"/>
    <id>http://yoursite.com/2020/04/07/vuex/</id>
    <published>2020-04-07T01:06:22.000Z</published>
    <updated>2020-04-07T08:17:17.230Z</updated>
    
    <content type="html"><![CDATA[<p>1.Vuex：状态管理模式(插件)，多个组件间共享状态的插件，且状态是响应式的<br>工具Devtools:在Chrome上调试时记录哪个变量修改<br>2.安装配置类比Vue-router</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//小写！</span><br><span class="line"> npm install vuex --save</span><br></pre></td></tr></table></figure><p>在src文件夹下新建store文件夹，建index.js，引入Vue与Vuex<br>注意大小写<br>【注】vuex-state是单一状态树，只推荐建一个对象store<br>3.对象的解构–ES6解构赋值，按名字赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line">   name:<span class="string">'why'</span>,</span><br><span class="line">   age:<span class="number">16</span>,</span><br><span class="line">   height:<span class="number">1.66</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name,age,height&#125;=obj;</span><br></pre></td></tr></table></figure><p>4.项目文件夹的目录组织：除state不抽，其他抽出,其他getters/mutations等均抽离成一个文件getters.js，并与index.js处于同一级目录下,抽离 <strong>export default{源代码}</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js中</span></span><br><span class="line"><span class="comment">//仅将state抽离，放在原文件下，</span></span><br><span class="line"><span class="comment">//使用时导入：import getters from './getters'</span></span><br><span class="line"><span class="keyword">const</span> state=&#123;</span><br><span class="line">    counter:<span class="number">1000</span>,</span><br><span class="line">    students:[</span><br><span class="line">       <span class="comment">//  注意对象的书写，是：而不是=</span></span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'aa'</span>,<span class="attr">age</span>:<span class="string">'10'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'bb'</span>,<span class="attr">age</span>:<span class="string">'15'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">'cc'</span>,<span class="attr">age</span>:<span class="string">'20'</span>&#125;,</span><br><span class="line">   ],</span><br><span class="line">   info:&#123;<span class="attr">id</span>:<span class="number">8</span>,<span class="attr">name</span>:<span class="string">'kk'</span>,<span class="attr">age</span>:<span class="string">'88'</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意对象的书写,注意大写！！！--单一数据源</span></span><br><span class="line"> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">     <span class="comment">//状态--单一数据源</span></span><br><span class="line">    state,</span><br><span class="line">    <span class="comment">//计算属性</span></span><br><span class="line">    getters,</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    mutations,</span><br><span class="line">     <span class="comment">//异步操作+Promise</span></span><br><span class="line">    actions,</span><br><span class="line">     <span class="comment">//划分模块--抽离模块</span></span><br><span class="line">    modules:&#123;</span><br><span class="line">      a:moduleA,</span><br><span class="line">&#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>5.五个核心概念：<br>1)state–类比data属性，存数据(状态)，供getters/mutations等使用;也可在APP.vue中直接使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2)getters–类比computed属性，即将数据进行一定处理再使用，本质为属性，可同state方法使用，但可以函数复用，可以有参数<br>但getters默认不可传参，传参数时：要求返回一个含参的函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$store.getters.moreAgeStu(18)&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在getters内部：里面也是函数，但用<span class="keyword">return</span></span><br><span class="line">  <span class="comment">//大于13岁的个数</span></span><br><span class="line">  <span class="comment">//1)函数的复用:复用之前的函数more13age,此时参数中多getters</span></span><br><span class="line">     more13ageLength(state,getters)&#123;</span><br><span class="line">         <span class="keyword">return</span> getters.more13age.length;</span><br><span class="line">     &#125;,</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//动态决定大于的岁数</span></span><br><span class="line"> <span class="comment">//2)计算属性中传参数，要求内部返回一个带参数的函数！</span></span><br><span class="line">     moreAgeStu(state)&#123;</span><br><span class="line">         <span class="comment">//返回函数</span></span><br><span class="line">         <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">             <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span>=&gt;</span>s.age&gt;age);</span><br><span class="line">             <span class="comment">//上句return 等价于</span></span><br><span class="line">             <span class="keyword">return</span> <span class="function"><span class="params">age</span>=&gt;</span>state.students.filter(<span class="function"><span class="params">s</span>=&gt;</span>s.age&gt;age);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>3)mutations–类比method属性：绑定事件;在App.vue中用commit来进行提交！同步，一般用devtool工具(浏览器插件)进行调试 响应式更新;<br>Vuex中store状态更新到唯一方式：提交mutation,含两部分：事件类型与回调函数(第一个参数为state)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;App.vue</span><br><span class="line"> &lt;button @click&#x3D;&quot;addNum(5)&quot;&gt;+5&lt;&#x2F;button&gt;</span><br><span class="line"> &#x2F;&#x2F;方法</span><br><span class="line">  addNum(num)&#123;</span><br><span class="line">      &#x2F;&#x2F;普通封装</span><br><span class="line">       this.$store.commit(&#39;inNum&#39;,num)</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;在mutations.js中</span><br><span class="line">   inNum(state,num)&#123;</span><br><span class="line">       state.counter +&#x3D; num</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>【拓展-提交风格：普通&amp;特殊-含type属性的对象，将整个commit的对象作payload使用】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊提交封装,可以</span></span><br><span class="line">     <span class="keyword">this</span>.$store.commit(&#123;</span><br><span class="line">         type: <span class="string">'inNum'</span>,</span><br><span class="line">         num</span><br><span class="line">           &#125;)</span><br><span class="line"> <span class="comment">//在mutations.js中 </span></span><br><span class="line"> <span class="comment">//特殊封装,特殊提交写成payload对象,小写！！</span></span><br><span class="line">   inNum(state,payload)&#123;</span><br><span class="line">       state.counter += payload.num</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>【响应规则：set与detele】<br>不用Vue时，改变的属性必须之前初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;响应式修改，之前没有的属性</span><br><span class="line">   upInfo(state)&#123;</span><br><span class="line">  &#x2F;&#x2F;第三个参数是字符串或数字</span><br><span class="line">  Vue.set(state.info,&#39;address&#39;,&#39;北京&#39;);</span><br><span class="line">  &#x2F;&#x2F;删除属性</span><br><span class="line">  Vue.delete(state.info,&#39;age&#39;)</span><br><span class="line">&#125;</span><br><span class="line">在App.vue中调用时同上</span><br></pre></td></tr></table></figure><p>4)Action -&gt;Mutation：异步操作(搭配Promise对象使用)<br>注：在定义函数时，第一个参数为context  –区别mutations的state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//context上下文，新定义异步操作的函数，payload为参数</span></span><br><span class="line">    aUpdataInfo(context,payload)&#123; </span><br><span class="line">    <span class="comment">//return Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//mutations中的函数</span></span><br><span class="line">           context.commit(<span class="string">'updateInfo'</span>);</span><br><span class="line">           <span class="built_in">console</span>.log(payload);</span><br><span class="line">           resolve(<span class="string">'resolve中的参数'</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">   &#125;) </span><br><span class="line">   </span><br><span class="line">   <span class="comment">//在App.vue中</span></span><br><span class="line">    <span class="comment">// Action的异步操作</span></span><br><span class="line">    actInfo()&#123;</span><br><span class="line">      <span class="comment">//异步，由commit改为dispatch</span></span><br><span class="line">       <span class="keyword">this</span>.$store.dispatch(<span class="string">'aUpdataInfo'</span>,<span class="string">'参数'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'里面完成了提交'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>【对比：同步mutations】参数为context,提交方式为dispatch，多返回Promise对象，有then</p><p>5)Module<br>  将store分割成模块(Module)，每个模块均有自身的state,mutations,getters,action<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;加入之前的状态：rootState</span><br><span class="line">    getName(state,getters,rootState)&#123;</span><br><span class="line">    return getters.fullname + rootState.counter;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><br>【小结】在其他组件.vue中，使用store对象中保存的状态</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1)this.$store.state.属性</span><br><span class="line">2)this.$store.getters.计算属性名</span><br><span class="line">2)this.$store.commit('mutations中的方法')//修改状态，绑定事件</span><br><span class="line">注：通过提交mutation来追踪状态变化，而非直接改变state</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.Vuex：状态管理模式(插件)，多个组件间共享状态的插件，且状态是响应式的&lt;br&gt;工具Devtools:在Chrome上调试时记录哪个变量修改&lt;br&gt;2.安装配置类比Vue-router&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从TabBar例子：抽离组件和复习vue-router</title>
    <link href="http://yoursite.com/2020/04/04/%E4%BB%8ETabBar%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%8A%BD%E7%A6%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%A4%8D%E4%B9%A0vue-router/"/>
    <id>http://yoursite.com/2020/04/04/%E4%BB%8ETabBar%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%8A%BD%E7%A6%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%A4%8D%E4%B9%A0vue-router/</id>
    <published>2020-04-04T15:00:46.000Z</published>
    <updated>2020-04-05T04:25:08.487Z</updated>
    
    <content type="html"><![CDATA[<p>【学习总结】<br>立了一堆flag，今天只完成了一个，自己太菜了，改了一天bug，为了省时间，一边看视频一边敲代码，减少自己bug的错误率;还好最终把结果做出来了，时间不够用，真心觉得时间不够用！以后的博客总结每日学习所得，不照本宣科，踏踏实实，多修改，多更正，不求一次做好，但要不断提炼自己的笔记。<br>今日早晨自己又独立写了一遍，果然上手才发现bug真不少。。<br>注意点：何时字符串，何时用变量;路径的大小写</p><a id="more"></a><p>【安装】<br>1)指定文件夹下：vue create “项目名”<br>2)安装vue-router: ** npm install vue-router –save **<br>3)配置路由：在src下新建router文件夹，创建index.js来配置路由信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.</span>导入Vue与VueRouter对象  <span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line">引入新建的子组件--懒加载(ES6的箭头函数)</span><br><span class="line"><span class="keyword">const</span> Home=<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'相对路径'</span>)</span><br><span class="line"><span class="number">1.</span>Vue.use(插件)安装插件</span><br><span class="line"><span class="number">2.</span>创建路由对象router，并且传入路由映射配置！</span><br><span class="line"><span class="keyword">const</span> router =<span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">   routes:[&#123;&#125;,&#123;&#125;];<span class="comment">//映射关系</span></span><br><span class="line">   mode:<span class="string">'history'</span><span class="comment">//拼接URL的格式</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="number">3.</span>输出router</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line">【补充】<span class="number">4.</span>在Vue实例main.js中挂载创建的路由对象router</span><br><span class="line">并在main.js中进行挂载：<span class="keyword">import</span>引入,实例中声明router</span><br></pre></td></tr></table></figure><p>4)【使用vue-router】创建路由组件，如Home.vue -&gt; 在index.js中懒加载，routes配置路由映射关系{path:,component} -&gt;在App.vue中使用<router-link>与<router-view><br>5)【组件抽离的思想】<br>1)整个页面：上–路由加载到的信息(子Vue),下–控制条;关系：点击控制条，路由到相应url,显示对应内容<br>2)上–<br>3)下–大组件：TabBar.vue内含四个小组件TabBarItem,每个小组件含两张图片(v-if v-else控制)和对应名字<br>【注】灵活更改使用slot组件，外包一层div，方便写控制，如v-if v-else和绑定属性等<br>【关键】子组件的click事件触发后更改router的地址，链接到不同的子组件如Home.vue等;且在App.vue中每个子组件标签处写上path地址<br>开发中：常用height:49px;<br>打包css样式安了插件<br><img src="/images/tabbar.png" alt="">】<br>【TabBar实现思路】<br>TabBar:定义插槽，flex布局平分<br>TabBarItem:定义两个插槽：图片，文字，外包div方便设置样式；<br>填充slot</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【学习总结】&lt;br&gt;立了一堆flag，今天只完成了一个，自己太菜了，改了一天bug，为了省时间，一边看视频一边敲代码，减少自己bug的错误率;还好最终把结果做出来了，时间不够用，真心觉得时间不够用！以后的博客总结每日学习所得，不照本宣科，踏踏实实，多修改，多更正，不求一次做好，但要不断提炼自己的笔记。&lt;br&gt;今日早晨自己又独立写了一遍，果然上手才发现bug真不少。。&lt;br&gt;注意点：何时字符串，何时用变量;路径的大小写&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vue-router</title>
    <link href="http://yoursite.com/2020/04/04/vue-router/"/>
    <id>http://yoursite.com/2020/04/04/vue-router/</id>
    <published>2020-04-04T01:18:39.000Z</published>
    <updated>2020-04-09T12:09:35.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习指南"><a href="#学习指南" class="headerlink" title="学习指南"></a>学习指南</h2><p>1.箭头函数()=&gt;{}:ES6定义函数的方式，常用于一个函数的往另一个函数中传参，箭头函数中的this向外层找;只有一行代码可省略return与{}<br>定义函数：本身function,对角字面量，ES6箭头函数<br>2.路由器：路由(路径)与传送(数据包转移)<br>内网192.168.1.110(可重复性，仅在当前网络中有效)<br>公网IP唯一性<br>发消息：公网IP-&gt;路由器(再次转发，映射表：内网IP与MAC地址的对应关系)<br>3.前端渲染与后端渲染<br>三个阶段<br>1）后端渲染(服务器渲染)-后端路由(jsp技术：java server page)，后端处理URL与页面的映射关系<br>2)前后端分离(前端渲染)-没有路由的概念(ajax请求数据)，后端(数据)，静态服务器(html+css+js),ajax发送网络请求，服务器回传数据，js操作浏览器渲染DOM<br>3)单页面富应用(SPA)(前端渲染)-前端路由(URL与页面的映射关系)+前后端分离，改变url，js判断，从资源中获取相应部分,页面不进行整体刷新，仅一个页面<br>4.【两种模式改URL】URL的hash(#)与HTML5中的history<br>【原】<a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8081</a><br>1)hash修改URL,页面未刷新，本质改location.href<br>控制台下：location.hash=’修改内容’—结果：<a href="http://localhost:8081/#修改内容" target="_blank" rel="noopener">http://localhost:8081/#修改内容</a><br>vue-router应用此机制，改变url地址，存在一份路由映射表，实现前端跳转而不刷新页面，ajax请求数据;<br>2)history对象模式，也不刷新页面，栈；后进先出，入栈：history.pushState()<br>出栈：history.back()<br>可以前进后退<br>同时：history.go(-1)=history.back()<br>history.go(1)=history.forward()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;&#125;,<span class="string">''</span>,<span class="string">'home'</span>)<span class="comment">//输出http://localhost:8081/home</span></span><br><span class="line"></span><br><span class="line">history.back()<span class="comment">//输出http://localhost:8081</span></span><br><span class="line"></span><br><span class="line">history.replaceState(&#123;&#125;,<span class="string">''</span>,<span class="string">'替换'</span>)<span class="comment">//http://localhost:8081/替换</span></span><br></pre></td></tr></table></figure><p>replaceState()只替换，无历史记录，无返回，后退受限</p><p>所有组件都继承自Vue类的原型</p><p>5.1)建立vue项目：在指定文件夹下 vue create 项目名 -&gt;cd 项目名 -&gt; npm run serve -&gt;修改URL的hash或HTML5中的history<br>2)配置vue-router插件模块，用Vue.user来安装路由功能;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure><ul><li>src下创router文件夹：存路由信息  ，建index.js</li><li>创建路由实例，在实例中挂载创建的路由实例对象</li></ul><p>3）快速生成vue模板：在vue文件下，输入vue回车<br>在components文件夹下创建路由组件Home.vue -》index.js配置路由映射(组件与路径映射)-》在APP.vue中使用路由</p><p>默认显示首页，再配置路由重定向<br>router-link默认渲染a标签，改为tag=”button” repalce状态repalceState<br>点击，字体颜色改变<br>【1.配置路由映射关系】配置组件，导入组件，配置映射关系，在APP内配置router-link<br>【2.动态路由】页面path不确定，在index.js的path改，在App.vue中绑定to属性，在data中定义路径；若要显示此路径，在User.vue中定义计算属性，获取 return this.$route.params.userId<br>【注】router是new的路由对象，内有routes(多个route),$route是此时活跃的路由<br>【3.路由懒加载–webpack的打包-步骤：npm run build,在dist-&gt;static-&gt;js中三类：app-业务你的代码，vendor-第三方(引用的vue/vue-router/axios/bs),manifest-底层支撑代码<br><strong>懒加载：用到时再加载</strong>，不同路由打包成不用js，几个组件几个懒加载,防止出现短暂空白–懒加载，将路由对应组件打包成一个个js块，路由访问时才加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入方式：三种，常用ES6的箭头函数</span></span><br><span class="line"><span class="comment">//index.js中书写懒加载</span></span><br><span class="line">&#123;</span><br><span class="line">        path:<span class="string">'/about'</span>,</span><br><span class="line">        component:<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'../components/About'</span>)<span class="comment">//箭头函数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用懒加载，js文件个数增加，从app.js中抽离出来<br>】</p><p><strong>路由使用时，用懒加载方式,一个路由一个js文件</strong><br>【路由嵌套】创建子组件，配置子路由，不用加/  ;父组件内部使用router-view<br>【路由参数】创建profile.vue–我的文件(档案);路由参数有两种：params对象与query–?<br>分析：URL<br>1)params类型：配置路由格式/router/:id<br>          传递方式：path后加对应值，形成路径：/router/123<br>2)query类型：/router ,传递格式：对象使用query的key为传递，形成路径：/router?id=123<br>【导航守卫】监听从哪往哪跳，改index.js中的title<br>常用生命周期的函数：created(),mounted(),updated()–界面刷新<br>方案一：在Home.vue中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'created Home'</span>);</span><br><span class="line">            <span class="built_in">document</span>.title=<span class="string">'首页'</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>【keep-alive保存组件状态】是Vue的内部组件<br>1.不写缺省值，在Home中在created()中写缺省</p><p>【琐碎知识】：vue-router是vue.js的路由插件<br>先渲染APP.vue</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习指南&quot;&gt;&lt;a href=&quot;#学习指南&quot; class=&quot;headerlink&quot; title=&quot;学习指南&quot;&gt;&lt;/a&gt;学习指南&lt;/h2&gt;&lt;p&gt;1.箭头函数()=&amp;gt;{}:ES6定义函数的方式，常用于一个函数的往另一个函数中传参，箭头函数中的this向外层找;只有
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>手撕promise</title>
    <link href="http://yoursite.com/2020/04/03/%E6%89%8B%E6%92%95promise/"/>
    <id>http://yoursite.com/2020/04/03/%E6%89%8B%E6%92%95promise/</id>
    <published>2020-04-03T09:28:00.000Z</published>
    <updated>2020-04-09T12:09:07.997Z</updated>
    
    <content type="html"><![CDATA[<p>【背景】解决ajax异步操作中的回调函数过多，将回调嵌套改为链式调用<br>1)观察者模式<br>then收集依赖–&gt;异步触发resolve–&gt;resolve执行依赖<br>在then方法的回调里取得异步操作的返回值<br>2)ES6中Promise/A规范控制Promise的状态<br>2.1)核心：Promise本质–状态机：Pending(等待),Fulfilled(执行中)，Rejected(拒绝态)<br>状态变更-单向:1-&gt;2,1-&gt;3<br>2.2)then方法：接收两个可选参数-状态改变时的回调;then方法可返回一个promise,可被同一个promise调用多次<br>3)【then的链式调用】<br>then()方法需返回一个Promise，这样才能返回then？then()的回调顺序执行<br>当前Promise状态变更后，再执行下一个then收集回调<br><strong>值穿透</strong>–then(参数必须为函数)<br><strong>处理状态为resolve/reject</strong>直接执行then回调</p><p>【查：instanceof 和try..catch】</p><p>【自学部分：promise】<br>1.背景：promise对异步操作进行封装<br>2.三种状态：<br>1).pending等待状态：正在执行网络请求或定时器未到时间<br>2).fulfill成功状态：主动回调resolve()时，并回调.then()<br>3).reject拒绝状态：主动回调reject()时，并回调.catch() 可省略<br>3.基本结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;setoutTime()&#125;).then().catch()</span><br></pre></td></tr></table></figure><p>4.链式调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    正确写法：不是一层套一层，是执行完之后继续链式执行</span></span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              resolve(<span class="string">'aaa'</span>);</span><br><span class="line">          &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//先初始调用，再拼接</span></span><br><span class="line">          <span class="built_in">console</span>.log(res, <span class="string">'第一层10行代码'</span>);</span><br><span class="line">          <span class="comment">//单纯在后面拼接，无需setTimeOut()再显示</span></span><br><span class="line">          <span class="comment">// return new Promise((resolve,reject) =&gt; &#123;</span></span><br><span class="line">          <span class="comment">//     // resolve(res + '111')</span></span><br><span class="line">          <span class="comment">//     reject(err);</span></span><br><span class="line">          <span class="comment">// &#125;)</span></span><br><span class="line">          <span class="comment">// 等价于 return Promise.reject(err);</span></span><br><span class="line">          <span class="comment">//再次简写：用throw抛出</span></span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//先初始调用，再拼接</span></span><br><span class="line">          <span class="built_in">console</span>.log(res, <span class="string">'第二层10行代码'</span>);</span><br><span class="line">         <span class="keyword">return</span> res+<span class="string">'222'</span>;</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(res, <span class="string">'第三层10行代码'</span>);</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'错误信息'</span>)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【背景】解决ajax异步操作中的回调函数过多，将回调嵌套改为链式调用&lt;br&gt;1)观察者模式&lt;br&gt;then收集依赖–&amp;gt;异步触发resolve–&amp;gt;resolve执行依赖&lt;br&gt;在then方法的回调里取得异步操作的返回值&lt;br&gt;2)ES6中Promise/A规范控制
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>常用HTML标签汇总</title>
    <link href="http://yoursite.com/2020/04/03/%E5%B8%B8%E7%94%A8HTML%E6%A0%87%E7%AD%BE%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2020/04/03/%E5%B8%B8%E7%94%A8HTML%E6%A0%87%E7%AD%BE%E6%B1%87%E6%80%BB/</id>
    <published>2020-04-03T08:57:00.000Z</published>
    <updated>2020-04-03T09:27:43.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="form标签中的input标签与label标签"><a href="#form标签中的input标签与label标签" class="headerlink" title="form标签中的input标签与label标签"></a>form标签中的input标签与label标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"male"</span>&gt;</span>Male<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">id</span>=<span class="string">"male"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1)form表单，可包含input元素，textarea元素，label元素，向服务器传数据，块元素<br>2)label标签为input元素定义标注，当用户选择此标签时，浏览器自动将焦点转到与此标签相关的表单控件;<br>3)label中的for=input中的id;即for将label绑定到另一个元素<br>4)input常用属性：type,value(input元素值),name(input元素名)<br>5)input标签，<a href="https://www.w3school.com.cn/tags/att_input_type.asp" target="_blank" rel="noopener">type规定input元素的类型</a><br>常见：button/checkbox/file/hidden/image/password/radio/<strong>reset(清除表单中所有数据)/submit(数据提交到服务器)/text(单行输入文本)</strong></p><h2 id="列表与列表项"><a href="#列表与列表项" class="headerlink" title="列表与列表项"></a>列表与列表项</h2><p> 1)列表ul/ol–li与定义列表dl-dt/dd描述<br> 2)列表项内部可以使用段落、换行符、图片、链接以及其他列表等等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;form标签中的input标签与label标签&quot;&gt;&lt;a href=&quot;#form标签中的input标签与label标签&quot; class=&quot;headerlink&quot; title=&quot;form标签中的input标签与label标签&quot;&gt;&lt;/a&gt;form标签中的input标签与l
      
    
    </summary>
    
    
    
      <category term="html " scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>http协议梳理</title>
    <link href="http://yoursite.com/2020/03/29/http%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/29/http%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/</id>
    <published>2020-03-29T07:31:21.000Z</published>
    <updated>2020-03-30T07:59:30.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《图解http协议》总结"><a href="#《图解http协议》总结" class="headerlink" title="《图解http协议》总结"></a>《图解http协议》总结</h2><p>1.HTTP：HyperText Transfer Protocol 超文本传输协议(规则)<br>HTTP协议前：FTP文本传输协议<br>2.WWW: World Wide Web 万维网，简称web<br>     3项WWW构建技术：SGML-标准通用标记语言<br>                HTTP协议<br>                URL-统一资源定位符<br>3.TCP/IP分层：应用层(FTP,DNS,HTTP协议)，传输层(TCP,UDP)，网络层(IP)，链路层(硬件)<br>4.TCP/IP 通信传输流(p19页图)<br>层与层传输数据时，加每层的首部信息<br>5.<strong>IP,TCP,DNS协议</strong><br>1)IP协议：传数据包，节点分配地址(可变);依赖MAC地址-网卡的固定地址;中转时IP通过ARP协议，解析地址反查对应的MAC地址<br>2)TCP协议：确定数据传到(可靠性)，BSS-字节流服务,数据以报文段(单位)分割;牢记三次握手：SYN–SYN/ACK–ACK<br><img src="/images/http%E5%8D%8F%E8%AE%AE/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"><br>3)DNS:域名解析，域名–IP地址，服务器接收IP地址，若是域名，则先经过DNS，将域名解析为IP地址<br>4)三者协议与HTTP协议关系(p24页图)<br>6.URI(标识符)&gt; URL(定位符),绝对URI,使用https:<br><img src="/images/http%E5%8D%8F%E8%AE%AE/%E7%BB%9D%E5%AF%B9URI.png" alt="绝对URI"></p><a id="more"></a><p>7.http协议:<br>1)不保存–Cookie技术,在报文中写入Cookie信息控制客户端(p46-47)<br>2)URI定位资源 –OPTIONS方法<br>3)持久连接-HTTP/0.9中需keep alive<br>4)管线化-并行发送，节省通信流量<br>8.请求方法<br>GET-请求资源，有返回<br>POST/PUT-传输资源，PUT指定位置<br>HEAD-获报文首部，类似GET，但只返首部信息<br>DELETE:删除指定位置资源<br>OPTIONS:询问支持方法<br>9.<a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener">Cookie变少，多用Token</a><br>10.HTTP报文：HTTP协议交互的信息，多行数据，字符串文本<br>请求报文：请求方法(GET,POST,PUT,HEAD),请求URI,协议版本(HTTP/1.1),可选–请求首部字段和内容实体(p32页)<br>响应报文：协议版本，状态码及解释短句(200 OK),可选-响应首部字段及实体内容(p33页)<br>11.报文结构：请求行/状态行,报文首部，报文主体<br>报文首部：请求/响应首部字段，通用首部字段，实体首部字段，其他(第6章重点)<br>首部字段：报文主体大小，语言，认证信息;结构–首部字段名：字段值(可多个)<br><img src="/images/http%E5%8D%8F%E8%AE%AE/%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.png" alt="通用首部字段"><br>请求首部字段<br><img src="/images/http%E5%8D%8F%E8%AE%AE/%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.png" alt="请求首部字段"><br><img src="/images/http%E5%8D%8F%E8%AE%AE/%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.png" alt="响应首部字段"><br><img src="/images/http%E5%8D%8F%E8%AE%AE/%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.png" alt="实体首部字段"></p><p>12.数据传输-编码提升传输效率，但耗CPU<br>1)不编码，报文内容=实体内容(变)<br>2)服务器内容编码：压缩–gzip/compress/deflate/identify<br>           分块–16进制，最后一块用’0’标记<br>3)可恢复机制–范围请求Range  206范围请求，返回指定范围<br>4)内容协商：服务器、客服端，透明(结合)协商<br>13.<strong>状态码(常考14种)：告知从服务器返回的请求结果(T/F)</strong><br>1xx–信息状态码<br>2xx–成功状态码，200正常返回   204成功，无资源返回<br>3xx–重定向,301永久 302暂时 303同302,但仅用GET 307同302，禁止POST变GET<br>4xx–客户端错误，401未授权 403禁止访问 404没找到资源<br>5xx–服务器错误，500执行错误 503超负荷<br>其中：304上次请求后页面未修改(特殊);加附加条件请求，服务器允许请求访问资源，但不满足条件；状态码返回时，无响应主体<br>14.服务器上的部署<br>1)相同IP，虚拟主机寄存多个不同主机名、域名<br>2)数据转发：代理，网关，隧道<br><strong>代理</strong>：转发不处理  代理服务器，写Via HTTP协议<br>分类基准：缓存？(缓存代理) 修改报文？(透明代理)<br><strong>网关</strong>：转发，处理请求  可使服务器提供非HTTP协议服务 安全性(加密)<br><strong>隧道</strong>：通信线路 安全通信<br>网关与隧道均为通信;<br>15.<a href="https://segmentfault.com/a/1190000022198770" target="_blank" rel="noopener">强缓存，协商缓存</a><br>强缓存-服务器，协商缓存-客户端<br>1.检查缓存是否过期（强缓存）<br>2.若缓存过期，与服务器协商是否更新缓存（协商缓存）</p><p>16.HTTP与HTTPS区别<br>1)HTTP缺点：不加密，内容被窃听;不验证身份，遭遇伪装;不证明报文完整性，遭篡改<br>2)通信加密，HTTP+SSL(安全套接层)=HTTPS,超文本传输安全协议<br>HTTP+加密+认证+完整性保护=HTTPS,是披SSL外壳的HTTP,不是新协议;<br>HTTPS采用混合加密机制：交换-公开密钥加密，交换报文-共享密钥加密<br>17.证明公开密钥正确性的证书（p150）<br>18.用户身份认证<br>1)核对信息：密码、动态令牌、数字证书、IC卡、生物认证<br>2)HTTP认证方式：BASIC、DIGEST、SSL客户端认证、FormBase认证(表单)–后端框架<br>Token认证<br>19.<a href="https://www.cnblogs.com/smallJunJun/p/11187796.html" target="_blank" rel="noopener">防范Web攻击</a><br>20.<a href="https://www.cnblogs.com/wupeixuan/p/8642100.html" target="_blank" rel="noopener">HTTP0.9-2.0版本区别</a><br>【后记】本篇基于《图解HTTP》与<a href="https://www.bilibili.com/video/bv1K7411Z7zu" target="_blank" rel="noopener">b站视频</a><br>学习过程：3小时刷书+2.5小时视频+2个小时总结为博客</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;《图解http协议》总结&quot;&gt;&lt;a href=&quot;#《图解http协议》总结&quot; class=&quot;headerlink&quot; title=&quot;《图解http协议》总结&quot;&gt;&lt;/a&gt;《图解http协议》总结&lt;/h2&gt;&lt;p&gt;1.HTTP：HyperText Transfer Protocol 超文本传输协议(规则)&lt;br&gt;HTTP协议前：FTP文本传输协议&lt;br&gt;2.WWW: World Wide Web 万维网，简称web&lt;br&gt;     3项WWW构建技术：SGML-标准通用标记语言&lt;br&gt;                HTTP协议&lt;br&gt;                URL-统一资源定位符&lt;br&gt;3.TCP/IP分层：应用层(FTP,DNS,HTTP协议)，传输层(TCP,UDP)，网络层(IP)，链路层(硬件)&lt;br&gt;4.TCP/IP 通信传输流(p19页图)&lt;br&gt;层与层传输数据时，加每层的首部信息&lt;br&gt;5.&lt;strong&gt;IP,TCP,DNS协议&lt;/strong&gt;&lt;br&gt;1)IP协议：传数据包，节点分配地址(可变);依赖MAC地址-网卡的固定地址;中转时IP通过ARP协议，解析地址反查对应的MAC地址&lt;br&gt;2)TCP协议：确定数据传到(可靠性)，BSS-字节流服务,数据以报文段(单位)分割;牢记三次握手：SYN–SYN/ACK–ACK&lt;br&gt;&lt;img src=&quot;/images/http%E5%8D%8F%E8%AE%AE/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&quot; alt=&quot;三次握手&quot;&gt;&lt;br&gt;3)DNS:域名解析，域名–IP地址，服务器接收IP地址，若是域名，则先经过DNS，将域名解析为IP地址&lt;br&gt;4)三者协议与HTTP协议关系(p24页图)&lt;br&gt;6.URI(标识符)&amp;gt; URL(定位符),绝对URI,使用https:&lt;br&gt;&lt;img src=&quot;/images/http%E5%8D%8F%E8%AE%AE/%E7%BB%9D%E5%AF%B9URI.png&quot; alt=&quot;绝对URI&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>js30系列04</title>
    <link href="http://yoursite.com/2020/03/28/js30%E7%B3%BB%E5%88%9704/"/>
    <id>http://yoursite.com/2020/03/28/js30%E7%B3%BB%E5%88%9704/</id>
    <published>2020-03-28T10:16:59.000Z</published>
    <updated>2020-04-02T09:27:55.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="15网页菜单"><a href="#15网页菜单" class="headerlink" title="15网页菜单"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/15%20-%20LocalStorage" target="_blank" rel="noopener">15网页菜单</a></h2><p>【目标】页面中添加新的菜品，而且在页面刷新之后也不清空<br>理解 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/LocalStorage" target="_blank" rel="noopener">localStorage</a> 的机制，利用 LocalStorage 把信息存到本地，从而可以保证刷新后内容不变。但使用 localStorage 的时候，直接把 items 传入得到的值是 [object Object]<br><a href="https://www.cnblogs.com/st-leslie/p/5617130.html" target="_blank" rel="noopener">localStorage学习</a><br>【关键点】1.localStorage理解为前端数据库：增删查改，setItem()/removeItem()/getItem()；字符串形式<br>2.主要配合JSON对象使用：JSON.stringify()//转字符串<br>JSON.parse()//字符串转JSON形式<br>3.HTML5的新特性，解决cookie内存不足(4k)，localStorage (5M)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 获取表单--添加部分</span><br><span class="line">  const addItems = document.querySelector(<span class="string">'.add-items'</span>);</span><br><span class="line">  // 获取列表--显示部分</span><br><span class="line">  const itemsList = document.querySelector(<span class="string">'.plates'</span>);</span><br><span class="line">  //定义空数组 const items = [];</span><br><span class="line">  //字符串转JSON格式</span><br><span class="line">  var items = JSON.parse(localStorage.getItem(<span class="string">'items'</span>)) || [];</span><br><span class="line">//事件的触发  提交-添加  点击-选中列表  最后：页面更新</span><br><span class="line">addItems.addEventListener(<span class="string">'submit'</span>,addItem);</span><br><span class="line">itemsList.addEventListener(<span class="string">'click'</span>,checkDone);</span><br><span class="line">changePage(items,itemsList);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//调用的具体函数</span><br><span class="line">//更新页面函数 changePage  显示ul</span><br><span class="line"><span class="keyword">function</span> changePage(plates=[],plateslist)&#123;</span><br><span class="line">  // 数组里的内容构造一组 &lt;li&gt; 组成的列表，并且加上一些标识信息，以助于之后需要实现的选中功能</span><br><span class="line">  plateslist.innerHTML = plates.map((plate,i)=&gt;&#123;</span><br><span class="line">    <span class="built_in">return</span> `</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span> =<span class="string">"checkbox"</span></span><br><span class="line">           data-index=<span class="variable">$&#123;i&#125;</span> id=<span class="string">"item<span class="variable">$&#123;i&#125;</span>"</span> </span><br><span class="line">           <span class="variable">$&#123;plate.checked1 ? 'checked' : ''&#125;</span> &gt;</span><br><span class="line">      &lt;label <span class="keyword">for</span>=<span class="string">"item<span class="variable">$&#123;i&#125;</span>"</span>&gt;<span class="variable">$&#123;plate.text&#125;</span>&lt;/label&gt;</span><br><span class="line">   &lt;/li&gt;</span><br><span class="line">    `;</span><br><span class="line">  &#125;).join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 添加函数addItem：获取当前input中的输入内容，将其存储在一个对象中，对象存入新数组</span><br><span class="line"><span class="keyword">function</span> addItem(e)&#123;</span><br><span class="line">  e.preventDefault();//阻止默认行为，闪动</span><br><span class="line">  // 获取输入框中的内容</span><br><span class="line">  const text =this.querySelector(<span class="string">'[name=item]'</span>).value;</span><br><span class="line">  //新建对象，存储输入框中的内容</span><br><span class="line">  const item =&#123;</span><br><span class="line">    text,//存储当前输入框中的内容</span><br><span class="line">    checked1:<span class="literal">false</span>,//是否勾选</span><br><span class="line">  &#125;</span><br><span class="line">  // 空数组中增加新元素</span><br><span class="line">  items.push(item);</span><br><span class="line">  // 表单元素重置为默认值--清空当前输入框</span><br><span class="line">  this.reset();</span><br><span class="line">  //页面刷新</span><br><span class="line">  changePage(items,itemsList);</span><br><span class="line">  //localStorage增加,等价于 localStorage.items = JSON.stringify(items)</span><br><span class="line">  localStorage.setItem(<span class="string">'items'</span>,JSON.stringify(items));</span><br><span class="line">  // 控制台打印当前输入内容，可删，同时第一句也可删</span><br><span class="line">console.log(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//选中函数 checkDone</span><br><span class="line"><span class="keyword">function</span> checkDone(e)&#123;</span><br><span class="line">  // 正则判断,要求为input</span><br><span class="line"><span class="keyword">if</span> (!e.target.matches(<span class="string">'input'</span>))</span><br><span class="line"><span class="built_in">return</span>;</span><br><span class="line">const el =e.target;</span><br><span class="line">const index =el.dataset.index;//读取data-index</span><br><span class="line">items[index].checked1 =!items[index].checked1;//取反</span><br><span class="line">changePage(items,itemsList);</span><br><span class="line">localStorage.setItem(<span class="string">'items'</span>,JSON.stringify(items));</span><br><span class="line">  // 控制台打印当前输入内容，可删，同时第一句也可删</span><br><span class="line">console.log(el.dataset.index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//附加功能，比如全选，全不选，删除</span><br><span class="line">const checkAllBtn = document.querySelector(<span class="string">'.check-all'</span>);</span><br><span class="line">const uncheckAllBtn = document.querySelector(<span class="string">'.uncheck-all'</span>);</span><br><span class="line">const deleteAllBtn = document.querySelector(<span class="string">'.delete-all'</span>);</span><br><span class="line"></span><br><span class="line">checkAllBtn.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  items.forEach(item=&gt;&#123;</span><br><span class="line">    item.checked1 = <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  changePage(items,itemsList);</span><br><span class="line">  localStorage.setItem(<span class="string">'items'</span>,JSON.stringify(items)); </span><br><span class="line">&#125;);</span><br><span class="line">uncheckAllBtn.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  items.forEach(item=&gt;&#123;</span><br><span class="line">    item.checked1 = <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  changePage(items,itemsList);</span><br><span class="line">  localStorage.setItem(<span class="string">'items'</span>,JSON.stringify(items)); </span><br><span class="line">&#125;);</span><br><span class="line">deleteAllBtn.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  items =[];</span><br><span class="line">  changePage(items,itemsList);</span><br><span class="line">  localStorage.setItem(<span class="string">'items'</span>,JSON.stringify(items)); </span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="17-数组标题去前缀"><a href="#17-数组标题去前缀" class="headerlink" title="[17.数组标题去前缀]"></a>[17.数组标题去前缀]</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">const bands = [<span class="string">'The Plot in You'</span>, <span class="string">'The Devil Wears Prada'</span>, <span class="string">'Pierce the Veil'</span>, <span class="string">'Norma Jean'</span>, <span class="string">'The Bled'</span>, <span class="string">'Say Anything'</span>, <span class="string">'The Midway State'</span>, <span class="string">'We Came as Romans'</span>,<span class="string">'Counterparts'</span>, <span class="string">'Oh, Sleeper'</span>, <span class="string">'A Skylit Drive'</span>, <span class="string">'Anywhere But Here'</span>, <span class="string">'An Old Dog'</span>];</span><br><span class="line">// 去除字符串中的The，A以及An的前缀后再进行排序,String.replace()函数,第一参数使用字面量正则表达式</span><br><span class="line">const delPrefix = item =&gt;item.replace(/^(The|A|An)\s&#123;1&#125;/,<span class="string">''</span>);</span><br><span class="line">  // Array.prototype.sort(*param*)方法虽然有返回值，但排序结果也影响原数组，Array.prototype.sort()函数只是返回了一个指向原数组的引用，而并没有生成新的数组。</span><br><span class="line">// 数组排序,排序后结果赋给新变量，</span><br><span class="line">const sortedbands = bands.sort((a,b)=&gt; delPrefix(a) &gt; delPrefix(b) ? 1 : -1);</span><br><span class="line">//获取ul列表,进行内容添加,展示到HTML页面</span><br><span class="line">document.querySelector(<span class="string">'#bands'</span>).innerHTML =<span class="string">'&lt;li&gt;'</span>+sortedbands.join(<span class="string">'&lt;/li&gt;&lt;li&gt;'</span>)+<span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">//测试Array.prototype.sort()的返回值，排序后的数组作为列表项插入其中。</span><br><span class="line">bands[0]=<span class="string">'I love javascript30!'</span>;</span><br><span class="line">console.log(sortedbands);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="19-照相"><a href="#19-照相" class="headerlink" title="19.照相"></a><a href="https://github.com/soyaine/JavaScript30/tree/master/19%20-%20Webcam%20Fun" target="_blank" rel="noopener">19.照相</a></h2><p>1.通过编写javascript代码，请求调用用户的网络摄像头;<br>2.在页面上展示来自webcam的数据流信息;<br>3.并允许用户保存展示的照片;<br>4.及使用滑块来改变图像的色彩。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">  canvas = document.querySelector(<span class="string">'canvas'</span>);</span><br><span class="line">    video = document.querySelector(<span class="string">'video'</span>);</span><br><span class="line">    ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    img = document.querySelector(<span class="string">'#myimg'</span>);</span><br><span class="line">    slider = document.querySelector(<span class="string">'.rgb'</span>);</span><br><span class="line">    a = document.querySelector(<span class="string">'a'</span>);</span><br><span class="line">    //滤色范围记录</span><br><span class="line">    filter = &#123;</span><br><span class="line">        rmin: 0,</span><br><span class="line">        rmax: 255,</span><br><span class="line">        gmin: 0,</span><br><span class="line">        gmax: 255,</span><br><span class="line">        bmin: 0,</span><br><span class="line">        bmax: 255</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //调用摄像头数据</span><br><span class="line">            askWebcam();</span><br><span class="line"></span><br><span class="line">    //绑定change事件动态修改图片颜色</span><br><span class="line">    slider.onchange = <span class="keyword">function</span>(e) &#123;</span><br><span class="line">        //先将canvas恢复至原始截图</span><br><span class="line">        ctx.putImageData(origindata, 0, 0);</span><br><span class="line">        const target = e.target;</span><br><span class="line">        //startPos表示操作像素点数据时的起点，从canvas获取到的像素数据每四个值表示一个像素点</span><br><span class="line">        //例如滑块为红色，则只需要改变像素数组中第0,4,8......个元素的值。</span><br><span class="line">        const startPos = &#123;</span><br><span class="line">            <span class="string">'r'</span>: 0,</span><br><span class="line">            <span class="string">'g'</span>: 1,</span><br><span class="line">            <span class="string">'b'</span>: 2</span><br><span class="line">        &#125;[target.name[0]];</span><br><span class="line">        //filterMin和filterMax表示相应的滤色范围上下限，若修改了红色滤色范围则取红色范围值。</span><br><span class="line">        //若修改蓝色的滤色范围，则取蓝色。</span><br><span class="line">        var tempFilter = checkFilter(target.name, target.value);</span><br><span class="line">        const filterMin = tempFilter.min;</span><br><span class="line">        const filterMax = tempFilter.max;</span><br><span class="line">        //从canvas获取像素数据</span><br><span class="line">        var img = ctx.getImageData(0, 0, 300, 200);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        var imgd = img.data;</span><br><span class="line">        //色彩过滤</span><br><span class="line">        <span class="keyword">for</span> (var i = startPos, len = imgd.length; i &lt; len; i += 4) &#123;</span><br><span class="line">            <span class="keyword">if</span> (imgd[i] &lt; filterMin) &#123;</span><br><span class="line">                imgd[i] = filterMin;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imgd[i] &gt; filterMax) &#123;</span><br><span class="line">                imgd[i] = filterMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将修改后的像素数据重绘制至canvas</span><br><span class="line">        ctx.putImageData(img, 0, 0);</span><br><span class="line">        img.src = canvas.toDataURL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//点击函数</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">takePhoto</span></span>() &#123;</span><br><span class="line">    ctx.drawImage(video, 0, 0, 300, 200);</span><br><span class="line">    //将原始截图保存</span><br><span class="line">    origindata = ctx.getImageData(0, 0, 300, 200);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//保存图片</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">savePhoto</span></span>() &#123;</span><br><span class="line">    img.src = canvas.toDataURL();</span><br><span class="line">    a.href = canvas.toDataURL();</span><br><span class="line">    a.setAttribute(<span class="string">'download'</span>, <span class="string">'handsome'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//申请网络摄像头操作权限</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">askWebcam</span></span>() &#123;</span><br><span class="line">    navigator.getUserMedia = navigator.getUserMedia ||</span><br><span class="line">        navigator.webkitGetUserMedia ||</span><br><span class="line">        navigator.mozGetUserMedia;</span><br><span class="line">    <span class="keyword">if</span> (navigator.getUserMedia) &#123;</span><br><span class="line">        navigator.getUserMedia(&#123;</span><br><span class="line">            audio: <span class="literal">false</span>,</span><br><span class="line">            video: &#123;</span><br><span class="line">                width: 300,</span><br><span class="line">                height: 200</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">function</span>(stream) &#123;</span><br><span class="line">            //若成功</span><br><span class="line">            video.srcObject = stream;</span><br><span class="line">            video.onloadedmetadata = <span class="keyword">function</span>(e) &#123;</span><br><span class="line">                video.play();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">function</span>(err) &#123;</span><br><span class="line">            console.log(<span class="string">'Error occured:'</span> + err.name);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        console.log(<span class="string">'this navigator doesn\'</span>t support webcam!<span class="string">');</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//滤色函数</span></span><br><span class="line"><span class="string">function checkFilter(name, value) &#123;</span></span><br><span class="line"><span class="string">    var _min;</span></span><br><span class="line"><span class="string">    var _max;</span></span><br><span class="line"><span class="string">    var _antiname = &#123;</span></span><br><span class="line"><span class="string">        '</span>rmin<span class="string">': '</span>rmax<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>rmax<span class="string">': '</span>rmin<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>gmin<span class="string">': '</span>gmax<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>gmax<span class="string">': '</span>gmin<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>bmin<span class="string">': '</span>bmax<span class="string">',</span></span><br><span class="line"><span class="string">        '</span>bmax<span class="string">': '</span>bmin<span class="string">'</span></span><br><span class="line"><span class="string">    &#125;[name]</span></span><br><span class="line"><span class="string">    filter[name] = value;</span></span><br><span class="line"><span class="string">    //当下限值超过上限时，将两者对调</span></span><br><span class="line"><span class="string">    _min = Math.min(filter[name], filter[_antiname]);</span></span><br><span class="line"><span class="string">    _max = Math.max(filter[name], filter[_antiname]);</span></span><br><span class="line"><span class="string">    console.log(filter);</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">        min: _min,</span></span><br><span class="line"><span class="string">        max: _max</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>20.语音接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;</span><br><span class="line">  var words = document.getElementById(<span class="string">'words'</span>);</span><br><span class="line"></span><br><span class="line">  //新建一个语音识别对象</span><br><span class="line">  var speech = new webkitSpeechRecognition();</span><br><span class="line">  speech.interimResults = <span class="literal">true</span>;</span><br><span class="line">  speech.lang = <span class="string">'en-US'</span>;</span><br><span class="line">  speech.start();</span><br><span class="line"></span><br><span class="line">//有结果返回时</span><br><span class="line">  speech.addEventListener(<span class="string">'result'</span>, (e) =&gt; &#123;</span><br><span class="line">      const results = Array.from(e.results) </span><br><span class="line">      // e.results中保存的是识别的结果，本来并不是数组，需要将其转换为数组，方便使用其map、join等方法。</span><br><span class="line">        .map(result =&gt; result[0])</span><br><span class="line">        .map(result =&gt; result.transcript) // 获取到每一段话，是一个数组类型</span><br><span class="line">        .join(<span class="string">''</span>); // 将每一段话连接成字符串</span><br><span class="line">       //将结果输出在页面上</span><br><span class="line">        words.innerHTML = results;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//开始捕获到音频时</span><br><span class="line">speech.onaudiostart = <span class="keyword">function</span>(e) &#123;</span><br><span class="line">  console.log(<span class="string">'start'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//出现错误时</span><br><span class="line">speech.onerror = <span class="keyword">function</span>(e) &#123;</span><br><span class="line">  console.log(e.error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//语音识别结束时重新开始捕获语音</span><br><span class="line"> speech.onend = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">     speech.start();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;15网页菜单&quot;&gt;&lt;a href=&quot;#15网页菜单&quot; class=&quot;headerlink&quot; title=&quot;15网页菜单&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/ximoxiyu/JavaScript30/tree/master/15%20-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>js30系列03</title>
    <link href="http://yoursite.com/2020/03/27/js30%E7%B3%BB%E5%88%9703/"/>
    <id>http://yoursite.com/2020/03/27/js30%E7%B3%BB%E5%88%9703/</id>
    <published>2020-03-27T14:48:00.000Z</published>
    <updated>2020-03-30T04:14:39.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="09-Console-调试技巧"><a href="#09-Console-调试技巧" class="headerlink" title="09 Console 调试技巧"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master" target="_blank" rel="noopener">09 Console 调试技巧</a></h2><p>仅html+js<br>[console对象与控制台学习]（<a href="https://wangdoc.com/javascript/features/console.html）" target="_blank" rel="noopener">https://wangdoc.com/javascript/features/console.html）</a></p><ul><li>console对象是js的原生对象<br>console用途：调试程序，提供命令行接口;F12<br>console面板：命令行窗口</li><li>console对象的静态方法，可覆盖</li></ul><p>1.console.log()输出普通信息<br>%c：css格式字符串–%c后面的内容<br>%d：打印整数<br>%s：打印字符串<br>%f：打印浮点数<br>%o：打印javascript对象，可以是整数，字符串，JSON对象<br>2.console.info()输出提示信息<br>3.console.error()输出错误信息<br>4.console.warn()输出警示信息<br>5.console.debug()输出调试信息<br>6.console.table()数据打印成表格<br>7.console.assert() 条件判断，2个参数;在第一个参数为 false 的情况下会在控制台输出信息。<br>8.console.dir()检查，可以显示一个对象的所有属性和方法<br>9.console.count()打印标识及调用次数，可接收字符串为参数，对执行次数进行分类<br>10.console.group()数组设置分组信息<br>  console.groupEnd()结束当前的分组。 console.groupCollapsed()隐藏分组信息<br>11.console.time()测试程序执行的时长<br>  console.timeEnd()计时结束,执行时长显示在控制台。<br>12.console.clear()清除控台台之前的信息;若选中控制台的“Preserve log”选项，console.clear方法将不起作用。</p><a id="more"></a>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">     // Regular常规输出</span><br><span class="line">console.log(<span class="string">"我只是常规输出"</span>);</span><br><span class="line">    // Interpolated字符替换</span><br><span class="line">console.log(<span class="string">"我的名字为%s"</span>,<span class="string">"log"</span>);</span><br><span class="line">console.log(<span class="string">"我的年龄为 %f"</span>,22);</span><br><span class="line">    // Styled设定输出样式</span><br><span class="line">    // %c打印内容定义格式</span><br><span class="line">console.log(<span class="string">"偷偷告诉你，我会变身 %c ~\(≧▽≦)/~巴拉拉~~"</span>, <span class="string">"color: #00fdff; font-size: 2em;"</span>)</span><br><span class="line">    // warning!</span><br><span class="line">console.warn(<span class="string">"我是warnning"</span>);</span><br><span class="line">    // Error :|</span><br><span class="line">console.error(<span class="string">"我是报错error"</span>);</span><br><span class="line">    // Info输出提示信息</span><br><span class="line">console.info(<span class="string">"我是输出提示信息"</span>);</span><br><span class="line">  // Viewing DOM Elements打印输出DOM元素</span><br><span class="line">  const p =document.querySelector(<span class="string">'p'</span>);</span><br><span class="line">    console.log(p);</span><br><span class="line">    // Testing测试</span><br><span class="line">    console.assert(1===1,<span class="string">"这句话发布时删除"</span>);</span><br><span class="line">    console.assert(0===1,<span class="string">"console.assert()第一个参数为false时输出信息"</span>);</span><br><span class="line">    console.assert(p.innerHTML.match(<span class="string">"小红"</span>),<span class="string">"我这没有小红"</span>);</span><br><span class="line">    // clearing清除之前控制台上所有信息</span><br><span class="line">    //  console.clear();</span><br><span class="line">    // console.dir()可以显示一个对象的所有属性和方法</span><br><span class="line">    console.dir(p);</span><br><span class="line">    // Grouping together</span><br><span class="line">    // console.group();数组设置分组信息</span><br><span class="line">    // 使用 console.groupEnd() 方法来结束当前的分组。</span><br><span class="line">    // 使用 console.groupCollapsed() 方法来隐藏分组信息</span><br><span class="line">    dogs.forEach(dog=&gt;&#123;</span><br><span class="line">        console.group();</span><br><span class="line">        console.log(dog.name);</span><br><span class="line">        console.log(dog.age);</span><br><span class="line">        console.log(dog.name+<span class="string">'有'</span>+dog.age +<span class="string">'岁了'</span>);</span><br><span class="line">        // console.groupEnd();</span><br><span class="line">    &#125;);</span><br><span class="line">    // 数据打印成表格</span><br><span class="line">    console.table(dogs);</span><br><span class="line">    console.table(dogs,[<span class="string">"age"</span>]);</span><br><span class="line">    // counting</span><br><span class="line">    // Console.count()打印标识及次数</span><br><span class="line">    console.count(<span class="string">"（读来过反）羊只"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）羊只"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）鱼条"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）羊只"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）羊只"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）鱼条"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）鱼条"</span>);</span><br><span class="line">    console.count(<span class="string">"（读来过反）羊只"</span>);</span><br><span class="line">    // timing测试程序执行的时长</span><br><span class="line">console.time(<span class="string">'fetch my data'</span>);</span><br><span class="line">fetch(<span class="string">'https://api.github.com/users/wesbos'</span>)</span><br><span class="line">   .<span class="keyword">then</span>(data =&gt; data.json())</span><br><span class="line">   .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">       console.timeEnd(<span class="string">'fetch my data'</span>);</span><br><span class="line">   console.log(data)&#125;</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p>  <img src="/images/js30/9.png" alt="效果"><br>  【补充】控制台命令行API<br>  1)$(selector)返回第一个匹配的元素，等同于document.querySelector()<br>  2)$$(selector)返回选中的 DOM 对象，等同于document.querySelectorAll。<br>  3)dir(object)：显示特定对象的所有属性，是console.dir方法的别名。<br>  2.debugger 语句,除错，设置断点</p><hr><h2 id="10-JS-实现-Checkbox-中按住-Shift-的多选功能"><a href="#10-JS-实现-Checkbox-中按住-Shift-的多选功能" class="headerlink" title="10 JS 实现 Checkbox 中按住 Shift 的多选功能"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/10%20-%20Hold%20Shift%20and%20Check%20Checkboxes" target="_blank" rel="noopener">10 JS 实现 Checkbox 中按住 Shift 的多选功能</a></h2><p>  【html】checkbox 类型的 input 元素<br>  【目标】选中某个复选框时，其 <p> 标签中的文字会显示删除线。按下Shift执行多选  按下shift,A-B之间全选<br>  【核心】 选中checkbox(点击事件)–触发数组范围，判断当前状态及是否按下shift的键，进行相应范围选中，改变对应样式<br>  1.截取数组元素slice(m,n)  –结果:数组索引【m,n)<br>  2.Math.min(a,b) 返回a，b的最小值<br>  【js】获取 A 和 B，利用 indexOf() 来获得 A 和 B 在数组中的索引值，由此即可确定范围，并能通过 slice() 来直接截取 A-B 的所有 DOM 元素，并进行状态改变的操作，而变量 onOff 表示 A-B 范围内的状态，true 表示选中，false 表示取消选中<br>   <img src="/images/js30/10.png" alt="效果"></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  &lt;script&gt;</span><br><span class="line">    // 1.获取input</span><br><span class="line">    const boxs = document.querySelectorAll(<span class="string">'input'</span>);</span><br><span class="line">    // 转换 Nodelist 为数组</span><br><span class="line">    const boxArr=Array.from(boxs);</span><br><span class="line">    // 上次选中的变量</span><br><span class="line">    <span class="built_in">let</span> A;</span><br><span class="line">    //2.点击事件-触发函数：利用数组索引获取需要选中的范围</span><br><span class="line">     boxs.forEach(box =&gt;box.onclick=<span class="keyword">function</span>(e)&#123;</span><br><span class="line">        // A 是上一次操作选中的对象，B 是此次操作对象</span><br><span class="line">        <span class="keyword">if</span>(!A)</span><br><span class="line">        A =this;</span><br><span class="line">        // onOff 表示 A-B 范围内的状态</span><br><span class="line">        onOff = A.checked ? <span class="literal">true</span> :<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(e.shiftKey)&#123;</span><br><span class="line">            //针对按下了 Shift 键的情况，利用indexOf()获取 A-B 索引值</span><br><span class="line">            <span class="built_in">let</span> start =boxArr.indexOf(A);</span><br><span class="line">            <span class="built_in">let</span> end = boxArr.indexOf(this);</span><br><span class="line">           </span><br><span class="line">            // slice(A,B)截取 A-B 的数组元素，并用forEach遍历改变选中状态</span><br><span class="line">            boxArr.slice(Math.min(start,end),Math.max(start,end)+1).forEach(input =&gt; input.checked = onOff);</span><br><span class="line"></span><br><span class="line">            console.log(start + <span class="string">'---'</span> + end);</span><br><span class="line">        &#125;</span><br><span class="line">       A=this;</span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="12-暗号-特效-16鼠标移动"><a href="#12-暗号-特效-16鼠标移动" class="headerlink" title="[12 暗号-特效+16鼠标移动]"></a>[12 暗号-特效+16鼠标移动]</h2><p>【目标】网页输入暗号，生成特效<br>html+js，仅js<br>  KeyUp事件是键盘上的某个键按下后再松开时触发; Change事件是控件的内容发生改变时触发。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  &lt;script&gt;</span><br><span class="line">        //核心：监听并获取输入的字符,处理输入，在符合条件时，调用 cornify</span><br><span class="line"> // 1.声明一个空数组，存放字符串，并声明暗号</span><br><span class="line">        const pressed = [];</span><br><span class="line">        const secretCode = <span class="string">'hello'</span>;</span><br><span class="line">        // 触发keyup事件, keyup 事件是针对页面的，所以在调试时单击页面后时焦点在页面中才生效，在 Console 面板中是不会触发的。</span><br><span class="line">        window.onkeyup = <span class="keyword">function</span> (e) &#123;</span><br><span class="line">            //验证输入字符</span><br><span class="line">            console.log(e.key);</span><br><span class="line">//2.将每一个输入的字符存入 pressed 数组，然后处理数组，使其呈现队列的性质，也就是输入一个字符时，会挤出原有的的字符，保证其最大长度始终为 secretCode 的长度</span><br><span class="line">            //数组内增加元素,获取输入字符</span><br><span class="line">            pressed.push(e.key);</span><br><span class="line">            // 截取数组</span><br><span class="line">            pressed.splice(-secretCode.length - 1, pressed.length - secretCode.length);</span><br><span class="line">            </span><br><span class="line">// 3.判断是否有暗号</span><br><span class="line">//Array.join()将array数据中每个元素都转为字符串，用自定义的连接符分割</span><br><span class="line">            <span class="keyword">if</span> (pressed.join(<span class="string">''</span>).includes(secretCode)) &#123;</span><br><span class="line">                console.log(<span class="string">'暗号成功'</span>);</span><br><span class="line">          //调用cornify_add() 方法时，会在页面中追加 p 标签，并在 DOM 中插入一个图标</span><br><span class="line">                cornify_add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><br>  <img src="/images/js30/12.png" alt="效果"></p><h3 id="16-鼠标移动"><a href="#16-鼠标移动" class="headerlink" title="16.鼠标移动"></a>16.鼠标移动</h3><p><img src="/images/js30/16.png" alt="理论"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//文字阴影text-shadow: h-shadow v-shadow blur color</span><br><span class="line">text-shadow: 10px 10px 0 rgba(0,0,0,1);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     const hero = document.querySelector(<span class="string">'.hero'</span>);</span><br><span class="line">  const text = hero.querySelector(<span class="string">'h1'</span>);</span><br><span class="line">  //定义：当鼠标移动至显示区域边界时，阴影距离占hero元素宽和高的比例</span><br><span class="line">//   标记阴影距离h1中心的距离和鼠标距离h1中心距离的比例，用于计算阴影的具体位置</span><br><span class="line">  const factor = 0.4;</span><br><span class="line">  //触发鼠标移动mousemove事件</span><br><span class="line">  hero.onmousemove =<span class="keyword">function</span>(e)&#123;</span><br><span class="line">       //解构赋值</span><br><span class="line">    //    从事件发生的event对象中获取需要的值,简写了</span><br><span class="line">    const &#123; offsetWidth: width, offsetHeight: height &#125; = hero;</span><br><span class="line">    <span class="built_in">let</span> &#123; offsetX: x, offsetY: y &#125; = e;</span><br><span class="line">     //将鼠标位置转换为相对视口左上角的坐标，本例中由于hero元素占满视口故未起实际作用</span><br><span class="line">     <span class="keyword">if</span> (this !== e.target) &#123;</span><br><span class="line">      x = x + e.target.offsetLeft;</span><br><span class="line">      y = y + e.target.offsetTop;</span><br><span class="line">    &#125;</span><br><span class="line">    //阴影瞬时位置：鼠标位置距离h1中心的距离乘以factor</span><br><span class="line">    // x表示鼠标当前位置的坐标,width与height指代hero元素的宽和高：</span><br><span class="line">    const xWalk = parseInt((x-width/2)*factor);</span><br><span class="line">    const yWalk = parseInt((y-height/2)*factor);</span><br><span class="line">    //使用模板字符串赋值</span><br><span class="line">    // 绕h1元素中心旋转90°的方式共生成4个阴影</span><br><span class="line">    text.style.textShadow = `</span><br><span class="line">      <span class="variable">$&#123;xWalk&#125;</span>px <span class="variable">$&#123;yWalk&#125;</span>px 0 rgba(255,0,255,0.7),</span><br><span class="line">      <span class="variable">$&#123;xWalk * -1&#125;</span>px <span class="variable">$&#123;yWalk&#125;</span>px 0 rgba(0,255,255,0.7),</span><br><span class="line">      <span class="variable">$&#123;yWalk&#125;</span>px <span class="variable">$&#123;xWalk * -1&#125;</span>px 0 rgba(0,255,0,0.7),</span><br><span class="line">      <span class="variable">$&#123;yWalk * -1&#125;</span>px <span class="variable">$&#123;xWalk&#125;</span>px 0 rgba(0,0,255,0.7)</span><br><span class="line">    `;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="13-图片随屏幕滚动"><a href="#13-图片随屏幕滚动" class="headerlink" title="13.图片随屏幕滚动"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/13%20-%20Slide%20in%20on%20Scroll" target="_blank" rel="noopener">13.图片随屏幕滚动</a></h2><p>页面中的文章有几张配图，随着页面上下滚动，图片位置划过图片一半时，图片从两侧滑入；图片位置离开可见区域时，图片向两侧滑出。<br><img src="/images/js30/13.png" alt="理论"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        //debounce 函数来降低触发的次数。</span><br><span class="line">        <span class="keyword">function</span> debounce(func, <span class="built_in">wait</span> = 20, immediate = <span class="literal">true</span>) &#123;</span><br><span class="line">            var timeout;</span><br><span class="line">            <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                var context = this, args = arguments;</span><br><span class="line">                var later = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                    timeout = null;</span><br><span class="line">                    <span class="keyword">if</span> (!immediate) func.apply(context, args);</span><br><span class="line">                &#125;;</span><br><span class="line">                var callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = setTimeout(later, <span class="built_in">wait</span>);</span><br><span class="line">                <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 1.获取页面中的所有图片元素</span><br><span class="line">        const imgs = document.querySelectorAll(<span class="string">'.slide-in'</span>);</span><br><span class="line"></span><br><span class="line">        //2.滚动事件监听</span><br><span class="line">        //定义处理函数：检查滑动条</span><br><span class="line">        <span class="keyword">function</span> checkSlide(e) &#123;</span><br><span class="line">            imgs.forEach(img =&gt; &#123;</span><br><span class="line">                // 滑动页面的底部距离扣除图片一半的高</span><br><span class="line">                const slideInAt = (window.scrollY + window.innerHeight) - img.height / 2;</span><br><span class="line">                //图片的底部距离顶端距离</span><br><span class="line">                const imgBottom = img.offsetTop + img.height;</span><br><span class="line">                //  两个临界点：判图片是否在需显示的区域</span><br><span class="line">                // 已滑过了图片的一半</span><br><span class="line">                const isHalfShow = slideInAt &gt; img.offsetTop;</span><br><span class="line">                //未完全滑过图片</span><br><span class="line">                const isNotScrollPast = window.scrollY &lt; imgBottom;</span><br><span class="line">                <span class="keyword">if</span> (isHalfShow &amp;&amp; isNotScrollPast) &#123;</span><br><span class="line">                    img.classList.add(<span class="string">'active'</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    img.classList.remove(<span class="string">'active'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        //事件触发</span><br><span class="line">        window.addEventListener(<span class="string">'scroll'</span>, debounce(checkSlide));</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="14-JS的引用与复制"><a href="#14-JS的引用与复制" class="headerlink" title="14.JS的引用与复制"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/14%20-%20JavaScript%20References%20VS%20Copying" target="_blank" rel="noopener">14.JS的引用与复制</a></h2><p> 【注】直接运行页面后打开 Console，边编辑代码，边查看结果。<br> 1.Array类型与普通类型(Boolean Number String)不同，是引用不是复制，两个变量均指同一个数组，改任意一个均变<br> 2.解决：Array.prototype.slice()//数组浅拷贝，不改原数组<br>  Array.prototype.concat() //合并数组，不改<br>  const team4 = […players]//ES6 扩展语法<br>  Array.from()//创建新数组实例<br> 3.Object类型–引用，会改<br>   Object.assign(target, …sources) 时，后来的源对象的属性值，将会覆盖它之前的对象的属性。<br>   利用 JSON 可以先将对象转成字符串的格式，然后再把它转成 JSON，从而实现复制【不太理解】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 1.普通类型：String、Number、Boolean ：仅复制不引用，不改变</span><br><span class="line">    <span class="built_in">let</span> age = 100;</span><br><span class="line">    <span class="built_in">let</span> age2 = age;</span><br><span class="line">    console.log(<span class="string">'原变量'</span>+age,<span class="string">'复制后'</span>+age2);</span><br><span class="line">    // 改变一个值</span><br><span class="line">    age = 200;</span><br><span class="line">    console.log(<span class="string">'原变量'</span>+age,<span class="string">'更改后'</span>+age2);</span><br><span class="line"></span><br><span class="line">    // 2.数组Array类型：引用，均改</span><br><span class="line">    const players = [<span class="string">'Wes'</span>, <span class="string">'Sarah'</span>, <span class="string">'Ryan'</span>, <span class="string">'Poppy'</span>];</span><br><span class="line"></span><br><span class="line">    // 直接复制不可，因为 team 只是这个数组的引用，并不是它的复制。team 和 players 指向的是同一个数组。</span><br><span class="line"></span><br><span class="line">    //4种复制方法</span><br><span class="line">    //1)浅拷贝，运行 slice 得到的结果是一个对原数组的浅拷贝，原数组不会被修改</span><br><span class="line">    const team1 =players.slice();</span><br><span class="line">    team1[3] =<span class="string">'11'</span>;</span><br><span class="line">    console.log(<span class="string">'原'</span>+players[3],<span class="string">'浅拷贝'</span>+ team1[3]);</span><br><span class="line">    // 2)创建一个新数组，然后用 concat 方法来获取它</span><br><span class="line">    const team2 =[].concat(players);</span><br><span class="line">    team2[3] =<span class="string">'22'</span>;</span><br><span class="line">    console.log(<span class="string">'原'</span>+players[3],<span class="string">'concat合并数组'</span>+ team2[3]);</span><br><span class="line">    //3) ES6 里面的扩展语法</span><br><span class="line">    const team3 =[...players];</span><br><span class="line">    team3[3] =<span class="string">'33'</span>;</span><br><span class="line">    console.log(<span class="string">'原'</span>+players[3], <span class="string">'Es6写法'</span>+ team3[3]);</span><br><span class="line">    //4)Array.from()//创建新数组实例</span><br><span class="line">    const team4 =Array.from(players);</span><br><span class="line">    team4[3] =<span class="string">'44'</span>;</span><br><span class="line">    console.log(<span class="string">'原'</span>+players[3],<span class="string">'Array.from()创数组实例'</span>+ team4[3]);</span><br><span class="line">    //直接复制</span><br><span class="line">    const team = players;</span><br><span class="line">    team[3] =<span class="string">'Lux'</span>;</span><br><span class="line">    console.log( <span class="string">'原'</span>+players[3],<span class="string">'直接修改后'</span>+team[3]);</span><br><span class="line">    // 3.对象类型Object()</span><br><span class="line">     const person =&#123;</span><br><span class="line">        name:<span class="string">'Wes Bos'</span>,</span><br><span class="line">        age:20</span><br><span class="line">     &#125;;</span><br><span class="line">    //复制方法：2种</span><br><span class="line">    //1)Object.assign(target, ...sources) 时，后来的源对象的属性值，将会覆盖它之前的对象的属性。三个参数</span><br><span class="line">     const people =Object.assign(&#123;&#125;,person,&#123;age: 11&#125;);</span><br><span class="line">     console.log(<span class="string">'原:'</span>+person.age,<span class="string">'改:'</span>+people.age);</span><br><span class="line">    //json法：对象转字符串再转json--使用JSON.parse(JSON.stringify(obj))实现深拷贝</span><br><span class="line">    // stringify()从一个对象解析出字符串</span><br><span class="line">    // JSON.parse()从一个字符串中解析出json对象</span><br><span class="line">    const wes = &#123;</span><br><span class="line">      age: 100,</span><br><span class="line">    &#125;;</span><br><span class="line">    const people2 =JSON.parse(JSON.stringify(wes));</span><br><span class="line">    console.log(<span class="string">'原:'</span>+person.age,<span class="string">'改:'</span>+people2.age</span><br><span class="line"></span><br><span class="line">    //常规复制：均改，只引用不复制</span><br><span class="line">    const person1=person;</span><br><span class="line">        person1.age =80;</span><br><span class="line">    console.log(<span class="string">'原:'</span>+person.age,<span class="string">'常规复制:'</span>+person1.age);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/js30/14.png" alt="理论"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;09-Console-调试技巧&quot;&gt;&lt;a href=&quot;#09-Console-调试技巧&quot; class=&quot;headerlink&quot; title=&quot;09 Console 调试技巧&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/ximoxiyu/JavaScript30/tree/master&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;09 Console 调试技巧&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;仅html+js&lt;br&gt;[console对象与控制台学习]（&lt;a href=&quot;https://wangdoc.com/javascript/features/console.html）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://wangdoc.com/javascript/features/console.html）&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;console对象是js的原生对象&lt;br&gt;console用途：调试程序，提供命令行接口;F12&lt;br&gt;console面板：命令行窗口&lt;/li&gt;
&lt;li&gt;console对象的静态方法，可覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.console.log()输出普通信息&lt;br&gt;%c：css格式字符串–%c后面的内容&lt;br&gt;%d：打印整数&lt;br&gt;%s：打印字符串&lt;br&gt;%f：打印浮点数&lt;br&gt;%o：打印javascript对象，可以是整数，字符串，JSON对象&lt;br&gt;2.console.info()输出提示信息&lt;br&gt;3.console.error()输出错误信息&lt;br&gt;4.console.warn()输出警示信息&lt;br&gt;5.console.debug()输出调试信息&lt;br&gt;6.console.table()数据打印成表格&lt;br&gt;7.console.assert() 条件判断，2个参数;在第一个参数为 false 的情况下会在控制台输出信息。&lt;br&gt;8.console.dir()检查，可以显示一个对象的所有属性和方法&lt;br&gt;9.console.count()打印标识及调用次数，可接收字符串为参数，对执行次数进行分类&lt;br&gt;10.console.group()数组设置分组信息&lt;br&gt;  console.groupEnd()结束当前的分组。 console.groupCollapsed()隐藏分组信息&lt;br&gt;11.console.time()测试程序执行的时长&lt;br&gt;  console.timeEnd()计时结束,执行时长显示在控制台。&lt;br&gt;12.console.clear()清除控台台之前的信息;若选中控制台的“Preserve log”选项，console.clear方法将不起作用。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/03/26/hello-world/"/>
    <id>http://yoursite.com/2020/03/26/hello-world/</id>
    <published>2020-03-26T09:06:32.000Z</published>
    <updated>2020-03-26T09:06:34.340Z</updated>
    
    <content type="html"><![CDATA[<p>图片引用格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></table></figure><p><img src="/images/img.jpg" alt="你好"></p><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;图片引用格式&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>js30系列02</title>
    <link href="http://yoursite.com/2020/03/26/js30%E7%B3%BB%E5%88%9702/"/>
    <id>http://yoursite.com/2020/03/26/js30%E7%B3%BB%E5%88%9702/</id>
    <published>2020-03-26T09:05:01.000Z</published>
    <updated>2020-03-27T14:50:56.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="04-07-数组Array"><a href="#04-07-数组Array" class="headerlink" title="04+07 数组Array"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/04%20-%20Array%20Cardio%20Day%201" target="_blank" rel="noopener">04+07 数组Array</a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">Array</a></p><p>Array对象–构造数组的全局对象<br>2个属性：Array.length<br>Array.prototype //通过数组的原型对象可以为所有数组对象添加属性。所有数组实例都会从 Array.prototype 继承属性和方法。修改 Array 的原型会影响到所有的数组实例<br>方法：<br>Array.prototype.sort()//对数组元素进行排序，并返回当前数组。<br>Array.prototype.splice()//任意的位置给数组添加或删除任意个元素。<br>Array.prototype.reverse()//颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。<br>【迭代方法】<br>Array.prototype.forEach()//数组中的每个元素执行一次回调函数<br>Array.prototype.every()//【每个】数组中的每个元素都满足测试函数，则返回 true，否则返回 false<br>Array.prototype.some()//【某个】数组中至少有一个元素满足测试函数，则返回 true，否则返回 false<br>Array.prototype.filter()//所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回<br>Array.prototype.find()//找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。<br>Array.prototype.findIndex() //找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。<br>Array.prototype.map()//返回一个由回调函数的返回值组成的新数组。<br>Array.prototype.reduce()//从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值<br><img src="/images/js30/4_7.png" alt="效果"></p><a id="more"></a><h2 id="05照片墙-弹性盒子"><a href="#05照片墙-弹性盒子" class="headerlink" title="05照片墙+弹性盒子"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/05%20-%20Flex%20Panel%20Gallery" target="_blank" rel="noopener">05照片墙+弹性盒子</a></h2><p>【html】父.panels的div块–5个小div，内部分别有3个p元素<br>【css】1.  min-height:100vh;//vh表示相对视窗高度<br>2. 过渡效果 transition:<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">font-size 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),</span><br><span class="line">flex 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),</span><br><span class="line">background 0.2s;</span><br></pre></td></tr></table></figure><br>3. 每一个子div盒子设置为弹性盒子，三个子元素p用flex=1;将宽度均分，justify-conten+flex-direction确定相对位置<br>4. .panel &gt; * {} //类元素下所有元素<br>5. .panel p:nth-child(2) {}//每个小块下的第二个p<br>6. .panel.open {}与.cta{}<br>7. transform: translateY(100%);//向Y轴移动，设置为了让一开始只有中间P显示在页面内<br>8. 改变效果transform ： none ;    也就是：  transform: rotate | scale | skew | translate |matrix; //空格隔开<br>   <a href="https://blog.csdn.net/dongfanghaoyu/article/details/9253913" target="_blank" rel="noopener">transition&amp;transform</a><br>   <a href="https://segmentfault.com/q/1010000004080910" target="_blank" rel="noopener">flex:1</a>运用 flex 可以使各个元素按一定比例占据页面<br><img src="/images/js30/5.png" alt="效果"></p><!--more--><p>【总结】<br>element.classList.toggle()//在元素中切换类名，有就删除，没有就添加;重点是改CSS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">//1.获取所有类名为 panel 的元素</span><br><span class="line">//匹配指定 CSS 选择器的所有元素</span><br><span class="line">const panels = document.querySelectorAll(<span class="string">'.panel'</span>);</span><br><span class="line">// 2.为其添加 click 事件监听，编写触发事件调用的函数（给触发的 DOM 元素添加/去掉样式，实现拉伸/压缩的效果）</span><br><span class="line">panels.forEach(panel=&gt;panel.onclick=<span class="keyword">function</span>(e)&#123;</span><br><span class="line">  //添加类名</span><br><span class="line">  console.log(this);</span><br><span class="line">   this.classList.toggle(<span class="string">'open'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="难06-Fetch-filter快速匹配古诗"><a href="#难06-Fetch-filter快速匹配古诗" class="headerlink" title="难06.Fetch+filter快速匹配古诗"></a>难<a href="https://github.com/ximoxiyu/JavaScript30/tree/master/06%20-%20Type%20Ahead" target="_blank" rel="noopener">06.Fetch+filter快速匹配古诗</a></h2><p>【考察】 Ajax，json,异步操作，Promise，Array与正则</p><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noopener">Fetch API</a>提供了一个获取资源的接口（包括跨域请求）,提供全局方法fetch();接受 (资源的路径)作为参数，返回值是一个 Promise 对象。若请求成功，这个对象包含了（对应 Request 的）Response，但这只是一个 HTTP 响应。<br>fetch(input, init).then(function(response) { … });<br>常用的方法还有：blob()、text()、arrayBuffer()、formData()和json()</li><li>正则表达式<br>正则表达式的 match() 可以执行数据匹配，我们再结合 Array.filter() 便能筛出整个数组中，满足条件的项，再经过字符串处理即可输出到页面。<br>【html】form:input(输入框)与ul(列表展示)<br>input标签内placeholder 属性适用类型：text, search, url, telephone, email 以及 password。<br>表：输入字段预期值<br>诗句的来源 json 数据是加载页面时从网络中异步获得<br><img src="/images/js30/6.png" alt="效果"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    const endpoint = <span class="string">'https://gist.githubusercontent.com/soyaine/81399bb2b24ca1bb5313e1985533c640/raw/bdf7df2cbcf70706c4a5e51a7dfb8c933ed78878/TangPoetry.json'</span>;</span><br><span class="line"></span><br><span class="line">      // fetch(资源路径).<span class="keyword">then</span>(<span class="keyword">function</span>(response) &#123; ... &#125;);ES6写法</span><br><span class="line">      //1.声明一个空数组，用于存放解析 json 后的数据</span><br><span class="line">      const poetrys = [];</span><br><span class="line">      // 异步获取数据并解析,运用 fetch() 发送 HTTP 请求,获取返回的 Promise 对象,解析 JSON 数据,存入数组poetrys</span><br><span class="line">      fetch(endpoint)</span><br><span class="line">          .<span class="keyword">then</span>(blob =&gt; blob.json())</span><br><span class="line">          .<span class="keyword">then</span>(data =&gt; poetrys.push(...data));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      //先声明函数，方便后面事件绑定</span><br><span class="line"></span><br><span class="line">      // 匹配输入的函数:运用 filter() 过滤数组数据,创建正则表达式，构造过滤条件</span><br><span class="line">      <span class="keyword">function</span> findMatches(wordToMatch, poetrys) &#123;</span><br><span class="line">          <span class="built_in">return</span> poetrys.filter(poet =&gt; &#123;</span><br><span class="line">              //正则找出匹配诗句</span><br><span class="line">              //  在js中提供了一个内置构造函数RegExp来创建一个正则对象</span><br><span class="line">              const regex = new RegExp(wordToMatch, <span class="string">'gi'</span>);</span><br><span class="line">              const author = poet.detail_author.join(<span class="string">''</span>);</span><br><span class="line">              <span class="built_in">return</span> poet.detail_text.match(regex) || poet.title.match(regex) || author.match(regex);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 展示匹配结果函数:获取匹配数据,替换关键词放入高亮的标签,构造 HTML 标签数据,将匹配值的 HTML 标签放入 &lt;ul&gt; 中</span><br><span class="line">      <span class="keyword">function</span> <span class="function"><span class="title">displayMatches</span></span>() &#123;</span><br><span class="line">          // 获取匹配数据</span><br><span class="line">          const matches = findMatches(this.value, poetrys);</span><br><span class="line">          const regex = new RegExp(this.value, <span class="string">'gi'</span>);</span><br><span class="line">          const html = matches.map(poet =&gt; &#123;</span><br><span class="line">              //替换高亮标签</span><br><span class="line">              const text = poet.detail_text.replace(regex, `&lt;span class=<span class="string">"h1"</span>&gt;<span class="variable">$&#123;this.value&#125;</span>&lt;/span&gt;`);</span><br><span class="line">              const title = poet.title.replace(regex, `&lt;span class=<span class="string">"hl"</span>&gt;<span class="variable">$&#123;this.value&#125;</span>&lt;/span&gt;`);</span><br><span class="line">              //构造HTML值</span><br><span class="line">              <span class="built_in">return</span> `</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;span class=<span class="string">"poet"</span>&gt;<span class="variable">$&#123; text&#125;</span>&lt;/span&gt;</span><br><span class="line">&lt;span class=<span class="string">"title"</span>&gt;<span class="variable">$&#123; title&#125;</span> - <span class="variable">$&#123;poet.detail_author[0]&#125;</span>&lt;/span&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">`;</span><br><span class="line">          &#125;).join(<span class="string">''</span>);</span><br><span class="line">          ulSuggestions.innerHTML = html;</span><br><span class="line">      &#125;</span><br><span class="line">      //2.获取两个主要 HTML 元素（&lt;input&gt;，&lt;ul&gt;），给 &lt;input&gt; 添加事件监听（change, keyup）均触发同一个函数</span><br><span class="line">      const inputSearch = document.querySelector(<span class="string">'.search'</span>);</span><br><span class="line">      const ulSuggestions = document.querySelector(<span class="string">'.suggestions'</span>);</span><br><span class="line">      inputSearch.addEventListener(<span class="string">'change'</span>, displayMatches);</span><br><span class="line">      inputSearch.addEventListener(<span class="string">'keyup'</span>, displayMatches);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;04-07-数组Array&quot;&gt;&lt;a href=&quot;#04-07-数组Array&quot; class=&quot;headerlink&quot; title=&quot;04+07 数组Array&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/ximoxiyu/JavaScript30/tree/master/04%20-%20Array%20Cardio%20Day%201&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;04+07 数组Array&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Array&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Array对象–构造数组的全局对象&lt;br&gt;2个属性：Array.length&lt;br&gt;Array.prototype //通过数组的原型对象可以为所有数组对象添加属性。所有数组实例都会从 Array.prototype 继承属性和方法。修改 Array 的原型会影响到所有的数组实例&lt;br&gt;方法：&lt;br&gt;Array.prototype.sort()//对数组元素进行排序，并返回当前数组。&lt;br&gt;Array.prototype.splice()//任意的位置给数组添加或删除任意个元素。&lt;br&gt;Array.prototype.reverse()//颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。&lt;br&gt;【迭代方法】&lt;br&gt;Array.prototype.forEach()//数组中的每个元素执行一次回调函数&lt;br&gt;Array.prototype.every()//【每个】数组中的每个元素都满足测试函数，则返回 true，否则返回 false&lt;br&gt;Array.prototype.some()//【某个】数组中至少有一个元素满足测试函数，则返回 true，否则返回 false&lt;br&gt;Array.prototype.filter()//所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回&lt;br&gt;Array.prototype.find()//找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。&lt;br&gt;Array.prototype.findIndex() //找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。&lt;br&gt;Array.prototype.map()//返回一个由回调函数的返回值组成的新数组。&lt;br&gt;Array.prototype.reduce()//从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值&lt;br&gt;&lt;img src=&quot;/images/js30/4_7.png&quot; alt=&quot;效果&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="js30" scheme="http://yoursite.com/tags/js30/"/>
    
  </entry>
  
  <entry>
    <title>js30系列01</title>
    <link href="http://yoursite.com/2020/03/23/js30%E7%B3%BB%E5%88%9701/"/>
    <id>http://yoursite.com/2020/03/23/js30%E7%B3%BB%E5%88%9701/</id>
    <published>2020-03-23T13:04:31.000Z</published>
    <updated>2020-03-26T10:43:00.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-打鼓"><a href="#01-打鼓" class="headerlink" title="01 打鼓"></a>01 <a href="https://github.com/ximoxiyu/JavaScript30/tree/master/01%20-%20JavaScript%20Drum%20Kit" target="_blank" rel="noopener">打鼓</a></h2><p>【基本思路】<br>触发键盘按键ASDFGHJKL,进行audio播放与样式的改变,结束后触发transitionend事件去除样式;<br>【html】一大块div(keys)内含9小块div(key)，每小块div有自身的键码data-key与音频sound;<br>每个按键码对应一个audio标签，进行指定音频【注：音频地址为本地sounds文件夹】</p><a id="more"></a><p>【css】<br>1)样式背景属性<a href="https://blog.csdn.net/qq_27674439/article/details/90674949" target="_blank" rel="noopener">background</a><br>我只设置了图片与位置,大小;注意：position与size使用时加/<br>2)高亮样式.playing由动态添加<br>3) /* 复合属性，含四个子属性，所用属性在0.07秒内匀速变化 */<br>  transition:all .07s;<br>4)设置英文字母为大写text-transform: uppercase;</p><p>【重点-JS】<br>两个事件：键盘keydown事件与transitionend事件<br>keydown事件：按键后audio.play()与增加样式<br>transitionend事件:获取所有按键，移出新样式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//监听键盘事件</span><br><span class="line">window.onkeydown =<span class="keyword">function</span> (e) &#123; </span><br><span class="line">    // 1.获取键码--获取音频与DIV元素</span><br><span class="line">    const audio=document.querySelector(`audio[data-key=<span class="string">"<span class="variable">$&#123;event.keyCode&#125;</span>"</span>]`);</span><br><span class="line">    const key=document.querySelector(`div[data-key=<span class="string">"<span class="variable">$&#123;event.keyCode&#125;</span>"</span>]`);</span><br><span class="line">    // 2.处理元素:播放音频，添加样式</span><br><span class="line">    // <span class="keyword">if</span>(!audio) <span class="built_in">return</span>;//处理无效按键</span><br><span class="line">    key.classList.add(<span class="string">'playing'</span>);//每个按键添加类名--添样式</span><br><span class="line">    //没有此语句时，按住不放是一声一声，加上后是连续鼓点</span><br><span class="line">    audio.currentTime = 0; // 每次播放之后都使音频播放进度归零=按键按住不放时，马上响起连续鼓点声</span><br><span class="line">    audio.play();//音频播放</span><br><span class="line">&#125;;</span><br><span class="line">// document.querySelectorAll()返回的不是一个数组，而是一个NodeList;不可遍历，所以使用Array.from转化成数组</span><br><span class="line">//获取页面上所有按键,为其添加transitionend 的事件，去除样式</span><br><span class="line">const keys = Array.from(document.querySelectorAll(<span class="string">'.key'</span>));</span><br><span class="line">//遍历元素触发事件</span><br><span class="line">keys.forEach(key=&gt;key.ontransitionend=<span class="keyword">function</span>(event)&#123;</span><br><span class="line">  // 过滤其中一种事件</span><br><span class="line">    <span class="keyword">if</span>(event.propertyName !=<span class="string">"transform"</span>)</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">      //去除样式</span><br><span class="line">    event.target.classList.remove(<span class="string">'playing'</span>);</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>【易错点】</p><ol><li>keys.forEach();//forEach后面直接加()</li><li>模板字面量–模板字符串的标识<br><code>字符串 ${ 变量、属性名 }</code><br>const audio=document.querySelector(`audio[data-key=”${event.keyCode}”]//为什么加了””?</li></ol><hr><h2 id="02-纯-JS、CSS-时钟"><a href="#02-纯-JS、CSS-时钟" class="headerlink" title="02 纯 JS、CSS 时钟"></a>02 <a href="https://github.com/ximoxiyu/JavaScript30/tree/master/02%20-%20JS%20%2B%20CSS%20Clock" target="_blank" rel="noopener">纯 JS、CSS 时钟</a></h2><p>目的：动态更新指针位置<br>关键：指针的旋转与获取实时时间，每转一秒改变一次指针状态–类比音乐播放器的旋转<br>核心思想:每走1s，改变分针的角度;实质：利用定时器setInterval获取当前时间Date对象时分秒针的转动角度，改变转动样式<br><img src="/images/js30/2.png" alt="效果"><br>【html】最大块clock–含整个表clock-face–含时,分，秒针<br>【css】圆盘指针属性<br>【js】1.获html节点<br>2.定时器setInterval每隔1s=1000ms进行一次处理(获取当前时间，更改对应角度，注意加90°–起始位置,获取到的html节点来改变样式transform：rotate())</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 核心:动态改时间旋转角度</span><br><span class="line">// 1.获取三个指针的HTML</span><br><span class="line">const secHand = document.querySelector(<span class="string">'.second-hand'</span>);</span><br><span class="line">const minHand = document.querySelector(<span class="string">'.min-hand'</span>);</span><br><span class="line">const hourHand = document.querySelector(<span class="string">'.hour-hand'</span>);</span><br><span class="line">//定时器+Data获取时间,定时器间隔ms</span><br><span class="line">var num=setInterval(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  // 编写setDate函数,获取当前时分秒，计算相应角度</span><br><span class="line">  //获取当前时间</span><br><span class="line">  const data = new Date();</span><br><span class="line">  const second =data.getSeconds();//获取秒</span><br><span class="line">  //计算角度：90°--0秒，60秒走360度</span><br><span class="line">  const secondDeg = 90+(second/60)*360;</span><br><span class="line">  const min =data.getMinutes();</span><br><span class="line">  const minDeg = 90 +(min/60)*360;</span><br><span class="line">  const hour = data.getHours();</span><br><span class="line">  //加入分钟所占的时间，是时针缓慢移动</span><br><span class="line">  // 时针在一小时内缓慢的移动到下一个时间点。所以可以利用上分钟，计算每一分钟对时针的角度影响，将加到时针角度上即可</span><br><span class="line">  const hourDeg = 90 + (hour / 12) * 360 + (min / 12 / 60) * 360;</span><br><span class="line">  // const hourDeg =( 90+ (hour/12)*360);也可</span><br><span class="line"></span><br><span class="line">  // 动态将角度值赋值给 HTML 元素的 style 中的 transform 属性</span><br><span class="line">  secHand.style.transform=`rotate(<span class="variable">$&#123;secondDeg&#125;</span>deg)`;</span><br><span class="line">  minHand.style.transform = `rotate(<span class="variable">$&#123; minDeg &#125;</span>deg)`;</span><br><span class="line">  hourHand.style.transform = `rotate(<span class="variable">$&#123; hourDeg &#125;</span>deg)`;</span><br><span class="line">        //在控制台打印当前时间及对应的角度</span><br><span class="line">        console.log(`<span class="variable">$&#123;hour&#125;</span>:<span class="variable">$&#123;min&#125;</span>:<span class="variable">$&#123;second&#125;</span>-角度<span class="variable">$&#123;hourDeg&#125;</span>:<span class="variable">$&#123;minDeg&#125;</span>:<span class="variable">$&#123;secondDeg&#125;</span>`);</span><br><span class="line">&#125;,1000); </span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>【难点】css中的样式设定：指针加阴影box-shadow<br>1.贝塞尔曲线过渡<a href="https://www.cnblogs.com/tenfly/p/11559845.html" target="_blank" rel="noopener">transition-timing-function: cubic-bezier(0.9, 0.54, 0.26, 1.68);</a><br>2.转换–调整曲线轴点–旋转元素的基点位置[transform-origin]<br>3.过渡–时钟指针跳动时的过渡效果<br>transition: all 3s;//复合属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: property duration timing-function delay;</span><br></pre></td></tr></table></figure><p>这里js主要改的是transform:rotate()</p><h3 id="3-js控制css"><a href="#3-js控制css" class="headerlink" title="3.js控制css"></a><a href="https://github.com/ximoxiyu/JavaScript30/tree/master/03%20-%20CSS%20Variables" target="_blank" rel="noopener">3.js控制css</a></h3><p>【核心】触发事件mousemove或input的change,改变css的样式<br><img src="/images/js30/3.png" alt="效果"><br>【html】标题,<a href="https://blog.csdn.net/zhouziyu2011/article/details/58594447?utm_source=blogxgwz0" target="_blank" rel="noopener">label+input</a>构成控制栏(),图片img</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//通过为&lt;input&gt;设置id属性，在&lt;lable&gt;标签中设置<span class="keyword">for</span>=id来让说明文本和对应的&lt;input&gt;关联起来。</span><br><span class="line"> &lt;label <span class="keyword">for</span>=<span class="string">"spacing"</span>&gt;Spacing:&lt;/label&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"range"</span> name=<span class="string">"spacing"</span> min=<span class="string">"10"</span> max=<span class="string">"200"</span> value=<span class="string">"10"</span> data-sizing=<span class="string">"px"</span>&gt;</span><br></pre></td></tr></table></figure><p>【css】</p><ol><li>声明全局（:root）对应html标签的 CSS 变量  –变量名</li><li>使用全局变量(要改变的元素hh类与img内使用) var(–变量名)<br>【js】</li><li>两种事件均会改变样式，故将改变样式封装成函数，触发事件调用此函数即可</li><li>多个input标签选定节点，forEach遍历;</li><li>addEventListener事件监听，一个事件可执行多个函数</li><li>change事件-input值变动，触发;mousemove-鼠标移动<br>【难点】样式改变<br>1)获取参数值后缀—数据属性 dataset<br>2)获取参数名与参数值<br>3)对应css变量赋值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        //   用 JS和 CSS3 实现拖动滑块时，实时调整图片的内边距、模糊度、背景颜色，同时标题中 JS 两字的颜色也随图片背景颜色而变化。</span><br><span class="line"></span><br><span class="line">        // 编写处理更新操作的方法</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">handleUpdate</span></span>() &#123;</span><br><span class="line">            // 获取参数值后缀</span><br><span class="line">            const suffix = this.dataset.sizing || <span class="string">''</span>; // 根据 data-sizing 获取参数的后缀</span><br><span class="line">            // 获取参数名（blur、spacing、color）</span><br><span class="line">            document.documentElement.style.setProperty(`--<span class="variable">$&#123;this.name&#125;</span>`, this.value + suffix); // 设置页面 CSS 变量的值</span><br><span class="line">            // 获取参数值（12px、<span class="comment">#efefef）并赋值给相应的CSS变量--文档根元素</span></span><br><span class="line">            document.getElementById(this.name).innerText = this.value + suffix; // 页面参数实时显示</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取页面中 input 元素</span><br><span class="line">        const inputs = document.querySelectorAll(<span class="string">'.controls input'</span>);</span><br><span class="line">        // 给每个 input 添加监听事件(两种)，使其在值变动，触发更新操作</span><br><span class="line">        inputs.forEach(input =&gt; input.addEventListener(<span class="string">'mousemove'</span>, handleUpdate));//可以加多个函数,不能加多个事件</span><br><span class="line">        inputs.forEach( input =&gt; input.addEventListener(<span class="string">'change'</span>, handleUpdate));</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="处理参数值"><a href="#处理参数值" class="headerlink" title="处理参数值"></a>处理参数值</h4>只需要加上 data- 前缀，可以随便添加和命名,利用dataset来访问，dataset 的值是 DOMStringMap 的一个实例化对象，其中包含之前所设定的自定义属性的“名-值”对。<br>input标签中声明data-sizing=”px”,在js中用dataset.sizing来获取后缀名</li></ol><h4 id="js处理css样式"><a href="#js处理css样式" class="headerlink" title="js处理css样式"></a>js处理css样式</h4><p>获取文档根元素document.documentElement，改变css的全局变量</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;01-打鼓&quot;&gt;&lt;a href=&quot;#01-打鼓&quot; class=&quot;headerlink&quot; title=&quot;01 打鼓&quot;&gt;&lt;/a&gt;01 &lt;a href=&quot;https://github.com/ximoxiyu/JavaScript30/tree/master/01%20-%20JavaScript%20Drum%20Kit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;打鼓&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;【基本思路】&lt;br&gt;触发键盘按键ASDFGHJKL,进行audio播放与样式的改变,结束后触发transitionend事件去除样式;&lt;br&gt;【html】一大块div(keys)内含9小块div(key)，每小块div有自身的键码data-key与音频sound;&lt;br&gt;每个按键码对应一个audio标签，进行指定音频【注：音频地址为本地sounds文件夹】&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="js30" scheme="http://yoursite.com/tags/js30/"/>
    
  </entry>
  
  <entry>
    <title>ajax与fetch学习</title>
    <link href="http://yoursite.com/2020/03/21/ajax%E4%B8%8Efetch/"/>
    <id>http://yoursite.com/2020/03/21/ajax%E4%B8%8Efetch/</id>
    <published>2020-03-21T05:04:07.000Z</published>
    <updated>2020-03-21T05:53:47.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ajax学习"><a href="#Ajax学习" class="headerlink" title="Ajax学习"></a>Ajax学习</h2><p>在控制台查看网页发送的网络请求,Network-XHR–Response</p><ol><li>定义:Asynchronous JavaScript and XML—异步 JavaScript 和 XML</li><li>用途:浏览器赋予js主动发起网络请求</li><li>XML数据传输格式(早期ajax使用)，现被JSON取代</li><li>实现方式：提供XMLHttpRequest构造函数，两部分XML+HttpRequest(指http协议中的请求报文);XMLHttpRequest函数让JS主动发起http请求，从而与服务器之间通过http协议来相互通信<a id="more"></a></li><li>1)一般将上述构造函数，new一个新对象xhr，即<br> var xhr =new XMLHttpRequest();</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">xhr对象的三个属性:</span><br><span class="line">1).readyState：表示当前 XHR 对象请求/响应过程的当前活动阶段,四个属性值(0,1,2,3,4)   <span class="keyword">if</span>(xhr.readyState ===4)</span><br><span class="line">0 UNSENT (初始状态，未打开)</span><br><span class="line">此时xhr对象被成功构造，open()方法还未被调用</span><br><span class="line"></span><br><span class="line">1 OPENED (已打开，未发送)</span><br><span class="line">open() 方法已被成功调用，send()方法还未被调用。注意：只有xhr处于OPENED状态，才能调用xhr.setRequestHeader()</span><br><span class="line">和xhr.send()，否则会报错</span><br><span class="line"></span><br><span class="line">2 HEADERS_RECEIVED (已获取响应头)</span><br><span class="line">send()方法已经被调用, 响应头和响应状态已经返回</span><br><span class="line"></span><br><span class="line">3 LOADING (正在下载响应体)</span><br><span class="line">响应体(response entity body)正在下载中，此状态下通过xhr.response可能已经有了响应数据</span><br><span class="line"></span><br><span class="line">4 DONE (整个数据传输过程结束)</span><br><span class="line">整个数据传输过程结束，不管本次请求是成功还是失败</span><br><span class="line">2).status：服务器响应报文的[状态码](http://blog.poetries.top/FE-Interview-Questions/base/<span class="comment">#_6-http%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89)if(xhr.status ===200)</span></span><br><span class="line">3).responseText：保存了服务器返回的数据  console.log(xhr.responseText);</span><br></pre></td></tr></table></figure><p>   2)open方法打开xhr对象–启动请求未发送<br>      xhr.open(‘GET’,url,true)//三个参数：<a href="http://blog.poetries.top/FE-Interview-Questions/base/#_3-http%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E7%94%A8%E9%80%94" target="_blank" rel="noopener">http请求方法</a>，http请求地址，第三个不常用<br>    3)send方法–发送http请求<br>    xhr.send(null)//一个参数–发送给server的信息(请求报文中的消息体)，字符串类型xhr.send(‘hello’);或null<br>    4)onreadystatechange属性–获取服务器数据<br>    在readyState属性变为4(请求完成)的时候访问responseText属性(存放服务器的响应数据)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 设定XHR对象的onreadystatechange属性</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'调用send函数后的XHR对象：'</span>, xhr.readyState);</span><br><span class="line"></span><br><span class="line">  // 浏览器接收完成server数据,下面用了xhr对象的三个属性</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === 4) &#123;</span><br><span class="line">    // 响应状态码有效,2XX：成功状态码,304自从上次请求后，请求的网页未修改过</span><br><span class="line">    <span class="keyword">if</span> (200 &lt;= xhr.status &lt; 300 || xhr.status === 304) &#123;</span><br><span class="line">      console.log(<span class="string">'接收到服务器数据：'</span>, xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个XHR对象</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">console.log(<span class="string">'刚刚创建的XHR对象：'</span>, xhr.readyState);</span><br><span class="line"></span><br><span class="line">// 打开XHR对象，</span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'http://yapi.demo.qunar.com/mock/63071/helloworld'</span>);</span><br><span class="line">console.log(<span class="string">'调用open函数后的XHR对象：'</span>, xhr.readyState);</span><br><span class="line"></span><br><span class="line">// 设定XHR对象的onreadystatechange属性</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'调用send函数后的XHR对象：'</span>, xhr.readyState);</span><br><span class="line"></span><br><span class="line">  // 浏览器接收完成服务器数据</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === 4) &#123;</span><br><span class="line">    // 响应状态码有效</span><br><span class="line">    <span class="keyword">if</span> (200 &lt;= xhr.status &lt; 300 || xhr.status === 304) &#123;</span><br><span class="line">      console.log(<span class="string">'接收到服务器数据：'</span>, xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 发送http请求</span><br><span class="line">xhr.send(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">刚刚创建的XHR对象：0</span><br><span class="line">调用open函数后的XHR对象：1</span><br><span class="line">调用send函数后的XHR对象：2</span><br><span class="line">调用send函数后的XHR对象：3</span><br><span class="line">调用send函数后的XHR对象：4</span><br><span class="line">接收到服务器数据：Hello World!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Ajax学习&quot;&gt;&lt;a href=&quot;#Ajax学习&quot; class=&quot;headerlink&quot; title=&quot;Ajax学习&quot;&gt;&lt;/a&gt;Ajax学习&lt;/h2&gt;&lt;p&gt;在控制台查看网页发送的网络请求,Network-XHR–Response&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义:Asynchronous JavaScript and XML—异步 JavaScript 和 XML&lt;/li&gt;
&lt;li&gt;用途:浏览器赋予js主动发起网络请求&lt;/li&gt;
&lt;li&gt;XML数据传输格式(早期ajax使用)，现被JSON取代&lt;/li&gt;
&lt;li&gt;实现方式：提供XMLHttpRequest构造函数，两部分XML+HttpRequest(指http协议中的请求报文);XMLHttpRequest函数让JS主动发起http请求，从而与服务器之间通过http协议来相互通信
    
    </summary>
    
    
    
      <category term="前端学习" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>面试题03</title>
    <link href="http://yoursite.com/2020/03/21/%E9%9D%A2%E8%AF%95%E9%A2%9803/"/>
    <id>http://yoursite.com/2020/03/21/%E9%9D%A2%E8%AF%95%E9%A2%9803/</id>
    <published>2020-03-21T05:03:21.000Z</published>
    <updated>2020-03-29T09:51:33.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a><a href="http://blog.poetries.top/FE-Interview-Questions/base/#%E4%B8%89%E3%80%81javascript" target="_blank" rel="noopener">js基础</a></h2><p> 1)<a href="http://blog.poetries.top/FE-Interview-Questions/base/#_1-%E9%97%AD%E5%8C%85" target="_blank" rel="noopener">闭包</a><br> 读取函数内部变量的函数;创建闭包：函数内嵌套函数,内部函数可访问外变量与参数,变量与参数不会被垃圾机制回收<br> 理解：避免全局污染，但增加内存，使用不当会增加内存泄漏；在js中函数即闭包<br> <a id="more"></a><br>2)作用域链<br>作用域:变量与函数的可访问范围,作用域链保证有序<br>3)<a href="https://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="noopener">JS原型,原型链及特点</a><br>实例的构造函数属性指向构造函数<br>对象分普通对象和函数对象,每个对象都有 <strong>proto</strong> 属性，但只有函数对象才有 prototype 属性,原型对象就是 Person.prototype<br>原型对象（Person.prototype）是 构造函数（Person）的一个实例。<br>JS对象通过引用传递<br>原型:对象内部属性–prototype(原型)<br>原型链:访问一个对象属性,若没有,去原型里找,此原型又有自身原型,递推下去，一直检索到 Object 内建对象<br>关系：instance.constructor.prototype = instance.<strong>proto</strong><br>4)事件代理(事件委托):事件绑定到父元素–DOM元素事件冒泡<br>可节省内存,减少事件注册,提高性能<br>5)JS继承:构造继承,原型继承及两者混用(常用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//构造函数首字母大写</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>()&#123;</span><br><span class="line">    this.name =<span class="string">'wang'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>()&#123;</span><br><span class="line">    this.age =<span class="string">'22'</span>;</span><br><span class="line">&#125;</span><br><span class="line">//通过原型,继承Parent属性</span><br><span class="line">Child.prototype =new Parent();</span><br><span class="line">//创建demo实例</span><br><span class="line">var demo = new Child();</span><br><span class="line">alert(demo.age);</span><br><span class="line">alert(demo.name);//得到被继承的属性</span><br></pre></td></tr></table></figure><p>6)this对象的理解:<br>四种绑定:默认,显性,隐形,new<br>遇到this,函数还原foo.call();<br>this-函数直接调用者/new的对象/触发事件的对象/全局对象Window<br>7)事件模型<br>事件发生三阶段:捕获(父子)-目标-冒泡(子父)<br>DOM事件流:支持捕获型事件与冒泡型事件<br>阻止冒泡stopPropagation();阻止捕获:阻止事件的默认行为preventDefault()方法<br>8)new操作符用途:创建空对象,this变量引用此对象,属性方法被加入且继承函数原型<br>9)Ajax原理:前后端中间加入中间层(Ajax引擎),由XMLHttpRequest对象向服务器发送异步请求获数据,js操作DOM更新页面.【异步操作】<br>此过程只涉及JS，XMLHttpRequest与DOM<br>优缺点：异步操作，减少带宽占用，不易调试，不安全<br>【同步与异步区别】<br>10)跨域：<br>浏览器的同源策略(Sop)：”协议+域名+端口”安全协议</p><p>多用：nginx代理跨域<br>11)模块化开发：ES6 module<br>12)异步加载JS:async?<br>13)内存泄漏：应用程序不再需要占用内存，内存仍存在<br>闭包使用不当;setTimeout第一个参数为字符串;控制台日志，循环(两对象彼此引用，保留)<br>14)JSON与XML：数据交换格式，多用JSON<br>基于JS的子集，易读写，占带宽小<br>JSON字符串转换为JSON对象:var obj = JSON.parse(str);<br>JSON对象转换为JSON字符串:var last=JSON.stringify(obj);<br>15)webpack:模块打包工具<br>16)AMD与Commonjs<br>Commonjs–Node.js采用的服务器模块规范，同步;module.exports属性赋值–模块对象<br>AMD-非同步加载模块,返回对象做模块对象<br>es6模块 CommonJS、AMD、CMD<br>17)web安全及防护<br>18)设计模式：工厂模式，构造函数模式<br>21)JS方法定义对象<br>对象字面量 var obj ={}<br>构造函数  var obj = new Object();<br>Object.create()  var obj =Object.create(Object.prototype)<br>22)兼容性问题【重】<br>全局的*{margin:0;padding:0;}<br>23)Promise对象<br>四种状态：pending初始状态，fulfilled成功操作，rejected失败，settled<br>Promise对象：延迟与异步计算<br>【异步编程实现】<br>回调函数(简单，不利维护);事件监听(事件驱动型);发布、订阅(类似事件监听);Promise对象(then方法，链式);Generator函数;async函数<br>24)js优势：防变量全局污染，window对象做局部变量，链式调用节约代码<br>25)vue与react<br>26)Node应用场景<br>29)web开发会话跟踪：cookie,session,url重写，ip地址，隐藏input<br>30)基本数据类型(5)：Number Boolean String Null Undefined<br>31)js内置对象：object父对象;数据封装类对象(Array Object Boolean Number String);其他对象(function Math Date RegExp(正则) Error Arguments)<br>32)js基本规范：<br>33)JS几种类型值：栈-基本数据类型，大小固定，占据空间小;堆-引用数据类型(数组，对象，函数)<br>区别：存储位置不同,引用数据类型仔栈中存指针，指针指向堆中实体的起始地址<br>寻找引用值：在栈中找地址，从堆中获实体<br>35)eval:字符串解析为js代码，避免使用，耗内存<br>36)null与undefined区别：变量是否声明赋值，参与数学运算;验证时用===<br>38)use strict:严格运行模式，编码更规范;<br>严格模式限制：变量先声明后使用，函数参数不能有同名属性，不能用with,禁止this指向全局对象<br>40)js延迟加载：defer(并行加载js,顺序执行)和async(并行加载js,下载完成执行)、动态创建DOM方式（用得最多）、按需异步载入js</p><p>42)<a href="https://www.cnblogs.com/web-wjg/p/7240985.html" target="_blank" rel="noopener">渐进增强与优雅降级</a><br>目的：关注不同浏览器下的不同体验<br>低-构建页面，高-增加效果—从低版本到高版本<br>先构建完整功能，低版本兼容—从高版本到低版本<br>45)attribute和property的区别<br>dom元素在html/js的属性;html标准属性：同步，自动更新;自定义属性：不同步<br>46)ES6理解【重点】:模板字符串,箭头函数，Promise对象，let与const，块级作用域，引入module模板;Object.creat()写class<br>58)原生js:数据类型，运算，对象，函数，继承，闭包，作用域，原型链，事件，正则，JSON,Ajax,DOM,BOM,内存泄漏，跨域，异步装载，模板引擎，前端MVC,路由，模块化，Canvas，ECMAScript<br>48)<a href="https://blog.csdn.net/jean_1221/article/details/51694008" target="_blank" rel="noopener">面向对象&amp;面向过程</a><br>面向对象:功能划分，对象，类，继承，封装；易维护，易扩展，缩短开发周期，重用性<br>面向过程：步骤划分<br>js是面向对象<br>50)web标准、可用性、可访问性<br>51)JS判断一个数组<br>52)let与var  块中封闭作用域<br>53)map与forEach:遍历循环<br>map返回新数组，return<br>forEach(遍历数组内容，数组索引，当前遍历数组)<br>54)函数式编程：编程范式，如何编写程序的方法<br>特性：闭包与高阶函数，惰性计算，递归，函数–只用表达式<br>55)箭头函数【重点】：内部无this对象，不用new,不作构造函数<br>59)JS动画与CSS3动画区别<br>复杂-js动画;css3-小交互动效<br>60)js数组和对象遍历方式：for in/for/forEach<br>61)gulp:基于流的代码构建工具，易使用，构建快速，学习<br>62)Vue双向绑定数据：<br>64)let var const<br>65)数组乱序<br>66)渲染数据不卡界面(代码)<br>67)获取页面checkbox<br>68)添加，移除，移动，复制，创建，寻找节点<br>69)正则表达式RegExp<br>70)js的callee与caller<br>71)window.onload与$(document).ready<br>window.onload()加载完毕才执行<br>$(document).ready()不必加载完就执行<br>72)addEventListener()依次执行和attachEvent()倒序执行的区别<br>74)数组去重：set;for嵌套for，用splice;indexOf;filter<br>75)页面节点拖拽(代码) js实现持续动画<br>76)js的全局函数与变量<br>80)项目优化:减少HTTP请求数，减少DNS查询，使用CDN,避免重定向，图片懒加载等<br>81)浏览器缓存：强、协商缓存<br>82)WebSocket<br>83)Electron理解：套了Chrome的nodejs<br>84)深浅拷贝<br>85)防抖、节流<br>86)变量提升：<br>87)单线程：仅一个线程，只做一个事，避免DOM渲染冲突<br>103)完成一个Dialog组件<br>105)ajax,axios,fetch</p><hr><h3 id="Webpack相关"><a href="#Webpack相关" class="headerlink" title="Webpack相关"></a>Webpack相关</h3><ol><li>打包体积优化<br>代码压缩插件Uglifyjsplugin;服务器启用gzip压缩;剥离css文件，单独打包</li><li>打包效率:热更新;配置devtool;选合适loader;优化构建时的搜索路径 指明需要构建目录及不需要构建目录</li><li>Loader:node模块，输出一个函数(代码)</li></ol><h3 id="编程题-剑指offer-递归思想"><a href="#编程题-剑指offer-递归思想" class="headerlink" title="编程题(剑指offer)-递归思想"></a>编程题(剑指offer)-递归思想</h3><p>2)如何判断一个对象是否为数组?<br>3)冒泡排序,快速排序(递归)<br>5)求一个字符串的字节长度:判ASCII(有问题)<br>6)bind的用法<br>与call和apply相同，区别是call和apply是立即调用函数，而bind是返回了一个函数，需要调用的时候再执行。<br>7)函数clone,while比for效率高–递归算法<br>8)闭包<br>12)12 写一段JS程序提取URL中的各个GET参数<br>14)闭包  快捷作用域<br>15)回文字符串<br>16)数组扁平化处理:递归</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>负载均衡</li><li>CDN：内容分发网络</li><li>内存泄漏</li><li>babel原理</li><li>js自定义事件</li><li>前后端路由差别</li></ol><p><a href="http://blog.poetries.top/FE-Interview-Questions/base/#%E4%B8%89%E3%80%81javascript" target="_blank" rel="noopener">题库</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端基础js,105道
    
    </summary>
    
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
      <category term="基础篇" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>面试题02</title>
    <link href="http://yoursite.com/2020/03/21/%E9%9D%A2%E8%AF%95%E9%A2%9802/"/>
    <id>http://yoursite.com/2020/03/21/%E9%9D%A2%E8%AF%95%E9%A2%9802/</id>
    <published>2020-03-21T05:03:06.000Z</published>
    <updated>2020-03-24T10:17:09.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a><a href="http://blog.poetries.top/FE-Interview-Questions/base/#_19-%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%A5%87%E6%95%B0%E8%BF%98%E6%98%AF%E5%81%B6%E6%95%B0%E7%9A%84%E5%AD%97%E4%BD%93%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F" target="_blank" rel="noopener">CSS部分</a></h2><ol><li><a href="">css sprite是什么及优缺点？</a><a href="https://www.cnblogs.com/evenyao/p/9262371.html">https://www.cnblogs.com/evenyao/p/9262371.html</a><br>css精灵或雪碧图,网页图片的应用处理—多个小图拼成一个大图(背景图像)<br>background-position 背景图像background-image的起始位置(左上角)。使用雪碧图前确定每个小图标的位置 background-position:x y<a id="more"></a></li><li>display: none;与visibility: hidden;的区别<br>均是元素不可见;display: none元素从渲染树消失，不占空间，非继承性，读屏器不读取</li><li><a href="http://www.divcss5.com/rumen/r431.shtml" target="_blank" rel="noopener">link与@import的区别</a><br>均是引入css样式;<br>1)语法结构<br>link是html标签,而@import url(CSS文件路径地址);在style标签下使用<br>2)link最大限度支持并行下载;@import是串行下载，出现FOUC,且必须在样式规则前，可在css文件中引用其他文件<br>3)link优于@import</li><li><a href="https://www.cnblogs.com/gxx129/p/10859117.html" target="_blank" rel="noopener">FOUC-文档样式短暂失效</a><br>Flash Of Unstyled Content无样式内容闪烁，在IE下由@import导入css文件引起;IE先加载文档DOM树，再导入外部css,两者时间中页面无样式<br>解决：使用link标签</li><li><a href="https://blog.csdn.net/sinat_36422236/article/details/88763187" target="_blank" rel="noopener">BFC的创建与用途</a><br>block formatting context块格式化上下文<br>用途：1)使BFC内部浮动元素不乱跑，2)与浮动元素产生边界<br>正常的文档流中，块级元素是按照从上自下，内联元素从左到右的顺序排列，给float或绝对定位absolute，元素脱离正常文档流<br>举例子而不要纠结定义<br>BFC规范：决定元素对其内容定位及其他元素的关系与相互作用</li><li>display、float、position的关系：绝对定位、浮动、根元素都需要调整display</li><li>清除浮动的几种方式,最佳：父级div定义伪类:after和zoom</li><li>初始化CSS样式：浏览器的兼容问题，但会影响SEO</li><li>css3新特性：圆角 border-radius, 文字特效text-shadow,线性渐变,旋转transform,新增伪类</li><li>display有哪些值7【重点】 </li><li>标准的CSS的盒子模型：W3C盒子模型content+padiing+border+margin;低版本IE的盒模型中的content包含border与padding</li><li>css优先级算法：就近；!important &gt; id &gt; class &gt; tag; !important 比 内联优先级高</li><li>浮动和清除浮动</li><li>position的值， relative(原位置)和absolute定位原点(不为static的父元素)</li><li>display:inline-block 什么时候不会显示间隙？移除空格，使用margin负值，使用font-size:0,【参考代码04间隙解决】</li><li>PNG\GIF\JPG的区别及如何选【记住】</li><li>行内元素float:left后是否变为块级元素？像inline-block,但默认效果不是100%,可以设置padding-top和padding-bottom或者width、height</li><li><a href="https://blog.csdn.net/jian_xi/article/details/79346477" target="_blank" rel="noopener">在网页中使用偶数字体</a>：更容易与web设计的其他部分构成比例关系;低版本浏览器ie6会将奇数字体强制转换成偶数字体</li><li>::before 和 :after中双冒号–伪元素和单冒号–CSS3伪类<br>伪类用于选择DOM树之外的信息，或是不能用简单选择器进行表示的信息。伪元素为DOM树没有定义的虚拟元素<br><a href="https://segmentfault.com/a/1190000019122105" target="_blank" rel="noopener">伪类与伪元素</a>伪类-状态-：  伪元素-真有元素-::</li><li>手写动画的最小时间间隔：多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms ＝ 16.7ms</li><li>CSS合并方法：css工具(sass/compass)将css合并成一个css文件</li><li>CSS不同选择器的权重(CSS层叠的规则)<a href="https://www.cnblogs.com/piaoyi1997/p/12530163.html" target="_blank" rel="noopener">内联样式表(1000)&gt;id选择符(100)&gt;class选择符(10)&gt;标签选择符(1)</a></li><li>改变页面布局的属性：display,padding,margin,postion,top,left,right,width,height,float</li><li>CSS性能优化:尽量用缩写、避免用滤镜、合理使用选择器</li><li>css3简单动画：旋转<br>3个属性：transition,transform,animation</li><li>base64原理及优缺点：Base64是用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个字符来表示二进制数据的方法;优点：可加密，减少HTTP请求;缺点：消耗CPU来编解码;base适用于小图片，体积约为原图3/4</li><li>常见CSS布局：流体布局,圣杯布局,双飞翼布局</li><li><a href="https://blog.csdn.net/ly2983068126/article/details/77737292" target="_blank" rel="noopener">stylus/sass/less区别</a><br>为三款不同的css预处理器</li><li><a href="https://www.jianshu.com/p/288963680642" target="_blank" rel="noopener">postcss</a></li><li>自定义字体的使用场景:宣传、品牌等固定文案;字体图标</li><li>美化CheckBox<br>Checkbox 对象代表一个 HTML 表单中的 一个选择框。3种方法</li><li><a href="https://zhuanlan.zhihu.com/p/25220324" target="_blank" rel="noopener">自适应布局</a></li><li>用css写一个简单的幻灯片效果-代码37</li><li>外边距重叠margin-collapse,相邻外边距结合成一个单独外边距<br>重叠结果：同正或同负，取绝对值最大;一正一负取两者和</li><li>透明效果rgba()仅作用于元素颜色及背景色，子元素不继承<br>opacity作用于元素及元素内容</li><li>css文字在垂直line-height与水平方向重叠letter-spacing</li><li>垂直居中一个浮动元素:已知宽高-父绝对，上左为50%，margin-top与margin-left为-1/2宽高;<br>未知宽高-父相对，margin:auto,上下左右均为0</li><li>px固定与em不固定区别：长度单位，em可继承，1em=16px,浏览器默认字体高16px</li><li>css的content属性：应用于before与after伪元素上，用于插入生成内容，应用：利用伪类清除浮动</li><li>水平居中(5种)，垂直居中5种【重点】</li><li>CSS实现硬件加速：创建独立的复合图层，让GPU来渲染这个图层，从而提高性能，css属性transform、opacity、filter</li><li><a href="https://www.cnblogs.com/soyxiaobi/p/9963019.html" target="_blank" rel="noopener">重绘与重排</a></li><li>css3的animation动画效果</li><li>左边宽度固定，右边自适应(代码)</li><li>垂直水平居中(5种–博客)</li><li>小于12px的字体–利用display:inline;//设成行内块元素<br>transform: scale(0.7);//缩放有宽高的元素<br><a href="http://blog.poetries.top/FE-Interview-Questions/base/#%E4%BA%8C%E3%80%81css%E9%83%A8%E5%88%86" target="_blank" rel="noopener">题库</a></li></ol><hr><h3 id="补充-css3学习"><a href="#补充-css3学习" class="headerlink" title="补充-css3学习"></a><a href="https://www.runoob.com/css3/css3-tutorial.html" target="_blank" rel="noopener">补充-css3学习</a></h3><p>CSS 用于控制网页的样式和布局,CSS3 是最新的 CSS 标准。模块化发展<br>【重点】选择器，盒模型，背景和边框，文字特效，2D/3D转换，动画动态盒子<br>1)border-radius使用(3种) 顺时针简写<br>   border-radius: 25px;<br>            /* background-color: blue; <em>/<br>            /</em> border: 1px solid red; <em>/<br>            /</em> background-image: url(bg.jpg) ; */<br>2)background背景 简写<br>background-image(可放多个背景图片,)/background-size/background-size/background-position/ background-repeat<br>background-origin:背景图片位置，三个值<br>  background-clip: content-box;默认：没有背景剪裁 border-box<br>3)渐变，减少下载的时间和宽带的使用;线性(下上左右对角)、径向渐变(中心，形状)<br>对角线性渐变background-image:linear-gradient(to top left,#e66465, #9198e5,blue);<br>透明度：创建逐渐变淡效果rgba() 函数来定义颜色结点，rgba() 函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。<br>径向渐变：默认椭圆background-image: radial-gradient(red, yellow, green);<br>4)文本效果：<br>text-shadow文字阴影：水平，垂直，阴影距离，颜色text-shadow: 5px 5px 5px #FF0000;<br>【做卡片】盒子阴影box-shadow: 10px 10px 5px #888888;//盒子距离，第三个属性值表模糊度<br>word-break:keep-all单词拆分、break-all换行;<br>5)CSS3字体：@font-face<br>6)2D/3D转换：移动、缩放、转动、拉长或拉伸，效果某元素改变大小，位置，形状<br>transform:translate()/rotate()/scale()/skew(倾斜角度)/matrix()<br>7)过渡transition–样式转变:添加效果样式，持续时间(样式转变更平滑)transition: width 2s;<br>简写属性：transition-property应用过渡的CSS名称<br>transition-duration默认为0,transition-timing-function,transition-delay何时开始<br>8)动画@keyframes 规则是创建动画,指定两个CSS3的动画属性(名称，时长)绑定一个选择器<br>动画是使元素从一种样式逐渐变化为另一种样式的效果。百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0%(开始) 和 100%(结束)且当动画完成时，会变回初始的样式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">   //animation所有动画属性的简写，除了animation-play-state 属性--动画运行或暂停。</span><br><span class="line">   animation: myfirst 5s;</span><br><span class="line">   &#125;</span><br><span class="line">@keyframes myfirst</span><br><span class="line">&#123;</span><br><span class="line">from &#123;background:red;&#125;</span><br><span class="line">to &#123;background:yellow;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9)CSS3 多列column–报纸<br>(分割数count、列间隙gap,列边框/厚度/颜色 rule-style/width/color–简写column-rule)</p><p>10)用户界面：调整元素尺寸，框尺寸和外边框resize,box-sizing,outline-offset<br>11)css图片img+border-radius实现圆角、椭圆形，缩略图<br>响应式图片–自动适配各种尺寸的屏幕<br>文字图片居中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line"> top: 50%;</span><br><span class="line"> width: 100%;</span><br><span class="line"> text-align: center;</span><br></pre></td></tr></table></figure><p>图片滤镜 img{filter:grayscale(100%)}<br>图片模态框(css+js)<br>12)<a href="https://www.runoob.com/css3/css3-buttons.html" target="_blank" rel="noopener">css按钮</a><br>13)css3分页：页面导航<br>14)框大小：CSS3 box-sizing 属性可以设置 width 和 height 属性中包含了 padding(内边距) 和 border(边框)。使用：box-sizing: border-box;<br>15)【重点：弹性盒子flex box】容器+子元素(一行，从左到右)<br>flex-direction 属性指定了弹性子元素在父容器中的位置。<br>弹性容器上：内容对齐（justify-content）属性-水平；align-item—垂直;flex-wrap 属性–子元素换行<br>【注】1.设置”margin”值为”auto”值，自动获取弹性容器中剩余的空间<br>居中：display:flex及margin:auto<br>2.flex 属性用于指定弹性子元素如何分配空间<br>flex: auto | initial | none | inherit |  [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]<br>16)<a href="https://www.runoob.com/css3/css3-mediaqueries-ex.html" target="_blank" rel="noopener">多媒体查询@media</a></p>]]></content>
    
    <summary type="html">
    
      基础篇-css部分
    
    </summary>
    
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
      <category term="基础篇" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>面试题01</title>
    <link href="http://yoursite.com/2020/03/21/%E9%9D%A2%E8%AF%95%E9%A2%9801/"/>
    <id>http://yoursite.com/2020/03/21/%E9%9D%A2%E8%AF%95%E9%A2%9801/</id>
    <published>2020-03-21T05:02:53.000Z</published>
    <updated>2020-03-22T03:05:58.663Z</updated>
    
    <content type="html"><![CDATA[<p>真的快哭死了，敲了三个小时的内容，一个保存–否，回到解放前！被自己蠢哭<br>所以我决定<a href="https://www.jb51.net/article/151649.htm" target="_blank" rel="noopener">在VScode中使用git</a></p><h2 id="基础篇-HTML-HTTP，Web综合问题"><a href="#基础篇-HTML-HTTP，Web综合问题" class="headerlink" title="[基础篇]HTML,HTTP，Web综合问题"></a>[基础篇]HTML,HTTP，Web综合问题</h2><ol><li>前端需要注意哪些SEO<br>SEO：搜索引擎优化<br>1)合理title&gt;description(内容高度概括)&gt;keyworks(关键字)<br>不同页面的title,description不同<br>2)语义化html代码，重要内容的html往前写，不用js输出<br>3)少用frame<br>4)非装饰性img加alt属性<br>5)提高网站的速度<a id="more"></a></li><li>HTTP的请求方法：GET POST PUT HEAD DELETE</li><li>【重点】 从浏览器地址栏输入url到显示页面的步骤</li><li>网站性能优化<br>js与css多用外链,尾与头部，减少DOM的数量与调用，较小cookie大小</li><li>HTTP状态码<br>1xx–信息状态码<br>2xx–成功状态码，200-正常返回<br>3xx–重定向,304上次请求后页面未修改<br>4xx–客户端错误，403禁止访问，404没找到资源<br>5xx–服务器错误，500服务器端错误</li><li>语义化理解<br>正确的标签做正确的事，利于SEO</li><li>浏览器内核–渲染引擎</li><li><a href="https://blog.csdn.net/weixin_41796631/article/details/89313941" target="_blank" rel="noopener">.appcache</a><br>AppCache就是对app内存缓存的方案，具体表现为当请求某个文件时不是从网络获取该文件，而是从本地获取。<br>优势：离线浏览,速度,减少服务器负载</li><li>【重点】cookies，sessionStorage 和 localStorage 的区别？存储地址,大小,寿命</li><li>iframe缺点：阻碍主页面onload事件;不利于SEO;影响页面并行加载;解决-js动态给iframe添加src属性</li><li>web标准与W3C标准<br>标签闭合，标签大小写，不乱嵌套，css与js外链</li><li>Doctype作用? &lt;!DOCTYPE&gt; 声明位于文档中的最前面，定义文档规范;不存在或错误使用时导致文档以混杂模式呈现<br>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为</li><li>行内元素：span img input a select<br>块元素：div h1-h6 p ul li dd<br>空元素：input img hr br link meta</li><li>全局属性：class title id style</li><li><a href="https://blog.csdn.net/yaodebian/article/details/84778425" target="_blank" rel="noopener">如何在页面上实现一个圆形的可点击区域？</a><br>svg–矢量图<br>border-radius=50%(css3)<br>纯js–有代码<ol start="22"><li>网页验证码(输入证书)<br>区分用户是否为人;防止黑客</li><li>渲染优化【理解】</li><li>你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?<br>IE: trident内核<br>Firefox：gecko内核<br>Safari:webkit内核<br>Opera:以前是presto内核，Opera现已改用Google - Chrome的Blink内核<br>Chrome:Blink(基于webkit，Google与Opera Software共同开发) </li></ol></li><li>div+css的布局较table布局有什么优点？<br>html与css分离，更改方便;加载速度快，结构化清晰，页面简洁，SEO友好</li><li>a：img的alt与title有何异同？b：strong与em的异同？</li><li>为什么利用多个域名来存储网站资源会更有效？<br>CDN缓存更方便<br>突破浏览器并发限制<br>节约cookie带宽<br>节约主域名的连接数，优化页面响应速度<br>防止不必要的安全问题 </li><li>src与href的区别<br>src替换当前元素，href当前文档和引用资源之间确立联系；<br>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接<br>link标签中href，并行下载资源对当前文档的处理</li><li>网页制作会用到的图片格式<br>png-8、png-24、jpeg、gif、svg,新技术：Webp(加快图片加载速度)与Apng(动态图标准)</li><li>在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？dns缓存，cdn缓存，浏览器缓存，服务器缓存</li><li>优化页面加载<br>图片懒加载等</li><li>常见排序算法的时间复杂度,空间复杂度【重点】</li><li>HTTP request报文结构是怎样的【掌握】</li><li>HTTP response报文结构是怎样的【掌握】</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真的快哭死了，敲了三个小时的内容，一个保存–否，回到解放前！被自己蠢哭&lt;br&gt;所以我决定&lt;a href=&quot;https://www.jb51.net/article/151649.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在VScode中使用git&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基础篇-HTML-HTTP，Web综合问题&quot;&gt;&lt;a href=&quot;#基础篇-HTML-HTTP，Web综合问题&quot; class=&quot;headerlink&quot; title=&quot;[基础篇]HTML,HTTP，Web综合问题&quot;&gt;&lt;/a&gt;[基础篇]HTML,HTTP，Web综合问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;前端需要注意哪些SEO&lt;br&gt;SEO：搜索引擎优化&lt;br&gt;1)合理title&amp;gt;description(内容高度概括)&amp;gt;keyworks(关键字)&lt;br&gt;不同页面的title,description不同&lt;br&gt;2)语义化html代码，重要内容的html往前写，不用js输出&lt;br&gt;3)少用frame&lt;br&gt;4)非装饰性img加alt属性&lt;br&gt;5)提高网站的速度
    
    </summary>
    
    
    
      <category term="前端面试" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
